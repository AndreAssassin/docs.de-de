---
title: Formate von Dateipfaden unter Windows-Systemen
ms.date: 06/06/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- I/O, long paths
- long paths
- path formats, Windows
ms.openlocfilehash: 258cf59fb8383fe131f4a0e78dac6189e1d9c91e
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 12/25/2019
ms.locfileid: "75337675"
---
# <a name="file-path-formats-on-windows-systems"></a><span data-ttu-id="3b294-102">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="3b294-102">File path formats on Windows systems</span></span>

<span data-ttu-id="3b294-103">Die Member vieler Typen im <xref:System.IO>-Namespace enthalten einen `path`-Parameter, mit dem Sie einen absoluten oder relativen Pfad zu einer Dateisystemressource festlegen können.</span><span class="sxs-lookup"><span data-stu-id="3b294-103">Members of many of the types in the <xref:System.IO> namespace include a `path` parameter that lets you specify an absolute or relative path to a file system resource.</span></span> <span data-ttu-id="3b294-104">Dieser Pfad wird dann an [Windows-Dateisystem-APIs](/windows/desktop/fileio/file-systems) übergeben.</span><span class="sxs-lookup"><span data-stu-id="3b294-104">This path is then passed to [Windows file system APIs](/windows/desktop/fileio/file-systems).</span></span> <span data-ttu-id="3b294-105">In diesem Artikel werden die Formate für Dateipfade erläutert, die Sie unter Windows-Systemen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="3b294-105">This topic discusses the formats for file paths that you can use on Windows systems.</span></span>

## <a name="traditional-dos-paths"></a><span data-ttu-id="3b294-106">Herkömmliche DOS-Pfade</span><span class="sxs-lookup"><span data-stu-id="3b294-106">Traditional DOS paths</span></span>

<span data-ttu-id="3b294-107">Ein standardmäßiger DOS-Pfad kann aus drei Komponenten bestehen:</span><span class="sxs-lookup"><span data-stu-id="3b294-107">A standard DOS path can consist of three components:</span></span>

- <span data-ttu-id="3b294-108">Ein Volume oder Laufwerkbuchstabe gefolgt von dem entsprechenden Trennzeichen (`:`).</span><span class="sxs-lookup"><span data-stu-id="3b294-108">A volume or drive letter followed by the volume separator (`:`).</span></span>
- <span data-ttu-id="3b294-109">Ein Verzeichnisname.</span><span class="sxs-lookup"><span data-stu-id="3b294-109">A directory name.</span></span> <span data-ttu-id="3b294-110">Das [Verzeichnistrennzeichen](<xref:System.IO.Path.DirectorySeparatorChar>) trennt Unterverzeichnisse innerhalb der geschachtelten Verzeichnishierarchie.</span><span class="sxs-lookup"><span data-stu-id="3b294-110">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="3b294-111">Ein optionaler Dateiname.</span><span class="sxs-lookup"><span data-stu-id="3b294-111">An optional filename.</span></span> <span data-ttu-id="3b294-112">Das [Verzeichnistrennzeichen](<xref:System.IO.Path.DirectorySeparatorChar>) trennt den Dateipfad und den Dateinamen.</span><span class="sxs-lookup"><span data-stu-id="3b294-112">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="3b294-113">Wenn alle drei Komponenten vorhanden sind, ist der Pfad absolut.</span><span class="sxs-lookup"><span data-stu-id="3b294-113">If all three components are present, the path is absolute.</span></span> <span data-ttu-id="3b294-114">Wenn kein Volume oder Laufwerkbuchstabe angegeben ist und der Name des Verzeichnisses mit dem [Verzeichnistrennzeichen](<xref:System.IO.Path.DirectorySeparatorChar>) beginnt, ist der Pfad relativ zum Stamm des aktuellen Laufwerks.</span><span class="sxs-lookup"><span data-stu-id="3b294-114">If no volume or drive letter is specified and the directory name begins with the [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>), the path is relative from the root of the current drive.</span></span> <span data-ttu-id="3b294-115">Andernfalls ist der Pfad relativ zum aktuellen Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="3b294-115">Otherwise, the path is relative to the current directory.</span></span> <span data-ttu-id="3b294-116">In der folgenden Tabelle werden mögliche Verzeichnis- und Dateipfade veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="3b294-116">The following table shows some possible directory and file paths.</span></span>

|<span data-ttu-id="3b294-117">Pfad</span><span class="sxs-lookup"><span data-stu-id="3b294-117">Path</span></span>  |<span data-ttu-id="3b294-118">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3b294-118">Description</span></span>  |
| -- | -- |
| `C:\Documents\Newsletters\Summer2018.pdf` | <span data-ttu-id="3b294-119">Ein absoluter Dateipfad aus dem Stamm vom Laufwerk „C:“</span><span class="sxs-lookup"><span data-stu-id="3b294-119">An absolute file path from the root of drive C:</span></span> |
| `\Program Files\Custom Utilities\StringFinder.exe` | <span data-ttu-id="3b294-120">Ein absoluter Pfad aus dem Stamm des aktuellen Laufwerks</span><span class="sxs-lookup"><span data-stu-id="3b294-120">An absolute path from the root of the current drive.</span></span> |
| `2018\January.xlsx` | <span data-ttu-id="3b294-121">Ein relativer Pfad zu einer Datei in einem Unterverzeichnis des aktuellen Verzeichnisses</span><span class="sxs-lookup"><span data-stu-id="3b294-121">A relative path to a file in a subdirectory of the current directory.</span></span> |
| `..\Publications\TravelBrochure.pdf` | <span data-ttu-id="3b294-122">Ein relativer Pfad zu einer Datei in einem Verzeichnis, das ein Peer des aktuellen Verzeichnisses ist</span><span class="sxs-lookup"><span data-stu-id="3b294-122">A relative path to file in a directory that is a peer of the current directory.</span></span> |
| `C:\Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="3b294-123">Ein absoluter Pfad zu einer Datei aus dem Stamm vom Laufwerk „C:“</span><span class="sxs-lookup"><span data-stu-id="3b294-123">An absolute path to a file from the root of drive C:</span></span> |
| `C:Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="3b294-124">Ein relativer Pfad aus dem aktuellen Verzeichnis des Laufwerks „C:“</span><span class="sxs-lookup"><span data-stu-id="3b294-124">A relative path from the current directory of the C: drive.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="3b294-125">Beachten Sie den Unterschied zwischen den letzten beiden Pfaden.</span><span class="sxs-lookup"><span data-stu-id="3b294-125">Note the difference between the last two paths.</span></span> <span data-ttu-id="3b294-126">Beide geben den optionalen Volumebezeichner (in beiden Fällen „C:“) an, jedoch beginnt der erste im Gegensatz zum zweiten mit dem Stamm des angegebenen Volume.</span><span class="sxs-lookup"><span data-stu-id="3b294-126">Both specify the optional volume specifier (C: in both cases), but the first begins with the root of the specified volume, whereas the second does not.</span></span> <span data-ttu-id="3b294-127">Daher ist der erste ein absoluter Pfad aus dem Stammverzeichnis vom Laufwerk „C:“, während der zweite ein relativer Pfad aus dem aktuellen Verzeichnis vom Laufwerk „C:“ ist.</span><span class="sxs-lookup"><span data-stu-id="3b294-127">As result, the first is an absolute path from the root directory of drive C:, whereas the second is a relative path from the current directory of drive C:.</span></span> <span data-ttu-id="3b294-128">Verwenden Sie das zweite Format, wenn das erste als Ursache für Fehler mit Windows-Dateipfaden bekannt ist.</span><span class="sxs-lookup"><span data-stu-id="3b294-128">Use of the second form when the first is intended is a common source of bugs that involve Windows file paths.</span></span>

<span data-ttu-id="3b294-129">Sie können ermitteln, ob ein Dateipfad absolut ist (d.h. der Pfad ist unabhängig vom aktuellen Verzeichnis und ändert sich nicht, wenn das aktuelle Verzeichnis geändert wird), indem Sie die Methode <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> aufrufen.</span><span class="sxs-lookup"><span data-stu-id="3b294-129">You can determine whether a file path is fully qualified (that is, it the path is independent of the current directory and does not change when the current directory changes) by calling the <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> method.</span></span> <span data-ttu-id="3b294-130">Beachten Sie, dass ein solcher Pfad relative Verzeichnissegmente (`.` und `..`) enthalten und weiterhin absolut sein kann, wenn der aufgelöste Pfad immer zum gleichen Speicherort führt.</span><span class="sxs-lookup"><span data-stu-id="3b294-130">Note that such a path can include relative directory segments (`.` and `..`) and still be fully qualified if the resolved path always points to the same location.</span></span>

<span data-ttu-id="3b294-131">Im folgenden Beispiel wird der Unterschied zwischen absoluten und relativen Pfaden veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="3b294-131">The following example illustrates the difference between absolute and relative paths.</span></span> <span data-ttu-id="3b294-132">Es wird davon ausgegangen, dass das Verzeichnis „D:\FY2018\“ vorhanden ist, und dass Sie kein aktuelles Verzeichnis für „D:\“ über die Eingabeaufforderung festgelegt haben, bevor Sie das Beispiel ausführen.</span><span class="sxs-lookup"><span data-stu-id="3b294-132">It assumes that the directory D:\FY2018\ exists, and that you haven't set any current directory for D:\ from the command prompt before running the example.</span></span>

[!code-csharp[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/cs/paths.cs)]
[!code-vb[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/vb/paths.vb)]

## <a name="unc-paths"></a><span data-ttu-id="3b294-133">UNC-Pfade</span><span class="sxs-lookup"><span data-stu-id="3b294-133">UNC paths</span></span>

<span data-ttu-id="3b294-134">UNC-Pfade (Universal Naming Convention), die für den Zugriff auf Netzwerkressourcen verwendet werden, weisen das folgende Format auf:</span><span class="sxs-lookup"><span data-stu-id="3b294-134">Universal naming convention (UNC) paths, which are used to access network resources, have the following format:</span></span>

- <span data-ttu-id="3b294-135">Ein Server- oder Hostname, dem \\\\ vorangestellt ist.</span><span class="sxs-lookup"><span data-stu-id="3b294-135">A server or host name, which is prefaced by \\\\.</span></span> <span data-ttu-id="3b294-136">Der Servername kann ein NetBIOS-Computername oder eine IP-/FQDN-Adresse sein (IPv4 und v6 werden unterstützt).</span><span class="sxs-lookup"><span data-stu-id="3b294-136">The server name can be a NetBIOS machine name or an IP/FQDN address (IPv4 as well as v6 are supported).</span></span>
- <span data-ttu-id="3b294-137">Ein Freigabename, der durch \\ vom Hostnamen getrennt wird.</span><span class="sxs-lookup"><span data-stu-id="3b294-137">A share name, which is separated from the host name by \\.</span></span> <span data-ttu-id="3b294-138">Gemeinsam bilden der Server- und Freigabename das Volume.</span><span class="sxs-lookup"><span data-stu-id="3b294-138">Together, the server and share name make up the volume.</span></span>
- <span data-ttu-id="3b294-139">Ein Verzeichnisname.</span><span class="sxs-lookup"><span data-stu-id="3b294-139">A directory name.</span></span> <span data-ttu-id="3b294-140">Das [Verzeichnistrennzeichen](<xref:System.IO.Path.DirectorySeparatorChar>) trennt Unterverzeichnisse innerhalb der geschachtelten Verzeichnishierarchie.</span><span class="sxs-lookup"><span data-stu-id="3b294-140">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="3b294-141">Ein optionaler Dateiname.</span><span class="sxs-lookup"><span data-stu-id="3b294-141">An optional filename.</span></span> <span data-ttu-id="3b294-142">Das [Verzeichnistrennzeichen](<xref:System.IO.Path.DirectorySeparatorChar>) trennt den Dateipfad und den Dateinamen.</span><span class="sxs-lookup"><span data-stu-id="3b294-142">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="3b294-143">Im Folgenden werden einige Beispiele für UNC-Pfade aufgeführt:</span><span class="sxs-lookup"><span data-stu-id="3b294-143">The following are some examples of UNC paths:</span></span>

|<span data-ttu-id="3b294-144">Pfad</span><span class="sxs-lookup"><span data-stu-id="3b294-144">Path</span></span>  |<span data-ttu-id="3b294-145">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3b294-145">Description</span></span>  |
| -- | -- |
| `\\system07\C$\` | <span data-ttu-id="3b294-146">Das Stammverzeichnis des Laufwerks „C:“ auf `system07`.</span><span class="sxs-lookup"><span data-stu-id="3b294-146">The root directory of the C: drive on `system07`.</span></span> |
| `\\Server2\Share\Test\Foo.txt` | <span data-ttu-id="3b294-147">Die Datei „Foo.txt“ im Testverzeichnis des Volume „\\\\Server2\\Share“.</span><span class="sxs-lookup"><span data-stu-id="3b294-147">The Foo.txt file in the Test directory of the \\\\Server2\\Share volume.</span></span>|

<span data-ttu-id="3b294-148">UNC-Pfade müssen immer absolut sein.</span><span class="sxs-lookup"><span data-stu-id="3b294-148">UNC paths must always be fully qualified.</span></span> <span data-ttu-id="3b294-149">Sie können relative Verzeichnissegmente (`.` und `..`) enthalten, jedoch müssen diese Teil eines absoluten Pfads sein.</span><span class="sxs-lookup"><span data-stu-id="3b294-149">They can include relative directory segments (`.` and `..`), but these must be part of a fully qualified path.</span></span> <span data-ttu-id="3b294-150">Sie können relative Pfade nur verwenden, indem Sie einem Laufwerkbuchstaben einen UNC-Pfad zuordnen.</span><span class="sxs-lookup"><span data-stu-id="3b294-150">You can use relative paths only by mapping a UNC path to a drive letter.</span></span>

## <a name="dos-device-paths"></a><span data-ttu-id="3b294-151">DOS-Gerätepfade</span><span class="sxs-lookup"><span data-stu-id="3b294-151">DOS device paths</span></span>

<span data-ttu-id="3b294-152">Das Windows-Betriebssystem verfügt über ein einheitliches Objektmodell, das auf alle Ressourcen, einschließlich Dateien, verweist.</span><span class="sxs-lookup"><span data-stu-id="3b294-152">The Windows operating system has a unified object model that points to all resources, including files.</span></span> <span data-ttu-id="3b294-153">Sie können über das Konsolenfenster auf diese Objektpfade zugreifen. Diese werden über einen speziellen Ordner aus symbolischen Verknüpfungen, denen ältere DOS- und UNC-Pfade zugeordnet sind, für die Win32-Schicht zur Verfügung gestellt.</span><span class="sxs-lookup"><span data-stu-id="3b294-153">These object paths are accessible from the console window and are exposed to the Win32 layer through a special folder of symbolic links that legacy DOS and UNC paths are mapped to.</span></span> <span data-ttu-id="3b294-154">Der Zugriff auf diesen speziellen Ordner erfolgt über die DOS-Gerätepfadsyntax, die einer der Folgenden entspricht:</span><span class="sxs-lookup"><span data-stu-id="3b294-154">This special folder is accessed via the DOS device path syntax, which is one of:</span></span>

`\\.\C:\Test\Foo.txt`
`\\?\C:\Test\Foo.txt`

<span data-ttu-id="3b294-155">Zusätzlich zum Identifizieren eines Laufwerks anhand des Laufwerkbuchstabens können Sie ein Volume mithilfe des Volume-GUID identifizieren.</span><span class="sxs-lookup"><span data-stu-id="3b294-155">In addition to identifying a drive by its drive letter, you can identify a volume by using its volume GUID.</span></span> <span data-ttu-id="3b294-156">Dieser weist folgendes Format auf:</span><span class="sxs-lookup"><span data-stu-id="3b294-156">This takes the form:</span></span>

`\\.\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`
`\\?\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`

> [!NOTE]
> <span data-ttu-id="3b294-157">Die DOS-Gerätepfadsyntax wird beginnend mit .NET Core 1.1 und .NET Framework 4.6.2 von .NET-Implementierungen unterstützt, die unter Windows ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3b294-157">DOS device path syntax is supported on .NET implementations running on Windows starting with .NET Core 1.1 and .NET Framework 4.6.2.</span></span>

<span data-ttu-id="3b294-158">Der DOS-Gerätepfad besteht aus den folgenden Komponenten:</span><span class="sxs-lookup"><span data-stu-id="3b294-158">The DOS device path consists of the following components:</span></span>

- <span data-ttu-id="3b294-159">Der Gerätepfadbezeichner (`\\.\` oder `\\?\`), der den Pfad als DOS-Gerätepfad identifiziert.</span><span class="sxs-lookup"><span data-stu-id="3b294-159">The device path specifier (`\\.\` or `\\?\`), which identifies the path as a DOS device path.</span></span>

   > [!NOTE]
   > <span data-ttu-id="3b294-160">`\\?\` wird in allen Versionen von .NET Core und ab Version 4.6.2 von .NET Framework unterstützt.</span><span class="sxs-lookup"><span data-stu-id="3b294-160">The `\\?\` is supported in all versions of .NET Core and in the .NET Framework starting with version 4.6.2.</span></span>

- <span data-ttu-id="3b294-161">Ein symbolischer Link zum „echten“ Geräteobjekt (im Fall eines Laufwerknamens „C:“, im Fall eines Volume-GUID „Volume{b75e2c83-0000-0000-0000-602f00000000}“).</span><span class="sxs-lookup"><span data-stu-id="3b294-161">A symbolic link to the "real" device object (C: in the case of a drive name, or Volume{b75e2c83-0000-0000-0000-602f00000000} in the case of a volume GUID).</span></span>

   <span data-ttu-id="3b294-162">Das erste Segment des DOS-Gerätepfads, nachdem der Gerätepfadbezeichner das Volume oder Laufwerk identifiziert.</span><span class="sxs-lookup"><span data-stu-id="3b294-162">The first segment of the DOS device path after the device path specifier identifies the volume or drive.</span></span> <span data-ttu-id="3b294-163">(Zum Beispiel `\\?\C:\` und `\\.\BootPartition\`.)</span><span class="sxs-lookup"><span data-stu-id="3b294-163">(For example, `\\?\C:\` and `\\.\BootPartition\`.)</span></span>

   <span data-ttu-id="3b294-164">Es gibt eine spezifische Verknüpfung für UNC-Pfade mit dem unverwechselbaren Namen `UNC`.</span><span class="sxs-lookup"><span data-stu-id="3b294-164">There is a specific link for UNCs that is called, not surprisingly, `UNC`.</span></span> <span data-ttu-id="3b294-165">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="3b294-165">For example:</span></span>

  `\\.\UNC\Server\Share\Test\Foo.txt`
  `\\?\UNC\Server\Share\Test\Foo.txt`

    <span data-ttu-id="3b294-166">Bei Geräte-UNCs bildet der Abschnitt „server/share“ das Volume.</span><span class="sxs-lookup"><span data-stu-id="3b294-166">For device UNCs, the server/share portion forms the volume.</span></span> <span data-ttu-id="3b294-167">Zum Beispiel entspricht der Abschnitt „server/share“ bei `\\?\server1\e:\utilities\\filecomparer\` „server1\utilities“.</span><span class="sxs-lookup"><span data-stu-id="3b294-167">For example, in `\\?\server1\e:\utilities\\filecomparer\`, the server/share portion is server1\utilities.</span></span> <span data-ttu-id="3b294-168">Dies ist beim Aufrufen einer Methode mit relativen Verzeichnissegmenten wie <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> wichtig. Es ist nicht möglich, weiter als zum Volume zu navigieren.</span><span class="sxs-lookup"><span data-stu-id="3b294-168">This is significant when calling a method such as <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> with relative directory segments; it is never possible to navigate past the volume.</span></span>

<span data-ttu-id="3b294-169">DOS-Gerätepfade sind definitionsgemäß absolut.</span><span class="sxs-lookup"><span data-stu-id="3b294-169">DOS device paths are fully qualified by definition.</span></span> <span data-ttu-id="3b294-170">Die relativen Verzeichnissegmente (`.` und `..`) sind nicht zulässig.</span><span class="sxs-lookup"><span data-stu-id="3b294-170">Relative directory segments (`.` and `..`) are not allowed.</span></span> <span data-ttu-id="3b294-171">Aktuelle Verzeichnisse haben bei Verwendung von UNC-Pfaden keine Relevanz.</span><span class="sxs-lookup"><span data-stu-id="3b294-171">Current directories never enter into their usage.</span></span>

## <a name="example-ways-to-refer-to-the-same-file"></a><span data-ttu-id="3b294-172">Beispiel: Möglichkeiten zum Verweisen auf dieselbe Datei</span><span class="sxs-lookup"><span data-stu-id="3b294-172">Example: Ways to refer to the same file</span></span>

<span data-ttu-id="3b294-173">Im folgenden Beispiel werden einige Möglichkeiten zum Verweisen auf eine Datei veranschaulicht, wenn Sie die APIs des <xref:System.IO>-Namespace verwenden.</span><span class="sxs-lookup"><span data-stu-id="3b294-173">The following example illustrates some of the ways in which you can refer to a file when using the APIs in the <xref:System.IO> namespace.</span></span> <span data-ttu-id="3b294-174">Im Beispiel wird ein <xref:System.IO.FileInfo>-Objekt instanziiert und dessen <xref:System.IO.FileInfo.Name>- und <xref:System.IO.FileInfo.Length>-Eigenschaften verwendet, um den Dateinamen und die Dateigröße anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="3b294-174">The example instantiates a <xref:System.IO.FileInfo> object and uses its <xref:System.IO.FileInfo.Name> and <xref:System.IO.FileInfo.Length> properties to display the filename and the length of the file.</span></span>

[!code-csharp[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/cs/file-refs.cs)]
[!code-vb[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/vb/file-refs.vb)]

## <a name="path-normalization"></a><span data-ttu-id="3b294-175">Pfadnormalisierung</span><span class="sxs-lookup"><span data-stu-id="3b294-175">Path normalization</span></span>

<span data-ttu-id="3b294-176">Die meisten Pfade, die an Windows-APIs übergeben werden, werden normalisiert.</span><span class="sxs-lookup"><span data-stu-id="3b294-176">Almost all paths passed to Windows APIs are normalized.</span></span> <span data-ttu-id="3b294-177">Während der Normalisierung führt Windows die folgenden Schritte durch:</span><span class="sxs-lookup"><span data-stu-id="3b294-177">During normalization, Windows performs the following steps:</span></span>

- <span data-ttu-id="3b294-178">Der Pfad wird identifiziert.</span><span class="sxs-lookup"><span data-stu-id="3b294-178">Identifies the path.</span></span>
- <span data-ttu-id="3b294-179">Das aktuelle Verzeichnis wird auf relative Pfade angewandt.</span><span class="sxs-lookup"><span data-stu-id="3b294-179">Applies the current directory to partially qualified (relative) paths.</span></span>
- <span data-ttu-id="3b294-180">Komponenten und Verzeichnistrennzeichen werden kanonisiert.</span><span class="sxs-lookup"><span data-stu-id="3b294-180">Canonicalizes component and directory separators.</span></span>
- <span data-ttu-id="3b294-181">Relative Verzeichniskomponenten werden ausgewertet (`.` für das aktuelle Verzeichnis und `..` für das übergeordnete Verzeichnis).</span><span class="sxs-lookup"><span data-stu-id="3b294-181">Evaluates relative directory components (`.` for the current directory and `..` for the parent directory).</span></span>
- <span data-ttu-id="3b294-182">Bestimmte Zeichen werden gekürzt.</span><span class="sxs-lookup"><span data-stu-id="3b294-182">Trims certain characters.</span></span>

<span data-ttu-id="3b294-183">Diese Normalisierung erfolgt implizit, Sie können sie jedoch explizit ausführen, indem Sie die Methode <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> aufrufen, die einen Aufruf der [GetFullPathName()-Funktion](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) umschließt.</span><span class="sxs-lookup"><span data-stu-id="3b294-183">This normalization happens implicitly, but you can do it explicitly by calling the <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> method, which wraps a call to the  [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span> <span data-ttu-id="3b294-184">Sie können die Windows-Funktion [GetFullPathName()](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) auch aufrufen, indem Sie „P/Invoke“ verwenden</span><span class="sxs-lookup"><span data-stu-id="3b294-184">You can also call the Windows [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) directly using P/Invoke.</span></span>

### <a name="identifying-the-path"></a><span data-ttu-id="3b294-185">Identifizieren des Pfads</span><span class="sxs-lookup"><span data-stu-id="3b294-185">Identifying the path</span></span>

<span data-ttu-id="3b294-186">Der erste Schritt der Pfadnormalisierung ist das Identifizieren des Pfadtyps.</span><span class="sxs-lookup"><span data-stu-id="3b294-186">The first step in path normalization is identifying the type of path.</span></span> <span data-ttu-id="3b294-187">Pfade gehören zu einer von wenigen Kategorien:</span><span class="sxs-lookup"><span data-stu-id="3b294-187">Paths fall into one of a few categories:</span></span>

- <span data-ttu-id="3b294-188">Gerätepfade, d.h. sie beginnen mit zwei Trennzeichen und einem Fragezeichen oder einem Punkt (`\\?` oder `\\.`).</span><span class="sxs-lookup"><span data-stu-id="3b294-188">They are device paths; that is, they begin with two separators and a question mark or period (`\\?` or `\\.`).</span></span>
- <span data-ttu-id="3b294-189">UNC-Pfade, d.h. sie beginnen mit zwei Trennzeichen ohne einem Fragezeichen oder Punkt.</span><span class="sxs-lookup"><span data-stu-id="3b294-189">They are UNC paths; that is, they begin with two separators without a question mark or period.</span></span>
- <span data-ttu-id="3b294-190">Absolute DOS-Pfade, d.h. sie beginnen mit einem Laufwerkbuchstaben, einem Volumetrennzeichen und einem Komponententrennzeichen (`C:\`).</span><span class="sxs-lookup"><span data-stu-id="3b294-190">They are fully qualified DOS paths; that is, they begin with a drive letter, a volume separator, and a component separator (`C:\`).</span></span>
- <span data-ttu-id="3b294-191">Sie legen ein Legacygerät fest (`CON`, `LPT1`).</span><span class="sxs-lookup"><span data-stu-id="3b294-191">They designate a legacy device (`CON`, `LPT1`).</span></span>
- <span data-ttu-id="3b294-192">Sie sind relativ zum Stamm des aktuellen Laufwerks, d.h. sie beginnen mit einem einzelnen Komponententrennzeichen (`\`).</span><span class="sxs-lookup"><span data-stu-id="3b294-192">They are relative to the root of the current drive; that is, they begin with a single component separator (`\`).</span></span>
- <span data-ttu-id="3b294-193">Sie sind relativ zum aktuellen Verzeichnis eines angegebenen Laufwerks, d.h. sie beginnen mit einem Laufwerkbuchstaben, einem Volumetrennzeichen und keinem Komponententrennzeichen (`C:`).</span><span class="sxs-lookup"><span data-stu-id="3b294-193">They are relative to the current directory of a specified drive; that is, they begin with a drive letter, a volume separator, and no component separator (`C:`).</span></span>
- <span data-ttu-id="3b294-194">Sie sind relativ zum aktuellen Verzeichnis, d.h. sie beginnen mit etwas anderem (`temp\testfile.txt`).</span><span class="sxs-lookup"><span data-stu-id="3b294-194">They are relative to the current directory; that is, they begin with anything else (`temp\testfile.txt`).</span></span>

<span data-ttu-id="3b294-195">Der Typ des Pfad bestimmt, ob ein aktuelles Verzeichnis in irgendeiner Weise angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="3b294-195">The type of the path determines whether or not a current directory is applied in some way.</span></span> <span data-ttu-id="3b294-196">Er bestimmt auch den „Stamm“ des Pfads.</span><span class="sxs-lookup"><span data-stu-id="3b294-196">It also determines what the "root" of the path is.</span></span>

### <a name="handling-legacy-devices"></a><span data-ttu-id="3b294-197">Handhaben von Legacygeräten</span><span class="sxs-lookup"><span data-stu-id="3b294-197">Handling legacy devices</span></span>

<span data-ttu-id="3b294-198">Wenn der Pfad ein DOS-Legacygerät wie `CON`, `COM1` oder `LPT1` ist, wird er durch Voranstellen von `\\.\` in einen Gerätepfad konvertiert und zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3b294-198">If the path is a legacy DOS device such as `CON`, `COM1`, or `LPT1`, it is converted into a device path by prepending `\\.\` and returned.</span></span>

<span data-ttu-id="3b294-199">Ein Pfad, der mit einem Legacygerätenamen beginnt, wird von der Methode <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> immer als Legacygerät interpretiert.</span><span class="sxs-lookup"><span data-stu-id="3b294-199">A path that begins with a legacy device name is always interpreted as a legacy device by the <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3b294-200">Beispielsweise ist der DOS-Gerätepfad für `CON.TXT``\\.\CON`, und der DOS-Gerätepfad für `COM1.TXT\file1.txt` ist `\\.\COM1`.</span><span class="sxs-lookup"><span data-stu-id="3b294-200">For example, the DOS device path for `CON.TXT` is `\\.\CON`, and the DOS device path for `COM1.TXT\file1.txt` is `\\.\COM1`.</span></span>

### <a name="applying-the-current-directory"></a><span data-ttu-id="3b294-201">Anwenden des aktuellen Verzeichnisses</span><span class="sxs-lookup"><span data-stu-id="3b294-201">Applying the current directory</span></span>

<span data-ttu-id="3b294-202">Wenn ein Pfad nicht absolut ist, wendet Windows das aktuelle Verzeichnis an.</span><span class="sxs-lookup"><span data-stu-id="3b294-202">If a path isn't fully qualified, Windows applies the current directory to it.</span></span> <span data-ttu-id="3b294-203">Das aktuelle Verzeichnis wird nicht auf UNC- und Gerätepfade angewendet.</span><span class="sxs-lookup"><span data-stu-id="3b294-203">UNCs and device paths do not have the current directory applied.</span></span> <span data-ttu-id="3b294-204">Auch nicht auf ein volles Laufwerk mit dem Trennzeichen C:\\.</span><span class="sxs-lookup"><span data-stu-id="3b294-204">Neither does a full drive with separator C:\\.</span></span>

<span data-ttu-id="3b294-205">Wenn der Pfad mit einem einzelnen Komponententrennzeichen beginnt, wird das Laufwerk des aktuellen Verzeichnisses angewendet.</span><span class="sxs-lookup"><span data-stu-id="3b294-205">If the path starts with a single component separator, the drive from the current directory is applied.</span></span> <span data-ttu-id="3b294-206">Wenn der Gerätepfad beispielsweise `\utilities` entspricht und das aktuelle Verzeichnis `C:\temp\` ist, erzeugt die Normalisierung `C:\utilities`.</span><span class="sxs-lookup"><span data-stu-id="3b294-206">For example, if the file path is `\utilities` and the current directory is `C:\temp\`, normalization produces `C:\utilities`.</span></span>

<span data-ttu-id="3b294-207">Wenn der Pfad mit einem Laufwerkbuchstaben, einem Volumetrennzeichen und keinem Komponententrennzeichen beginnt, wird das letzte über die Befehlsshell festgelegte aktuelle Verzeichnis für das angegebene Laufwerk angewendet.</span><span class="sxs-lookup"><span data-stu-id="3b294-207">If the path starts with a drive letter, volume separator, and no component separator, the last current directory set from the command shell for the specified drive is applied.</span></span> <span data-ttu-id="3b294-208">Wenn das letzte aktuelle Verzeichnis nicht festgelegt wurde, wird nur das Laufwerk angewendet.</span><span class="sxs-lookup"><span data-stu-id="3b294-208">If the last current directory was not set, the drive alone is applied.</span></span> <span data-ttu-id="3b294-209">Wenn der Dateipfad beispielsweise `D:sources` entspricht, das aktuelle Verzeichnis `C:\Documents\` ist, und das letzte aktuelle Verzeichnis auf Laufwerk „D:“ `D:\sources\` war, ist das Ergebnis `D:\sources\sources`.</span><span class="sxs-lookup"><span data-stu-id="3b294-209">For example, if the file path is `D:sources`, the current directory is `C:\Documents\`, and the last current directory on drive D: was `D:\sources\`, the result is `D:\sources\sources`.</span></span> <span data-ttu-id="3b294-210">Diese „zum Laufwerk relativen“ Pfade sind eine häufige Ursache für Logikfehler beim Programm und Skript.</span><span class="sxs-lookup"><span data-stu-id="3b294-210">These "drive relative" paths are a common source of program and script logic errors.</span></span> <span data-ttu-id="3b294-211">Die Annahme, dass ein Pfad, der mit einem Buchstaben und einem Doppelpunkt beginnt, nicht relativ ist, ist offensichtlich falsch.</span><span class="sxs-lookup"><span data-stu-id="3b294-211">Assuming that a path beginning with a letter and a colon isn't relative is obviously not correct.</span></span>

<span data-ttu-id="3b294-212">Wenn der Pfad mit etwas anderem als einem Trennzeichen beginnt, werden das aktuelle Laufwerk und das aktuelle Verzeichnis angewendet.</span><span class="sxs-lookup"><span data-stu-id="3b294-212">If the path starts with something other than a separator, the current drive and current directory are applied.</span></span> <span data-ttu-id="3b294-213">Wenn der Pfad beispielsweise `filecompare` entspricht, und das aktuelle Verzeichnis `C:\utilities\` ist, ist das Ergebnis `C:\utilities\filecompare\`.</span><span class="sxs-lookup"><span data-stu-id="3b294-213">For example, if the path is `filecompare` and the current directory is `C:\utilities\`, the result is `C:\utilities\filecompare\`.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="3b294-214">Relative Pfade sind in Multithreadanwendungen gefährlich (d.h. in den meisten Anwendungen), da das aktuelle Verzeichnis eine prozessspezifische Einstellung ist.</span><span class="sxs-lookup"><span data-stu-id="3b294-214">Relative paths are dangerous in multithreaded applications (that is, most applications) because the current directory is a per-process setting.</span></span> <span data-ttu-id="3b294-215">Jeder Thread kann das aktuelle Verzeichnis jederzeit ändern.</span><span class="sxs-lookup"><span data-stu-id="3b294-215">Any thread can change the current directory at any time.</span></span> <span data-ttu-id="3b294-216">Beginnend mit .NET Core 2.1 können Sie die Methode <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> aufrufen, um einen absoluten Pfad von einem relativen Pfad und dem Basispfad (dem aktuellen Verzeichnis) abzurufen, gegen die Sie auflösen möchten.</span><span class="sxs-lookup"><span data-stu-id="3b294-216">Starting with .NET Core 2.1, you can call the <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> method to get an absolute path from a relative path and the base path (the current directory) that you want to resolve it against.</span></span>

### <a name="canonicalizing-separators"></a><span data-ttu-id="3b294-217">Kanonisierende Trennzeichen</span><span class="sxs-lookup"><span data-stu-id="3b294-217">Canonicalizing separators</span></span>

<span data-ttu-id="3b294-218">Alle führenden Schrägstriche (`/`) werden in das standardmäßige Trennzeichen von Windows konvertiert, den umgekehrten Schrägstrich (`\`).</span><span class="sxs-lookup"><span data-stu-id="3b294-218">All forward slashes (`/`) are converted into the standard Windows separator, the back slash (`\`).</span></span> <span data-ttu-id="3b294-219">Wenn sie vorhanden sind, wird eine Reihe von Schrägstrichen, die auf die ersten zwei Schrägstriche folgt, auf einen einzelnen Schrägstrich reduziert.</span><span class="sxs-lookup"><span data-stu-id="3b294-219">If they are present, a series of slashes that follow the first two slashes are collapsed into a single slash.</span></span>

### <a name="evaluating-relative-components"></a><span data-ttu-id="3b294-220">Auswerten relativer Komponenten</span><span class="sxs-lookup"><span data-stu-id="3b294-220">Evaluating relative components</span></span>

<span data-ttu-id="3b294-221">Während der Pfad verarbeitet wird, werden alle Komponenten oder Segmente ausgewertet, die aus einem oder zwei Punkten (`.` oder `..`) bestehen:</span><span class="sxs-lookup"><span data-stu-id="3b294-221">As the path is processed, any components or segments that are composed of a single or a double period (`.` or `..`) are evaluated:</span></span>

- <span data-ttu-id="3b294-222">Bei einzelnen Punkten wird das aktuelle Segment entfernt, da es auf das aktuelle Verzeichnis verweist.</span><span class="sxs-lookup"><span data-stu-id="3b294-222">For a single period, the current segment is removed, since it refers to the current directory.</span></span>

- <span data-ttu-id="3b294-223">Bei zwei Punkten werden das aktuelle Segment und das übergeordnete Segment entfernt, da die zwei Punkte auf das übergeordnetes Verzeichnis verweisen.</span><span class="sxs-lookup"><span data-stu-id="3b294-223">For a double period, the current segment and the parent segment are removed, since the double period refers to the parent directory.</span></span>

   <span data-ttu-id="3b294-224">Übergeordnete Verzeichnisse werden nur entfernt, wenn sie sich nicht nach dem Stamm des Pfads befinden.</span><span class="sxs-lookup"><span data-stu-id="3b294-224">Parent directories are only removed if they aren't past the root of the path.</span></span> <span data-ttu-id="3b294-225">Der Stamm des Pfads ist abhängig von der Art des Pfads.</span><span class="sxs-lookup"><span data-stu-id="3b294-225">The root of the path depends on the type of path.</span></span> <span data-ttu-id="3b294-226">Für DOS-Pfade ist es das Laufwerk (`C:\`), für UNC-Pfade ist es „server/share“ (`\\Server\Share`) und für Gerätepfade ist es das Gerätepfadpräfix (`\\?\` oder `\\.\`).</span><span class="sxs-lookup"><span data-stu-id="3b294-226">It is the drive (`C:\`) for DOS paths, the server/share for UNCs (`\\Server\Share`), and the device path prefix for device paths (`\\?\` or `\\.\`).</span></span>

### <a name="trimming-characters"></a><span data-ttu-id="3b294-227">Entfernen von Zeichen</span><span class="sxs-lookup"><span data-stu-id="3b294-227">Trimming characters</span></span>

<span data-ttu-id="3b294-228">Zusätzlich zu den Ausführungen von Trennzeichen und Segmenten, die weiter oben entfernt wurden, werden einige zusätzliche Zeichen während der Normalisierung entfernt:</span><span class="sxs-lookup"><span data-stu-id="3b294-228">Along with the runs of separators and relative segments removed earlier, some additional characters are removed during normalization:</span></span>

- <span data-ttu-id="3b294-229">Wenn ein Segment mit einem einzelnen Punkt endet, wird der Punkt entfernt.</span><span class="sxs-lookup"><span data-stu-id="3b294-229">If a segment ends in a single period, that period is removed.</span></span> <span data-ttu-id="3b294-230">(Im vorherigen Schritt wurde ein Segment aus einem oder zwei Punkten normalisiert.</span><span class="sxs-lookup"><span data-stu-id="3b294-230">(A segment of a single or double period is normalized in the previous step.</span></span> <span data-ttu-id="3b294-231">Ein Segment aus mindestens drei Punkten wird nicht normalisiert. Tatsächlich ist das ein gültiger Datei- oder Verzeichnisname.)</span><span class="sxs-lookup"><span data-stu-id="3b294-231">A segment of three or more periods is not normalized and is actually a valid file/directory name.)</span></span>

- <span data-ttu-id="3b294-232">Wenn der Pfad nicht mit einem Trennzeichen endet, werden alle nachfolgenden Punkte und Leerzeichen (U+0020) entfernt.</span><span class="sxs-lookup"><span data-stu-id="3b294-232">If the path doesn't end in a separator, all trailing periods and spaces (U+0020) are removed.</span></span> <span data-ttu-id="3b294-233">Wenn das letzte Segment nur aus einem oder zwei Punkten besteht, unterliegt es den oben genannten Regeln für relative Komponenten.</span><span class="sxs-lookup"><span data-stu-id="3b294-233">If the last segment is simply a single or double period, it falls under the relative components rule above.</span></span>

   <span data-ttu-id="3b294-234">Diese Regel bedeutet, dass Sie einen Verzeichnisnamen mit einem nachfolgendem Leerzeichen erstellen können, indem Sie nach dem Leerzeichen ein Trennzeichen hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="3b294-234">This rule means that you can create a directory name with a trailing space by adding a trailing separator after the space.</span></span>

   > [!IMPORTANT]
   > <span data-ttu-id="3b294-235">Sie sollten **nie** Verzeichnisse oder Dateinamen mit nachstehenden Leerzeichen erstellen.</span><span class="sxs-lookup"><span data-stu-id="3b294-235">You should **never** create a directory or filename with a trailing space.</span></span> <span data-ttu-id="3b294-236">Nachstehende Leerzeichen machen es schwer, wenn nicht sogar unmöglich, auf ein Verzeichnis zuzugreifen. Außerdem treten häufig Fehler auf, wenn Anwendungen versuchen, Verzeichnisse oder Dateien zu verarbeiten, deren Namen nachstehende Leerzeichen enthalten.</span><span class="sxs-lookup"><span data-stu-id="3b294-236">Trailing spaces can make it difficult or impossible to access a directory, and applications commonly fail when attempting to handle directories or files whose names include trailing spaces.</span></span>

## <a name="skipping-normalization"></a><span data-ttu-id="3b294-237">Überspringen der Normalisierung</span><span class="sxs-lookup"><span data-stu-id="3b294-237">Skipping normalization</span></span>

<span data-ttu-id="3b294-238">Normalerweise werden alle Pfade, die an die Windows-API übergeben werden, effektiv an die [GetFullPathName-Funktion](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) übergeben und normalisiert.</span><span class="sxs-lookup"><span data-stu-id="3b294-238">Normally, any path passed to a Windows API is (effectively) passed to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) and normalized.</span></span> <span data-ttu-id="3b294-239">Es gibt eine wichtige Ausnahme: ein Gerätepfad, der mit einem Fragezeichen statt einem Punkt beginnt.</span><span class="sxs-lookup"><span data-stu-id="3b294-239">There is one important exception: a device path that begins with a question mark instead of a period.</span></span> <span data-ttu-id="3b294-240">Sofern der Pfad nicht mit `\\?\` beginnt (beachten Sie die Verwendung des kanonischen umgekehrten Schrägstrichs), ist er normalisiert.</span><span class="sxs-lookup"><span data-stu-id="3b294-240">Unless the path starts exactly with `\\?\` (note the use of the canonical backslash), it is normalized.</span></span>

<span data-ttu-id="3b294-241">Warum kann es sinnvoll sein, die Normalisierung zu überspringen?</span><span class="sxs-lookup"><span data-stu-id="3b294-241">Why would you want to skip normalization?</span></span> <span data-ttu-id="3b294-242">Es gibt drei wichtige Gründe:</span><span class="sxs-lookup"><span data-stu-id="3b294-242">There are three major reasons:</span></span>

1. <span data-ttu-id="3b294-243">Um Zugriff auf Pfade zu erhalten, die zwar zulässig sind, aber normalerweise nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="3b294-243">To get access to paths that are normally unavailable but are legal.</span></span> <span data-ttu-id="3b294-244">Beispielsweise ist es auf keine andere Weise möglich, Zugriff auf eine Datei oder ein Verzeichnis namens `hidden.` zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="3b294-244">A file or directory called `hidden.`, for example, is impossible to access in any other way.</span></span>

1. <span data-ttu-id="3b294-245">Zur Verbesserung der Leistung, wenn Sie die Normalisierung bereits durchgeführt haben.</span><span class="sxs-lookup"><span data-stu-id="3b294-245">To improve performance by skipping normalization if you've already normalized.</span></span>

1. <span data-ttu-id="3b294-246">Zum Überspringen der `MAX_PATH`-Überprüfung der Pfadlänge, um Pfade zu ermöglichen, die länger als 259 Zeichen sind (nur in .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="3b294-246">On the .NET Framework only, to skip the `MAX_PATH` check for path length to allow for paths that are greater than 259 characters.</span></span> <span data-ttu-id="3b294-247">Abgesehen von einigen Ausnahmen ist dies mit den meisten APIs möglich.</span><span class="sxs-lookup"><span data-stu-id="3b294-247">Most APIs allow this, with some exceptions.</span></span>

> [!NOTE]
> <span data-ttu-id="3b294-248">.NET Core verarbeitet lange Pfade implizit und führt keine `MAX_PATH`-Überprüfung durch.</span><span class="sxs-lookup"><span data-stu-id="3b294-248">.NET Core handles long paths implicitly and does not perform a `MAX_PATH` check.</span></span> <span data-ttu-id="3b294-249">Die `MAX_PATH`-Überprüfung gilt nur für .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="3b294-249">The `MAX_PATH` check applies only to the .NET Framework.</span></span>

<span data-ttu-id="3b294-250">Das Überspringen der Normalisierung und MAX_PATH-Überprüfungen ist der einzige Unterschied zwischen den zwei Gerätepfadsyntaxen. Andernfalls sind sie identisch.</span><span class="sxs-lookup"><span data-stu-id="3b294-250">Skipping normalization and max path checks is the only difference between the two device path syntaxes; they are otherwise identical.</span></span> <span data-ttu-id="3b294-251">Beachten Sie, dass Sie durch Überspringen der Normalisierung Pfade erstellen können, die für „normale“ Anwendungen schwer zu verarbeiten sind.</span><span class="sxs-lookup"><span data-stu-id="3b294-251">Be careful with skipping normalization, since you can easily create paths that are difficult for "normal" applications to deal with.</span></span>

<span data-ttu-id="3b294-252">Pfade, die mit `\\?\` beginnen, werden weiterhin normalisiert, wenn Sie sie explizit an die [GetFullPathName-Funktion](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) übergeben.</span><span class="sxs-lookup"><span data-stu-id="3b294-252">Paths that start with `\\?\` are still normalized if you explicitly pass them to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span>

<span data-ttu-id="3b294-253">Sie können Pfade mit mehr Zeichen als `MAX_PATH` übergeben, um [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) ohne `\\?\` abzurufen.</span><span class="sxs-lookup"><span data-stu-id="3b294-253">You can pass paths of more than `MAX_PATH` characters to [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) without `\\?\`.</span></span> <span data-ttu-id="3b294-254">Beliebige Pfadlängen werden bis zur maximalen Länge von Zeichenfolgen unterstützt, die Windows verarbeiten kann.</span><span class="sxs-lookup"><span data-stu-id="3b294-254">It supports arbitrary length paths up to the maximum string size that Windows can handle.</span></span>

## <a name="case-and-the-windows-file-system"></a><span data-ttu-id="3b294-255">Groß-/Kleinbuchstaben im Windows-Dateisystem</span><span class="sxs-lookup"><span data-stu-id="3b294-255">Case and the Windows file system</span></span>

<span data-ttu-id="3b294-256">Dass Pfad- und Verzeichnisnamen die Groß-/Kleinschreibung ignorieren, ist eine Besonderheit vom Windows-Dateisystem, was viele Benutzer und Entwickler verwirrt, die Windows nicht verwenden.</span><span class="sxs-lookup"><span data-stu-id="3b294-256">A peculiarity of the Windows file system that non-Windows users and developers find confusing is that path and directory names are case-insensitive.</span></span> <span data-ttu-id="3b294-257">Das bedeutet, dass Verzeichnis- und Dateinamen die Schreibweise der Zeichenfolgen darstellen, mit der sie erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="3b294-257">That is, directory and file names reflect the casing of the strings used when they are created.</span></span> <span data-ttu-id="3b294-258">Zum Beispiel erstellt der Methodenaufruf</span><span class="sxs-lookup"><span data-stu-id="3b294-258">For example, the method call</span></span>

```csharp
Directory.Create("TeStDiReCtOrY");
```

```vb
Directory.Create("TeStDiReCtOrY")
```

<span data-ttu-id="3b294-259">ein Verzeichnis namens TeStDiReCtOrY.</span><span class="sxs-lookup"><span data-stu-id="3b294-259">creates a directory named TeStDiReCtOrY.</span></span> <span data-ttu-id="3b294-260">Wenn Sie ein Verzeichnis oder eine Datei umbenennen, um die Groß-/Kleinschreibung zu ändern, wird die entsprechende Zeichenfolge angezeigt, die Sie beim Umbenennen eingegeben haben.</span><span class="sxs-lookup"><span data-stu-id="3b294-260">If you rename a directory or file to change its case, the directory or file name reflects the case of the string used when you rename it.</span></span> <span data-ttu-id="3b294-261">Der folgende Code benennt beispielweise eine Datei namens „test.txt“ in „Test.txt“ um:</span><span class="sxs-lookup"><span data-stu-id="3b294-261">For example, the following code renames a file named test.txt to Test.txt:</span></span>

[!code-csharp[case-and-renaming](~/samples/snippets/standard/io/file-names/cs/rename.cs)]
[!code-vb[case-and-renaming](~/samples/snippets/standard/io/file-names/vb/rename.vb)]

<span data-ttu-id="3b294-262">Allerdings berücksichtigen Vergleiche von Verzeichnis- und Dateinamen die Groß-/Kleinschreibung nicht.</span><span class="sxs-lookup"><span data-stu-id="3b294-262">However, directory and file name comparisons are case-insensitive.</span></span> <span data-ttu-id="3b294-263">Wenn Sie nach einer Datei namens „test.txt“ suchen, ignorieren .NET-Dateisystem-APIs die Groß-/Kleinschreibung für Vergleiche.</span><span class="sxs-lookup"><span data-stu-id="3b294-263">If you search for a file named "test.txt", .NET file system APIs ignore case in the comparison.</span></span> <span data-ttu-id="3b294-264">„Test.txt“, „TEST.TXT“, „test.TXT“ und beliebige andere Kombinationen aus Groß- und Kleinbuchstaben entsprechen „test.txt“.</span><span class="sxs-lookup"><span data-stu-id="3b294-264">Test.txt, TEST.TXT, test.TXT, and any other combination of upper- and lowercase letters will match "test.txt".</span></span>
