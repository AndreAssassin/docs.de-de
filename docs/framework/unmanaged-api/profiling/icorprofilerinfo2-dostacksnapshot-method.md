---
title: ICorProfilerInfo2::DoStackSnapshot-Methode
ms.date: 03/30/2017
api_name:
- ICorProfilerInfo2.DoStackSnapshot
api_location:
- mscorwks.dll
api_type:
- COM
f1_keywords:
- ICorProfilerInfo2::DoStackSnapshot
helpviewer_keywords:
- ICorProfilerInfo2::DoStackSnapshot method [.NET Framework profiling]
- DoStackSnapshot method [.NET Framework profiling]
ms.assetid: 287b11e9-7c52-4a13-ba97-751203fa97f4
topic_type:
- apiref
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 102349461456f971a2fdeaf2783630c1b88dbd6b
ms.sourcegitcommit: 7f616512044ab7795e32806578e8dc0c6a0e038f
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 07/10/2019
ms.locfileid: "67778626"
---
# <a name="icorprofilerinfo2dostacksnapshot-method"></a><span data-ttu-id="3409a-102">ICorProfilerInfo2::DoStackSnapshot-Methode</span><span class="sxs-lookup"><span data-stu-id="3409a-102">ICorProfilerInfo2::DoStackSnapshot Method</span></span>
<span data-ttu-id="3409a-103">Durchläuft die verwalteten Frames im Stapel für den angegebenen Thread und sendet die Informationen an den Profiler in einem Rückruf.</span><span class="sxs-lookup"><span data-stu-id="3409a-103">Walks the managed frames on the stack for the specified thread, and sends information to the profiler through a callback.</span></span>  
  
## <a name="syntax"></a><span data-ttu-id="3409a-104">Syntax</span><span class="sxs-lookup"><span data-stu-id="3409a-104">Syntax</span></span>  
  
```cpp  
HRESULT DoStackSnapshot(  
    [in] ThreadID thread,  
    [in] StackSnapshotCallback *callback,  
    [in] ULONG32 infoFlags,  
    [in] void *clientData,  
    [in, size_is(contextSize), length_is(contextSize)] BYTE context[],  
    [in] ULONG32 contextSize);  
```  
  
## <a name="parameters"></a><span data-ttu-id="3409a-105">Parameter</span><span class="sxs-lookup"><span data-stu-id="3409a-105">Parameters</span></span>  
 `thread`  
 <span data-ttu-id="3409a-106">[in] Die ID des Zielthreads.</span><span class="sxs-lookup"><span data-stu-id="3409a-106">[in] The ID of the target thread.</span></span>  
  
 <span data-ttu-id="3409a-107">Übergeben von null in `thread` ergibt sich eine Momentaufnahme des aktuellen Threads.</span><span class="sxs-lookup"><span data-stu-id="3409a-107">Passing null in `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="3409a-108">Wenn eine `ThreadID` von ein anderen Thread übergeben, die common Language Runtime (CLR) hält dieser Thread erstellt eine Momentaufnahme und fortgesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="3409a-108">If a `ThreadID` of a different thread is passed, the common language runtime (CLR) suspends that thread, performs the snapshot, and resumes.</span></span>  
  
 `callback`  
 <span data-ttu-id="3409a-109">[in] Ein Zeiger auf die Implementierung der [StackSnapshotCallback](../../../../docs/framework/unmanaged-api/profiling/stacksnapshotcallback-function.md) -Methode, die von der CLR, geben Sie den Profiler mit Informationen über jeden verwalteten Frame und die Ausführung von nicht verwalteten Frames aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="3409a-109">[in] A pointer to the implementation of the [StackSnapshotCallback](../../../../docs/framework/unmanaged-api/profiling/stacksnapshotcallback-function.md) method, which is called by the CLR to provide the profiler with information on each managed frame and each run of unmanaged frames.</span></span>  
  
 <span data-ttu-id="3409a-110">Die `StackSnapshotCallback` Methode wird vom Profilerwriter implementiert.</span><span class="sxs-lookup"><span data-stu-id="3409a-110">The `StackSnapshotCallback` method is implemented by the profiler writer.</span></span>  
  
 `infoFlags`  
 <span data-ttu-id="3409a-111">[in] Der Wert der [COR_PRF_SNAPSHOT_INFO](../../../../docs/framework/unmanaged-api/profiling/cor-prf-snapshot-info-enumeration.md) -Enumeration, die gibt an, die Menge der Daten für jeden Frame von zu übergebenden `StackSnapshotCallback`.</span><span class="sxs-lookup"><span data-stu-id="3409a-111">[in] A value of the [COR_PRF_SNAPSHOT_INFO](../../../../docs/framework/unmanaged-api/profiling/cor-prf-snapshot-info-enumeration.md) enumeration, which specifies the amount of data to be passed back for each frame by `StackSnapshotCallback`.</span></span>  
  
 `clientData`  
 <span data-ttu-id="3409a-112">[in] Ein Zeiger auf die Clientdaten, die direkt, um übergeben wird die `StackSnapshotCallback` Callback-Funktion.</span><span class="sxs-lookup"><span data-stu-id="3409a-112">[in] A pointer to the client data, which is passed straight through to the `StackSnapshotCallback` callback function.</span></span>  
  
 `context`  
 <span data-ttu-id="3409a-113">[in] Ein Zeiger auf eine Win32- `CONTEXT` -Struktur, die verwendet wird, um den Stackwalk zu starten.</span><span class="sxs-lookup"><span data-stu-id="3409a-113">[in] A pointer to a Win32 `CONTEXT` structure, which is used to seed the stack walk.</span></span> <span data-ttu-id="3409a-114">Die Win32 `CONTEXT` Struktur enthält Werte, der die CPU-Register und stellt den Zustand der CPU zu einem bestimmten Zeitpunkt dar.</span><span class="sxs-lookup"><span data-stu-id="3409a-114">The Win32 `CONTEXT` structure contains values of the CPU registers and represents the state of the CPU at a particular moment in time.</span></span>  
  
 <span data-ttu-id="3409a-115">Die CLR Bestimmen des Installationsorts für den Stackwalk zu beginnen, ist der Anfang des Stapels nicht verwalteter Hilfscode Startwerts; Andernfalls wird der Ausgangswert ignoriert.</span><span class="sxs-lookup"><span data-stu-id="3409a-115">The seed helps the CLR determine where to begin the stack walk, if the top of the stack is unmanaged helper code; otherwise, the seed is ignored.</span></span> <span data-ttu-id="3409a-116">Ein Ausgangswert muss für einen asynchronen Durchlauf angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="3409a-116">A seed must be supplied for an asynchronous walk.</span></span> <span data-ttu-id="3409a-117">Wenn Sie einen synchronen Durchlauf durchführen, ist kein Ausgangswert erforderlich.</span><span class="sxs-lookup"><span data-stu-id="3409a-117">If you are doing a synchronous walk, no seed is necessary.</span></span>  
  
 <span data-ttu-id="3409a-118">Die `context` Parameter ist nur gültig, wenn das Flag COR_PRF_SNAPSHOT_CONTEXT übergebene der `infoFlags` Parameter.</span><span class="sxs-lookup"><span data-stu-id="3409a-118">The `context` parameter is valid only if the COR_PRF_SNAPSHOT_CONTEXT flag was passed in the `infoFlags` parameter.</span></span>  
  
 `contextSize`  
 <span data-ttu-id="3409a-119">[in] Die Größe des der `CONTEXT` -Struktur, die verweist die `context` Parameter.</span><span class="sxs-lookup"><span data-stu-id="3409a-119">[in] The size of the `CONTEXT` structure, which is referenced by the `context` parameter.</span></span>  
  
## <a name="remarks"></a><span data-ttu-id="3409a-120">Hinweise</span><span class="sxs-lookup"><span data-stu-id="3409a-120">Remarks</span></span>  
 <span data-ttu-id="3409a-121">Übergeben von null `thread` ergibt sich eine Momentaufnahme des aktuellen Threads.</span><span class="sxs-lookup"><span data-stu-id="3409a-121">Passing null for `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="3409a-122">Momentaufnahmen können von anderen Threads erstellt werden, nur dann, wenn der Zielthread zur Zeit angehalten wird.</span><span class="sxs-lookup"><span data-stu-id="3409a-122">Snapshots can be taken of other threads only if the target thread is suspended at the time.</span></span>  
  
 <span data-ttu-id="3409a-123">Wenn Sie möchte, dass der Profiler den Stapel zu durchlaufen, ruft er `DoStackSnapshot`.</span><span class="sxs-lookup"><span data-stu-id="3409a-123">When the profiler wants to walk the stack, it calls `DoStackSnapshot`.</span></span> <span data-ttu-id="3409a-124">Bevor die CLR von diesem Aufruf zurückkehrt, ruft Ihre `StackSnapshotCallback` mehrfach, einmal für jeden verwalteten Frame (oder die Ausführung von nicht verwalteten Frames) auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3409a-124">Before the CLR returns from that call, it calls your `StackSnapshotCallback` several times, once for each managed frame (or run of unmanaged frames) on the stack.</span></span> <span data-ttu-id="3409a-125">Wenn nicht verwalteter Frames gefunden werden, müssen Sie sie selbst durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="3409a-125">When unmanaged frames are encountered, you must walk them yourself.</span></span>  
  
 <span data-ttu-id="3409a-126">Die Reihenfolge, in dem der Stapel durchgelaufen wird, ist die Umkehrung des wie die Frames auf dem Stapel abgelegt wurden: zuletzt Blattelemente der Frame (letzte verschoben) ersten, main (zuerst verschoben).</span><span class="sxs-lookup"><span data-stu-id="3409a-126">The order in which the stack is walked is the reverse of how the frames were pushed onto the stack: leaf (last-pushed) frame first, main (first-pushed) frame last.</span></span>  
  
 <span data-ttu-id="3409a-127">Weitere Informationen dazu, wie Sie den Profiler zum Durchlaufen verwalteter Stapel programmieren, finden Sie unter [Profiler Durchlaufen von Stapeln im .NET Framework 2.0: Grundlagen und mehr](https://go.microsoft.com/fwlink/?LinkId=73638).</span><span class="sxs-lookup"><span data-stu-id="3409a-127">For more information about how to program the profiler to walk managed stacks, see [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://go.microsoft.com/fwlink/?LinkId=73638).</span></span>  
  
 <span data-ttu-id="3409a-128">Ein Stackwalk kann synchron oder asynchron sein, wie in den folgenden Abschnitten erläutert.</span><span class="sxs-lookup"><span data-stu-id="3409a-128">A stack walk can be synchronous or asynchronous, as explained in the following sections.</span></span>  
  
## <a name="synchronous-stack-walk"></a><span data-ttu-id="3409a-129">Synchroner Stackwalk</span><span class="sxs-lookup"><span data-stu-id="3409a-129">Synchronous Stack Walk</span></span>  
 <span data-ttu-id="3409a-130">Ein synchroner Stackwalk umfasst den Stapel des aktuellen Threads in Reaktion auf einen Rückruf zu durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="3409a-130">A synchronous stack walk involves walking the stack of the current thread in response to a callback.</span></span> <span data-ttu-id="3409a-131">Das seeding oder angehalten ist nicht erforderlich.</span><span class="sxs-lookup"><span data-stu-id="3409a-131">It does not require seeding or suspending.</span></span>  
  
 <span data-ttu-id="3409a-132">Sie stellen einen synchronen Aufruf durch, wenn als Reaktion auf die CLR einen Aufruf der Ihres Profilers [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) (oder [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md))-Methoden aufrufen, Sie `DoStackSnapshot` Durchlaufen des Stapels für die aktuellen Thread.</span><span class="sxs-lookup"><span data-stu-id="3409a-132">You make a synchronous call when, in response to the CLR calling one of your profiler's [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) (or [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)) methods, you call `DoStackSnapshot` to walk the stack of the current thread.</span></span> <span data-ttu-id="3409a-133">Dies ist nützlich, wenn Sie möchten, finden Sie unter der Stapel bei einer Benachrichtigung wie sieht [ICorProfilerCallback:: ObjectAllocated](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method.md).</span><span class="sxs-lookup"><span data-stu-id="3409a-133">This is useful when you want to see what the stack looks like at a notification such as [ICorProfilerCallback::ObjectAllocated](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method.md).</span></span> <span data-ttu-id="3409a-134">Rufen Sie einfach `DoStackSnapshot` innerhalb Ihrer `ICorProfilerCallback` -Methode und übergeben null in der `context` und `thread` Parameter.</span><span class="sxs-lookup"><span data-stu-id="3409a-134">You just call `DoStackSnapshot` from within your `ICorProfilerCallback` method, passing null in the `context` and `thread` parameters.</span></span>  
  
## <a name="asynchronous-stack-walk"></a><span data-ttu-id="3409a-135">Asynchroner Stapeldurchlauf</span><span class="sxs-lookup"><span data-stu-id="3409a-135">Asynchronous Stack Walk</span></span>  
 <span data-ttu-id="3409a-136">Ein asynchroner Stapeldurchlauf umfasst den Stapel eines anderen Threads zu durchlaufen oder das Durchlaufen des Stapels für den aktuellen Thread nicht in der Antwort auf einen Rückruf, jedoch über den Anweisungszeiger des aktuellen Threads hijacking.</span><span class="sxs-lookup"><span data-stu-id="3409a-136">An asynchronous stack walk entails walking the stack of a different thread, or walking the stack of the current thread, not in response to a callback, but by hijacking the current thread's instruction pointer.</span></span> <span data-ttu-id="3409a-137">Asynchroner Durchlauf erfordert einen Ausgangswert ist der Anfang des Stapels nicht verwalteter Code, der nicht Teil einer Plattform ist Plattformaufruf (PInvoke) oder COM-Aufruf, aber Hilfscode in der CLR selbst.</span><span class="sxs-lookup"><span data-stu-id="3409a-137">An asynchronous walk requires a seed if the top of the stack is unmanaged code that is not part of a platform invoke (PInvoke) or COM call, but helper code in the CLR itself.</span></span> <span data-ttu-id="3409a-138">Code, der just-in-Time (JIT) Kompilierung oder Garbage Collection ist z. B. Hilfscode.</span><span class="sxs-lookup"><span data-stu-id="3409a-138">For example, code that does just-in-time (JIT) compiling or garbage collection is helper code.</span></span>  
  
 <span data-ttu-id="3409a-139">Sie erhalten einen Ausgangswert an, indem Sie den Zielthread direkt anhalten von und seinen Stapel durchlaufen selbst bis Sie den obersten finden verwalteten Frame.</span><span class="sxs-lookup"><span data-stu-id="3409a-139">You obtain a seed by directly suspending the target thread and walking its stack yourself, until you find the topmost managed frame.</span></span> <span data-ttu-id="3409a-140">Nachdem der Zielthread angehalten wird, erhalten Sie aktuellen Registerkontext in den Zielthread an.</span><span class="sxs-lookup"><span data-stu-id="3409a-140">After the target thread is suspended, get the target thread's current register context.</span></span> <span data-ttu-id="3409a-141">Als Nächstes zu bestimmen, ob der Registerkontext auf nicht verwalteten Code durch den Aufruf zeigt [ICorProfilerInfo:: GetFunctionFromIP](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getfunctionfromip-method.md) – Wenn zurückgegeben wird ein `FunctionID` gleich 0 (null) ist, wird der Frame nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="3409a-141">Next, determine whether the register context points to unmanaged code by calling [ICorProfilerInfo::GetFunctionFromIP](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getfunctionfromip-method.md) — if it returns a `FunctionID` equal to zero, the frame is unmanaged code.</span></span> <span data-ttu-id="3409a-142">Führen Sie nun den Stapel, bis Sie den ersten verwalteten Frame erreichen, und klicken Sie dann die Seed-Kontext, der basierend auf der Registerkontext für diesen Frame zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="3409a-142">Now, walk the stack until you reach the first managed frame, and then calculate the seed context based on the register context for that frame.</span></span>  
  
 <span data-ttu-id="3409a-143">Rufen Sie `DoStackSnapshot` mit den Kontext Ihres Ausgangswerts, um den asynchronen Stackwalk zu beginnen.</span><span class="sxs-lookup"><span data-stu-id="3409a-143">Call `DoStackSnapshot` with your seed context to begin the asynchronous stack walk.</span></span> <span data-ttu-id="3409a-144">Wenn Sie keinen Ausgangswert angeben `DoStackSnapshot` verwalteten Frames an der Spitze des Stapels überspringen und, folglich erhalten Sie einen unvollständiger Stackwalk.</span><span class="sxs-lookup"><span data-stu-id="3409a-144">If you do not supply a seed, `DoStackSnapshot` might skip managed frames at the top of the stack and, consequently, will give you an incomplete stack walk.</span></span> <span data-ttu-id="3409a-145">Wenn Sie einen Ausgangswert angeben, müssen sie zeigen Sie auf die JIT-Kompilierung oder Native Image Generator (Ngen.exe)-Code generiert andernfalls `DoStackSnapshot` gibt den Fehlercode CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX zurück.</span><span class="sxs-lookup"><span data-stu-id="3409a-145">If you do supply a seed, it must point to JIT-compiled or Native Image Generator (Ngen.exe)-generated code; otherwise, `DoStackSnapshot` returns the failure code, CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span></span>  
  
 <span data-ttu-id="3409a-146">Asynchroner Stapeldurchläufe können leicht dazu führen, dass Deadlocks oder zugriffsverletzungen, es sei denn, Sie die folgenden Richtlinien beachten:</span><span class="sxs-lookup"><span data-stu-id="3409a-146">Asynchronous stack walks can easily cause deadlocks or access violations, unless you follow these guidelines:</span></span>  
  
- <span data-ttu-id="3409a-147">Wenn Sie direkt über Threads anhalten, denken Sie daran, dass nur ein Thread, der nie verwalteten Code ausgeführt hat einen anderen Thread anhalten kann.</span><span class="sxs-lookup"><span data-stu-id="3409a-147">When you directly suspend threads, remember that only a thread that has never run managed code can suspend another thread.</span></span>  
  
- <span data-ttu-id="3409a-148">Immer-block in Ihre [ICorProfilerCallback:: ThreadDestroyed](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-threaddestroyed-method.md) Rückruf bis zum Abschluss der Stapeldurchlauf dieses Threads.</span><span class="sxs-lookup"><span data-stu-id="3409a-148">Always block in your [ICorProfilerCallback::ThreadDestroyed](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-threaddestroyed-method.md) callback until that thread's stack walk is complete.</span></span>  
  
- <span data-ttu-id="3409a-149">Führen Sie keine Sperre, während Ihr Profiler an eine CLR-Funktion aufruft, die eine Garbagecollection auslösen können.</span><span class="sxs-lookup"><span data-stu-id="3409a-149">Do not hold a lock while your profiler calls into a CLR function that can trigger a garbage collection.</span></span> <span data-ttu-id="3409a-150">D. h. keine Sperre, wenn der belegende Thread einen Aufruf durchführen kann, der eine Garbagecollection auslöst.</span><span class="sxs-lookup"><span data-stu-id="3409a-150">That is, do not hold a lock if the owning thread might make a call that triggers a garbage collection.</span></span>  
  
 <span data-ttu-id="3409a-151">Es gibt auch Risiko eines Deadlocks Aufrufen `DoStackSnapshot` von einem Thread, der Ihr Profiler erstellt wurde, damit Sie den Stapel des einen separaten Zielthread zu durchlaufen können.</span><span class="sxs-lookup"><span data-stu-id="3409a-151">There is also a risk of deadlock if you call `DoStackSnapshot` from a thread that your profiler has created so that you can walk the stack of a separate target thread.</span></span> <span data-ttu-id="3409a-152">Beim ersten erstellten Thread gibt bestimmte `ICorProfilerInfo*` Methoden (einschließlich `DoStackSnapshot`), die CLR wird pro Thread, CLR-spezifische-Initialisierung auf diesem Thread ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3409a-152">The first time the thread you created enters certain `ICorProfilerInfo*` methods (including `DoStackSnapshot`), the CLR will perform per-thread, CLR-specific initialization on that thread.</span></span> <span data-ttu-id="3409a-153">Wenn Ihr Profiler den Zielthread angehalten hat, dessen Stapel, die Sie durchlaufen möchten, und Zielthread aufgetreten ist, eine Sperre für diese Initialisierung pro Thread durchführen besitzen, wird ein Deadlock auftreten.</span><span class="sxs-lookup"><span data-stu-id="3409a-153">If your profiler has suspended the target thread whose stack you are trying to walk, and if that target thread happened to own a lock necessary for performing this per-thread initialization, a deadlock will occur.</span></span> <span data-ttu-id="3409a-154">Um diese Deadlocks zu vermeiden, stellen Sie einen anfänglichen Aufruf in `DoStackSnapshot` aus Ihrem Profiler erstellte Thread durchlaufen ein separaten Thread, als Zielplattform halten den Zielthread nicht zuerst.</span><span class="sxs-lookup"><span data-stu-id="3409a-154">To avoid this deadlock, make an initial call into `DoStackSnapshot` from your profiler-created thread to walk a separate target thread, but do not suspend the target thread first.</span></span> <span data-ttu-id="3409a-155">Diese ersten Aufruf wird sichergestellt, dass die Initialisierung pro Thread ohne Deadlock durchführen kann.</span><span class="sxs-lookup"><span data-stu-id="3409a-155">This initial call ensures that the per-thread initialization can complete without deadlock.</span></span> <span data-ttu-id="3409a-156">Wenn `DoStackSnapshot` erfolgreich ist, und meldet Sie mindestens einen Frame nach diesem Punkt, sie werden alle Zielthread und der Aufruf angehalten, Profiler erstellte Thread sicher `DoStackSnapshot` auf den Stapel Zielthread zu durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="3409a-156">If `DoStackSnapshot` succeeds and reports at least one frame, after that point, it will be safe for that profiler-created thread to suspend any target thread and call `DoStackSnapshot` to walk the stack of that target thread.</span></span>  
  
## <a name="requirements"></a><span data-ttu-id="3409a-157">Anforderungen</span><span class="sxs-lookup"><span data-stu-id="3409a-157">Requirements</span></span>  
 <span data-ttu-id="3409a-158">**Plattformen:** Weitere Informationen finden Sie unter [Systemanforderungen](../../../../docs/framework/get-started/system-requirements.md).</span><span class="sxs-lookup"><span data-stu-id="3409a-158">**Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md).</span></span>  
  
 <span data-ttu-id="3409a-159">**Header:** CorProf.idl, CorProf.h</span><span class="sxs-lookup"><span data-stu-id="3409a-159">**Header:** CorProf.idl, CorProf.h</span></span>  
  
 <span data-ttu-id="3409a-160">**Bibliothek:** CorGuids.lib</span><span class="sxs-lookup"><span data-stu-id="3409a-160">**Library:** CorGuids.lib</span></span>  
  
 <span data-ttu-id="3409a-161">**.NET Framework-Versionen:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span><span class="sxs-lookup"><span data-stu-id="3409a-161">**.NET Framework Versions:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3409a-162">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="3409a-162">See also</span></span>

- [<span data-ttu-id="3409a-163">ICorProfilerInfo-Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="3409a-163">ICorProfilerInfo Interface</span></span>](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)
- [<span data-ttu-id="3409a-164">ICorProfilerInfo2-Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="3409a-164">ICorProfilerInfo2 Interface</span></span>](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)
