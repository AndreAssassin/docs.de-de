---
title: Metadaten für Abhängigkeitseigenschaften
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 154a2543c62de545e8b2df711d6ad51989d0689d
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/22/2019
ms.locfileid: "69964851"
---
# <a name="dependency-property-metadata"></a>Metadaten für Abhängigkeitseigenschaften
Das [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] -Eigenschaften System enthält ein metadatenberichterstattungs System, das über die Berichte hinausgeht, die über Reflektion oder allgemeine Common Language Runtime (CLR)-Eigenschaften gemeldet werden können. Metadaten für eine Abhängigkeitseigenschaft können auch eindeutig durch die Klasse zugewiesen werden, die eine Abhängigkeitseigenschaft definiert, sie können geändert werden, wenn die Abhängigkeitseigenschaft zu einer anderen Klasse hinzugefügt wird, und sie können gezielt von allen abgeleiteten Klassen überschrieben werden, die die Abhängigkeitseigenschaft von der definierenden Basisklasse erben.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Erforderliche Komponenten  
 Dieses Thema setzt voraus, dass Sie Abhängigkeitseigenschaften vorhandener Abhängigkeitseigenschaften von [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-Klassen aus Sicht eines Kunden verstehen und die [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md) gelesen haben. Um den Beispielen in diesem Thema folgen zu können, sollten Sie zudem mit [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] vertraut sein und wissen, wie Sie [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Anwendungen schreiben.  
  
<a name="dp_metadata_contents"></a>   
## <a name="how-dependency-property-metadata-is-used"></a>So werden Metadaten für Abhängigkeitseigenschaften genutzt  
 Metadaten für Abhängigkeitseigenschaften sind ein Objekt vorhanden, das zur Untersuchung der Eigenschaften einer Abhängigkeitseigenschaft abgefragt werden kann. Auch das Eigenschaftensystem greift häufig auf diese Metadaten zu, da es alle Abhängigkeitseigenschaften verarbeitet. Das Metadatenobjekt für eine Abhängigkeitseigenschaft kann die folgenden Informationstypen enthalten:  
  
- Den Standardwert für die Abhängigkeitseigenschaft, wenn über den lokalen Wert, den Stil, die Vererbung usw. kein anderer Wert für die Abhängigkeitseigenschaft bestimmt werden kann. Ausführliche Informationen dazu, wie sich Standardwerte auf die vom Eigenschaftensystem beim Zuordnen von Werten zu Abhängigkeitseigenschaften verwendeten Rangfolge von Eigenschaftenwerten auswirken, finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](dependency-property-value-precedence.md).  
  
- Verweise auf die Rückrufimplementierungen, die das Umwandlungs- oder Änderungsbenachrichtigungsverhalten pro Besitzertyp beeinflussen. Beachten Sie, dass diese Rückrufe häufig auf nicht öffentlicher Zugriffsebene definiert werden. Die tatsächlichen Verweise aus den Metadaten zu erhalten, ist im Allgemeinen nicht möglich, wenn die Verweise sich nicht innerhalb Ihres zulässigen Zugriffsbereichs befinden. Weitere Informationen zu Abhängigkeitseigenschaftenrückrufen finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](dependency-property-callbacks-and-validation.md).  
  
- Wenn die fragliche Abhängigkeitseigenschaft eine Eigenschaft auf WPF-Frameworkebene ist, enthalten die Metadaten möglicherweise Merkmale der Abhängigkeitseigenschaft auf WPF-Frameworkebene, die Informationen und Zustände von Diensten wie der WPF-Framework-Layout-Engine und Eigenschaftsvererbungslogik melden. Weitere Informationen zu diesem Aspekt der Metadaten für Abhängigkeitseigenschaften finden Sie unter [Framework-Eigenschaftenmetadaten](framework-property-metadata.md).  
  
<a name="APIs"></a>   
## <a name="metadata-apis"></a>Metadaten-APIs  
 Der Typ, der die meisten Metadateninformationen meldet, die vom Eigenschaften System verwendet <xref:System.Windows.PropertyMetadata> werden, ist die-Klasse. Metadateninstanzen werden optional angegeben, wenn Abhängigkeitseigenschaften im Eigenschaftensystem registriert werden, und können erneut für zusätzliche Typen angegeben werden, die sich selbst entweder als Besitzer hinzufügen oder Metadaten überschreiben, die sie von der Basisklasse der Definition der Abhängigkeitseigenschaften erben. (In Fällen, in denen eine Eigenschaften Registrierung keine Metadaten angibt, wird <xref:System.Windows.PropertyMetadata> ein Standardwert mit Standardwerten für diese Klasse erstellt.) Die registrierten Metadaten werden als <xref:System.Windows.PropertyMetadata> zurückgegeben, wenn Sie die verschiedenen <xref:System.Windows.DependencyProperty.GetMetadata%2A> über Ladungen abrufen, die Metadaten von einer Abhängigkeits <xref:System.Windows.DependencyObject> Eigenschaft für eine-Instanz abrufen.  
  
 Die <xref:System.Windows.PropertyMetadata> -Klasse wird dann von abgeleitet, um spezifischere Metadaten für Architektur Bereiche wie die Klassen der WPF-Frameworkebene bereitzustellen. <xref:System.Windows.UIPropertyMetadata>Fügt Animations Berichte hinzu und <xref:System.Windows.FrameworkPropertyMetadata> stellt die Eigenschaften der WPF-Frameworkebene bereit, die im vorherigen Abschnitt erwähnt wurden. Wenn Abhängigkeits Eigenschaften registriert werden, können Sie mit diesen <xref:System.Windows.PropertyMetadata> abgeleiteten Klassen registriert werden. Wenn die Metadaten untersucht werden, kann <xref:System.Windows.PropertyMetadata> der Basistyp potenziell in die abgeleiteten Klassen umgewandelt werden, sodass Sie die spezifischeren Eigenschaften überprüfen können.  
  
> [!NOTE]
> Die Eigenschafts Merkmale, die in <xref:System.Windows.FrameworkPropertyMetadata> angegeben werden können, werden in dieser Dokumentation manchmal als "Flags" bezeichnet. Wenn Sie neue Metadateninstanzen für die Verwendung in Registrierungen von Abhängigkeits Eigenschaften oder Metadatenüberschreibungen erstellen, geben Sie diese Werte <xref:System.Windows.FrameworkPropertyMetadataOptions> mithilfe der flagweise-Enumeration an, und geben Sie dann möglicherweise verketteten Werte der-Enumeration an die <xref:System.Windows.FrameworkPropertyMetadata> -Konstruktor. Nachdem Sie jedoch erstellt wurden, werden diese Options Merkmale innerhalb <xref:System.Windows.FrameworkPropertyMetadata> von als eine Reihe von booleschen Eigenschaften und nicht im erstellenden Enumerationswert verfügbar gemacht. Mit den booleschen Eigenschaften können Sie jede Bedingung überprüfen, anstatt eine Maske auf einen Flag-Enumerationswert anzuwenden, um die interessanten Informationen abzurufen. Der Konstruktor verwendet die verketteten <xref:System.Windows.FrameworkPropertyMetadataOptions> , um die Länge der Konstruktorsignatur zu gewährleisten, wohingegen die tatsächlich erstellten Metadaten die diskreten Eigenschaften verfügbar machen, um die Abfrage der Metadaten intuitiver zu gestalten.  
  
<a name="override_or_subclass"></a>   
## <a name="when-to-override-metadata-when-to-derive-a-class"></a>Überschreiben von Metadaten und Ableiten einer Klasse  
 Das [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Eigenschaftensystem verfügt über Funktionen zum Ändern einiger Merkmale von Abhängigkeitseigenschaften, ohne dass sie vollständig neu implementiert werden müssen. Dies geschieht durch das Erstellen einer anderen Instanz von Metadaten für die Abhängigkeitseigenschaft, wie sie auf einem bestimmten Typ vorhanden ist. Beachten Sie, dass die meisten vorhandenen Abhängigkeitseigenschaften keine virtuellen Eigenschaften sind. Ihre „Neuimplementierung“ in geerbten Klassen könnte also nur das Shadowing des vorhandenen Elements erreicht werden.  
  
 Wenn das Szenario, das Sie für eine Abhängigkeitseigenschaft auf einem Typ umsetzen möchten, durch eine Änderung der Eigenschaften vorhandener Abhängigkeitseigenschaften nicht erreicht werden kann, müssen Sie möglicherweise eine abgeleitete Klasse erstellen und dann auf die abgeleitete Klasse eine benutzerdefinierte Abhängigkeitseigenschaft deklarieren. Eine benutzerdefinierte Abhängigkeits Eigenschaft verhält sich identisch mit den Abhängigkeits [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Eigenschaften, die von den APIs definiert werden. Weitere Informationen zu benutzerdefinierten Abhängigkeitseigenschaften finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](custom-dependency-properties.md).  
  
 Ein wichtiges Merkmal einer Abhängigkeitseigenschaft, das überschrieben werden kann, ist der Werttyp. Wenn Sie eine Abhängigkeitseigenschaft erben, die ungefähr das erforderliche Verhalten, aber einen anderen Typ aufweist, müssen Sie eine benutzerdefinierte Abhängigkeitseigenschaft implementieren und die Eigenschaften möglicherweise über die Typkonvertierung oder eine andere Implementierung auf Ihrer Klasse verknüpfen. Außerdem ist es nicht möglich, eine <xref:System.Windows.ValidateValueCallback>vorhandene zu ersetzen, da dieser Rückruf im Registrierungs Feld selbst und nicht innerhalb seiner Metadaten vorhanden ist.  
  
<a name="scenarios"></a>   
## <a name="scenarios-for-changing-existing-metadata"></a>Szenarios zum Ändern vorhandener Metadaten  
 Wenn Sie mit den Metadaten einer vorhandenen Abhängigkeitseigenschaft arbeiten, besteht ein häufiges Szenario für die Änderung der Metadaten der Abhängigkeitseigenschaft in der Änderung des Standardwerts. Das Ändern oder Hinzufügen von Eigenschaftensystemrückrufen ist ein erweitertes Szenario. Wenn Ihre Implementierung einer abgeleiteten Klasse verschiedene Wechselbeziehungen zwischen Abhängigkeitseigenschaften aufweist, ist dieses Szenario möglicherweise hilfreich. Eine der Voraussetzungen eines Programmiermodells, das sowohl Code als auch deklarative Verwendung unterstützt, ist die Möglichkeit, Eigenschaften in einer beliebigen Reihenfolge festzulegen. Daher müssen alle abhängigen Eigenschaften Just-In-Time ohne Kontext festgelegt werden und dürfen sich nicht auf die Kenntnis einer Festlegungsreihenfolge verlassen, wie z.B. in einem Konstruktor. Weitere Informationen zu diesem Aspekt des Eigenschaftensystems finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](dependency-property-callbacks-and-validation.md). Beachten Sie, dass Überprüfungsrückrufe kein Teil der Metadaten sind. Sie gehören zum Bezeichner der Abhängigkeitseigenschaft. Aus diesem Grund können Überprüfungsrückrufe nicht durch das Überschreiben der Metadaten geändert werden.  
  
 In einigen Fällen möchten Sie möglicherweise auch die Eigenschaftenmetadatenoptionen auf WPF-Frameworkebene für vorhandene Abhängigkeitseigenschaften ändern. Diese Optionen kommunizieren bestimmte bekannte Bedingungen zu Eigenschaften auf WPF-Frameworkebene an andere Prozesse auf WPF-Frameworkebene wie das Layoutsystem.  Das Festlegen der Optionen erfolgt in der Regel nur, wenn eine neue Abhängigkeits Eigenschaft registriert wird. es ist jedoch auch möglich, die Eigenschaften Metadaten der WPF-Frameworkebene im Rahmen eines <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> -oder <xref:System.Windows.DependencyProperty.AddOwner%2A> -Aufrufes zu ändern Die genauen Werte, die verwendet werden müssen, und weitere Informationen finden Sie unter [Framework-Eigenschaftenmetadaten](framework-property-metadata.md). Weitere Informationen zu Festlegung dieser Optionen für neu registrierte Abhängigkeitseigenschaften finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](custom-dependency-properties.md).  
  
<a name="dp_override_metadata"></a>   
### <a name="overriding-metadata"></a>Überschreiben von Metadaten  
 Metadaten werden in erster Linie überschrieben, damit Sie die verschiedenen, von Metadaten abgeleiteten Verhaltensweisen ändern können, die auf die Abhängigkeitseigenschaft, so wie sie auf Ihrem Typ vorhanden ist, angewendet werden. Die Gründe hierfür werden ausführlicher im Abschnitt [Metadaten](#dp_metadata_contents) erläutert. Weitere Informationen und Codebeispiele finden Sie unter [Überschreiben von Metadaten für eine Abhängigkeitseigenschaft](how-to-override-metadata-for-a-dependency-property.md).  
  
 Eigenschafts Metadaten können während des Registrierungs Aufrufes (<xref:System.Windows.DependencyProperty.Register%2A>) für eine Abhängigkeits Eigenschaft bereitgestellt werden. In vielen Fällen stellen Sie jedoch typspezifische Metadaten für Ihre Klasse bereit, wenn sie die Abhängigkeitseigenschaft erbt. Dies können Sie erreichen, indem Sie <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> die-Methode aufrufen.  Für ein Beispiel aus den [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] -APIs ist <xref:System.Windows.FrameworkElement> die-Klasse der <xref:System.Windows.UIElement.Focusable%2A> Typ, der die Abhängigkeits Eigenschaft zuerst registriert. Die <xref:System.Windows.Controls.Control> -Klasse überschreibt jedoch Metadaten für die-Abhängigkeits Eigenschaft, um Ihren eigenen anfänglichen Standardwert bereit `false` zustellen `true`, wobei Sie von in geändert und andernfalls <xref:System.Windows.UIElement.Focusable%2A> die ursprüngliche Implementierung wieder verwendet wird.  
  
 Wenn Sie Metadaten überschreiben, werden die verschiedenen Metadateneigenschaften entweder zusammengeführt oder ersetzt.  
  
- <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>wird zusammengeführt. Wenn Sie einen neuen <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>hinzufügen, wird dieser Rückruf in den Metadaten gespeichert. Wenn Sie <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> in der Überschreibung keine angeben, wird der Wert von <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> als Verweis vom nächstgelegenen Vorgänger herauf gestuft, der ihn in den Metadaten angegeben hat.  
  
- Das tatsächliche Eigenschaften Systemverhalten für <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> besteht darin, dass Implementierungen für alle metadatenbesitzer in der Hierarchie beibehalten und einer Tabelle hinzugefügt werden, wobei die Ausführungsreihenfolge des Eigenschaften Systems darin besteht, dass die Rückrufe der meisten abgeleiteten Klassen zuerst aufgerufen werden.  
  
- <xref:System.Windows.PropertyMetadata.DefaultValue%2A>wird ersetzt. Wenn Sie <xref:System.Windows.PropertyMetadata.DefaultValue%2A> in der Überschreibung keine angeben, wird der Wert von <xref:System.Windows.PropertyMetadata.DefaultValue%2A> vom nächstgelegenen Vorgänger, der ihn in den Metadaten angegeben hat, empfangen.  
  
- <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>Implementierungen werden ersetzt. Wenn Sie einen neuen <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>hinzufügen, wird dieser Rückruf in den Metadaten gespeichert. Wenn Sie <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in der Überschreibung keine angeben, wird der Wert von <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> als Verweis vom nächstgelegenen Vorgänger herauf gestuft, der ihn in den Metadaten angegeben hat.  
  
- Das Verhalten des Eigenschaften Systems besteht darin, <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> dass nur das in den unmittelbaren Metadaten aufgerufen wird. Es werden keine Verweise <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> auf andere Implementierungen in der Hierarchie beibehalten.  
  
 Dieses Verhalten wird von <xref:System.Windows.PropertyMetadata.Merge%2A>implementiert und kann für abgeleitete Metadatenklassen überschrieben werden.  
  
#### <a name="overriding-attached-property-metadata"></a>Überschreiben von Metadaten der angefügten Eigenschaft  
 Angefügte Eigenschaften werden in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] als Abhängigkeitseigenschaften implementiert. Dies bedeutet, dass sie auch Metadaten besitzen, die von einzelnen Klassen überschrieben werden können. Die Bereichs Überlegungen für eine angefügte Eigenschaft [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] in sind im allgemeinen <xref:System.Windows.DependencyObject> , dass für jede Eigenschaft eine angefügte Eigenschaft festgelegt werden kann. Daher kann jede <xref:System.Windows.DependencyObject> abgeleitete Klasse die Metadaten für eine beliebige angefügte Eigenschaft überschreiben, da Sie möglicherweise für eine Instanz der Klasse festgelegt wird. Sie können Standardwerte, Rückrufe oder Eigenschaften der Berichterstattung über Merkmale auf WPF-Frameworkebene überschreiben. Wenn die angefügte Eigenschaft auf eine Instanz Ihrer Klasse festgelegt ist, finden diese Merkmale zum Überschreiben von Metadateneigenschaften Anwendung. Falls die Eigenschaft nicht anderweitig festgelegt ist, können Sie z.B. den Standardwert überschreiben, sodass der Überschreibungswert als der Wert der angefügten Eigenschaft auf Ihren Klasseninstanzen gemeldet wird.  
  
> [!NOTE]
> Die <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> -Eigenschaft ist für angefügte Eigenschaften nicht relevant.  
  
<a name="dp_add_owner"></a>   
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a>Hinzufügen einer Klasse als Besitzer einer vorhandenen Abhängigkeitseigenschaft  
 Eine Klasse kann sich selbst als Besitzer einer Abhängigkeits Eigenschaft hinzufügen, die bereits registriert wurde, indem Sie <xref:System.Windows.DependencyProperty.AddOwner%2A> die-Methode verwendet. Dadurch kann die Klasse eine Abhängigkeitseigenschaft verwenden, die ursprünglich für einen anderen Typ registriert wurde. Die hinzugefügte Klasse ist in der Regel keine abgeleitete Klasse des Typs, der die Abhängigkeitseigenschaft zuerst als Besitzer registriert hat. Aus diesem Grund kann die Klasse und ihre abgeleiteten Klassen eine Implementierung von Abhängigkeitseigenschaften ohne die ursprüngliche Besitzerklasse „erben“, und ohne dass die hinzufügende Klasse der gleichen echten Klassenhierarchie angehört. Darüber hinaus kann die hinzufügende Klasse (und auch alle abgeleiteten Klassen) typspezifische Metadaten für die ursprüngliche Abhängigkeitseigenschaft bereitstellen.  
  
 Die hinzufügende Klasse sollte sich nicht nur über die Hilfsprogrammmethoden des Eigenschaftensystems als Besitzer hinzufügen, sondern auch weitere öffentliche Member für sich selbst deklarieren, um die Abhängigkeitseigenschaft in einen vollständigen Bestandteil des Eigenschaftensystems zu verwandeln, der für Code und Markup verfügbar ist. Eine Klasse, die eine vorhandene Abhängigkeitseigenschaft hinzufügt, hat beim Verfügbarmachen des Objektmodells für die Abhängigkeitseigenschaft die gleichen Aufgaben wie eine Klasse, die eine neue benutzerdefinierte Abhängigkeitseigenschaft definiert. Der erste Member, der verfügbar gemacht wird, ist ein Bezeichnerfeld für die Abhängigkeitseigenschaft. Dieses Feld muss ein `public static readonly` Feld vom Typ <xref:System.Windows.DependencyProperty>sein, das <xref:System.Windows.DependencyProperty.AddOwner%2A> dem Rückgabewert des Aufrufes zugewiesen wird. Der zweite zu definierenden Member ist die "Wrapper"-Eigenschaft des Common Language Runtime (CLR). Der Wrapper vereinfacht es, die Abhängigkeits Eigenschaft im Code zu manipulieren (Sie vermeiden die Aufrufe <xref:System.Windows.DependencyObject.SetValue%2A> jedes Mal und können diesen Aufruf nur einmal im Wrapper selbst vornehmen). Der Wrapper wird genauso implementiert, wie dies auch beim Registrieren einer benutzerdefinierten Abhängigkeitseigenschaft der Fall wäre. Weitere Informationen zum Implementieren einer Abhängigkeitseigenschaft finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](custom-dependency-properties.md) und [Hinzufügen eines Besitzertyps für eine Abhängigkeitseigenschaft](how-to-add-an-owner-type-for-a-dependency-property.md).  
  
#### <a name="addowner-and-attached-properties"></a>AddOwner und angefügte Eigenschaften  
 Sie können <xref:System.Windows.DependencyProperty.AddOwner%2A> für eine Abhängigkeits Eigenschaft, die von der Owner-Klasse als angefügte Eigenschaft definiert ist, aufgerufen werden. Der Zweck liegt im Allgemeinen darin, die zuvor angefügte Eigenschaft als nicht angefügte Abhängigkeitseigenschaft verfügbar zu machen. Anschließend machen Sie den <xref:System.Windows.DependencyProperty.AddOwner%2A> Rückgabewert `public static readonly` als Feld zur Verwendung als Bezeichner für die Abhängigkeits Eigenschaft verfügbar und definieren entsprechende "Wrapper"-Eigenschaften, sodass die Eigenschaft in der Tabelle "Members" angezeigt wird und eine nicht angefügte Eigenschaft unterstützt. Verwendung in der-Klasse.  
  
## <a name="see-also"></a>Siehe auch

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md)
- [Framework-Eigenschaftenmetadaten](framework-property-metadata.md)
