---
title: Metadaten für Abhängigkeitseigenschaften
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 98f8c6611340c89409697918ff8a16eaabe3c7a3
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/08/2019
ms.locfileid: "59170364"
---
# <a name="dependency-property-metadata"></a>Metadaten für Abhängigkeitseigenschaften
Das [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-Eigenschaftensystem enthält ein Metadatenberichtssystem, das die Berichtsmöglichkeiten mithilfe von Reflektion oder allgemeinen [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]-Merkmalen weit übertrifft. Metadaten für eine Abhängigkeitseigenschaft können auch eindeutig durch die Klasse zugewiesen werden, die eine Abhängigkeitseigenschaft definiert, sie können geändert werden, wenn die Abhängigkeitseigenschaft zu einer anderen Klasse hinzugefügt wird, und sie können gezielt von allen abgeleiteten Klassen überschrieben werden, die die Abhängigkeitseigenschaft von der definierenden Basisklasse erben.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Vorraussetzungen  
 Dieses Thema setzt voraus, dass Sie Abhängigkeitseigenschaften vorhandener Abhängigkeitseigenschaften von [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-Klassen aus Sicht eines Kunden verstehen und die [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md) gelesen haben. Um den Beispielen in diesem Thema folgen zu können, sollten Sie zudem mit [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] vertraut sein und wissen, wie Sie [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Anwendungen schreiben.  
  
<a name="dp_metadata_contents"></a>   
## <a name="how-dependency-property-metadata-is-used"></a>So werden Metadaten für Abhängigkeitseigenschaften genutzt  
 Metadaten für Abhängigkeitseigenschaften sind ein Objekt vorhanden, das zur Untersuchung der Eigenschaften einer Abhängigkeitseigenschaft abgefragt werden kann. Auch das Eigenschaftensystem greift häufig auf diese Metadaten zu, da es alle Abhängigkeitseigenschaften verarbeitet. Das Metadatenobjekt für eine Abhängigkeitseigenschaft kann die folgenden Informationstypen enthalten:  
  
-   Den Standardwert für die Abhängigkeitseigenschaft, wenn über den lokalen Wert, den Stil, die Vererbung usw. kein anderer Wert für die Abhängigkeitseigenschaft bestimmt werden kann. Ausführliche Informationen dazu, wie sich Standardwerte auf die vom Eigenschaftensystem beim Zuordnen von Werten zu Abhängigkeitseigenschaften verwendeten Rangfolge von Eigenschaftenwerten auswirken, finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](dependency-property-value-precedence.md).  
  
-   Verweise auf die Rückrufimplementierungen, die das Umwandlungs- oder Änderungsbenachrichtigungsverhalten pro Besitzertyp beeinflussen. Beachten Sie, dass diese Rückrufe häufig auf nicht öffentlicher Zugriffsebene definiert werden. Die tatsächlichen Verweise aus den Metadaten zu erhalten, ist im Allgemeinen nicht möglich, wenn die Verweise sich nicht innerhalb Ihres zulässigen Zugriffsbereichs befinden. Weitere Informationen zu Abhängigkeitseigenschaftenrückrufen finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](dependency-property-callbacks-and-validation.md).  
  
-   Wenn die fragliche Abhängigkeitseigenschaft eine Eigenschaft auf WPF-Frameworkebene ist, enthalten die Metadaten möglicherweise Merkmale der Abhängigkeitseigenschaft auf WPF-Frameworkebene, die Informationen und Zustände von Diensten wie der WPF-Framework-Layout-Engine und Eigenschaftsvererbungslogik melden. Weitere Informationen zu diesem Aspekt der Metadaten für Abhängigkeitseigenschaften finden Sie unter [Framework-Eigenschaftenmetadaten](framework-property-metadata.md).  
  
<a name="APIs"></a>   
## <a name="metadata-apis"></a>Metadaten-APIs  
 Ist der Typ, der meisten der vom Eigenschaftensystem verwendeten Metadateninformationen meldet die <xref:System.Windows.PropertyMetadata> Klasse. Metadateninstanzen werden optional angegeben, wenn Abhängigkeitseigenschaften im Eigenschaftensystem registriert werden, und können erneut für zusätzliche Typen angegeben werden, die sich selbst entweder als Besitzer hinzufügen oder Metadaten überschreiben, die sie von der Basisklasse der Definition der Abhängigkeitseigenschaften erben. (Für Fälle, die eine Registrierung, in denen keine Metadaten, der einen Standardwert gibt <xref:System.Windows.PropertyMetadata> wird mit den Standardwerten für diese Klasse erstellt.) Die registrierte Metadaten werden zurückgegeben, als <xref:System.Windows.PropertyMetadata> beim Aufrufen der verschiedenen <xref:System.Windows.DependencyProperty.GetMetadata%2A> Überladungen, die Metadaten von einer Abhängigkeitseigenschaft abrufen, auf eine <xref:System.Windows.DependencyObject> Instanz.  
  
 Die <xref:System.Windows.PropertyMetadata> Klasse wird dann abgeleitet, um spezifischere Metadaten für Architekturaspekte wie die WPF-Frameworkebene Klassen bereitstellen. <xref:System.Windows.UIPropertyMetadata> Fügt animierte Berichterstattung, hinzu und <xref:System.Windows.FrameworkPropertyMetadata> bietet die WPF-Frameworkebene-Eigenschaften, die im vorherigen Abschnitt erwähnt. Wenn Abhängigkeitseigenschaften registriert sind, können sie mit diesen registriert werden <xref:System.Windows.PropertyMetadata> abgeleiteten Klassen. Wenn die Metadaten untersucht werden, wird die <xref:System.Windows.PropertyMetadata> Typ kann potenziell in die abgeleiteten Klassen umgewandelt werden, damit Sie die spezifischeren Eigenschaften prüfen können.  
  
> [!NOTE]
>  Die Eigenschaftenmerkmale, die in angegeben werden können <xref:System.Windows.FrameworkPropertyMetadata> werden manchmal in dieser Dokumentation als "Flags" bezeichnet. Beim Erstellen neuer Metadateninstanzen für die Verwendung in Abhängigkeit Eigenschaft Registrierungen oder Überschreiben von Metadaten, geben Sie diese Werte mithilfe der Flag-Enumeration <xref:System.Windows.FrameworkPropertyMetadataOptions> und stellen Sie dann möglicherweise verkettete Werte der Enumeration der <xref:System.Windows.FrameworkPropertyMetadata> Konstruktor. Allerdings nach erstellt, diese werden offengelegt innerhalb einer <xref:System.Windows.FrameworkPropertyMetadata> als eine Reihe von booleschen Eigenschaften anstelle der erstellende Enumerationswert. Mit den booleschen Eigenschaften können Sie jede Bedingung überprüfen, anstatt eine Maske auf einen Flag-Enumerationswert anzuwenden, um die interessanten Informationen abzurufen. Der Konstruktor verwendet den verketteten <xref:System.Windows.FrameworkPropertyMetadataOptions> um die Länge der Konstruktorsignatur sinnvoll zu begrenzen, während die eigentliche erstellte Metadaten die diskreten Eigenschaften zur Vereinfachung der Abfrage des Metadaten intuitiver macht.  
  
<a name="override_or_subclass"></a>   
## <a name="when-to-override-metadata-when-to-derive-a-class"></a>Überschreiben von Metadaten und Ableiten einer Klasse  
 Das [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Eigenschaftensystem verfügt über Funktionen zum Ändern einiger Merkmale von Abhängigkeitseigenschaften, ohne dass sie vollständig neu implementiert werden müssen. Dies geschieht durch das Erstellen einer anderen Instanz von Metadaten für die Abhängigkeitseigenschaft, wie sie auf einem bestimmten Typ vorhanden ist. Beachten Sie, dass die meisten vorhandenen Abhängigkeitseigenschaften keine virtuellen Eigenschaften sind. Ihre „Neuimplementierung“ in geerbten Klassen könnte also nur das Shadowing des vorhandenen Elements erreicht werden.  
  
 Wenn das Szenario, das Sie für eine Abhängigkeitseigenschaft auf einem Typ umsetzen möchten, durch eine Änderung der Eigenschaften vorhandener Abhängigkeitseigenschaften nicht erreicht werden kann, müssen Sie möglicherweise eine abgeleitete Klasse erstellen und dann auf die abgeleitete Klasse eine benutzerdefinierte Abhängigkeitseigenschaft deklarieren. Eine benutzerdefinierte Abhängigkeitseigenschaft verhält sich genauso wie die von [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-[!INCLUDE[TLA#tla_api#plural](../../../../includes/tlasharptla-apisharpplural-md.md)] definierten Abhängigkeitseigenschaften. Weitere Informationen zu benutzerdefinierten Abhängigkeitseigenschaften finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](custom-dependency-properties.md).  
  
 Ein wichtiges Merkmal einer Abhängigkeitseigenschaft, das überschrieben werden kann, ist der Werttyp. Wenn Sie eine Abhängigkeitseigenschaft erben, die ungefähr das erforderliche Verhalten, aber einen anderen Typ aufweist, müssen Sie eine benutzerdefinierte Abhängigkeitseigenschaft implementieren und die Eigenschaften möglicherweise über die Typkonvertierung oder eine andere Implementierung auf Ihrer Klasse verknüpfen. Darüber hinaus kann nicht ersetzt eine vorhandene <xref:System.Windows.ValidateValueCallback>, da dieser Rückruf im Registrierungsfeld selbst und nicht innerhalb der Metadaten vorhanden ist.  
  
<a name="scenarios"></a>   
## <a name="scenarios-for-changing-existing-metadata"></a>Szenarios zum Ändern vorhandener Metadaten  
 Wenn Sie mit den Metadaten einer vorhandenen Abhängigkeitseigenschaft arbeiten, besteht ein häufiges Szenario für die Änderung der Metadaten der Abhängigkeitseigenschaft in der Änderung des Standardwerts. Das Ändern oder Hinzufügen von Eigenschaftensystemrückrufen ist ein erweitertes Szenario. Wenn Ihre Implementierung einer abgeleiteten Klasse verschiedene Wechselbeziehungen zwischen Abhängigkeitseigenschaften aufweist, ist dieses Szenario möglicherweise hilfreich. Eine der Voraussetzungen eines Programmiermodells, das sowohl Code als auch deklarative Verwendung unterstützt, ist die Möglichkeit, Eigenschaften in einer beliebigen Reihenfolge festzulegen. Daher müssen alle abhängigen Eigenschaften Just-In-Time ohne Kontext festgelegt werden und dürfen sich nicht auf die Kenntnis einer Festlegungsreihenfolge verlassen, wie z.B. in einem Konstruktor. Weitere Informationen zu diesem Aspekt des Eigenschaftensystems finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](dependency-property-callbacks-and-validation.md). Beachten Sie, dass Überprüfungsrückrufe kein Teil der Metadaten sind. Sie gehören zum Bezeichner der Abhängigkeitseigenschaft. Aus diesem Grund können Überprüfungsrückrufe nicht durch das Überschreiben der Metadaten geändert werden.  
  
 In einigen Fällen möchten Sie möglicherweise auch die Eigenschaftenmetadatenoptionen auf WPF-Frameworkebene für vorhandene Abhängigkeitseigenschaften ändern. Diese Optionen kommunizieren bestimmte bekannte Bedingungen zu Eigenschaften auf WPF-Frameworkebene an andere Prozesse auf WPF-Frameworkebene wie das Layoutsystem.  Festlegen der Optionen erfolgt in der Regel nur, wenn Sie eine neue Abhängigkeitseigenschaft registrieren, aber es ist auch möglich, so ändern Sie die Eigenschaftenmetadaten für WPF-Frameworkebene als Teil einer <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> oder <xref:System.Windows.DependencyProperty.AddOwner%2A> aufrufen. Die genauen Werte, die verwendet werden müssen, und weitere Informationen finden Sie unter [Framework-Eigenschaftenmetadaten](framework-property-metadata.md). Weitere Informationen zu Festlegung dieser Optionen für neu registrierte Abhängigkeitseigenschaften finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](custom-dependency-properties.md).  
  
<a name="dp_override_metadata"></a>   
### <a name="overriding-metadata"></a>Überschreiben von Metadaten  
 Metadaten werden in erster Linie überschrieben, damit Sie die verschiedenen, von Metadaten abgeleiteten Verhaltensweisen ändern können, die auf die Abhängigkeitseigenschaft, so wie sie auf Ihrem Typ vorhanden ist, angewendet werden. Die Gründe hierfür werden ausführlicher im Abschnitt [Metadaten](#dp_metadata_contents) erläutert. Weitere Informationen und Codebeispiele finden Sie unter [Überschreiben von Metadaten für eine Abhängigkeitseigenschaft](how-to-override-metadata-for-a-dependency-property.md).  
  
 Eigenschaftenmetadaten kann für eine Abhängigkeitseigenschaft während des Registrierungsaufrufs bereitgestellt werden (<xref:System.Windows.DependencyProperty.Register%2A>). In vielen Fällen stellen Sie jedoch typspezifische Metadaten für Ihre Klasse bereit, wenn sie die Abhängigkeitseigenschaft erbt. Sie erreichen dies durch den Aufruf der <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Methode.  Ein Beispiel von der [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)], <xref:System.Windows.FrameworkElement> Klasse ist der Typ, der zuerst registriert die <xref:System.Windows.UIElement.Focusable%2A> Abhängigkeitseigenschaft. Aber die <xref:System.Windows.Controls.Control> Klasse überschreibt die Metadaten für die Abhängigkeitseigenschaft, geben Sie eine eigene anfängliche-Wert, der Änderung von `false` zu `true`, und verwendet andernfalls die ursprüngliche <xref:System.Windows.UIElement.Focusable%2A> Implementierung.  
  
 Wenn Sie Metadaten überschreiben, werden die verschiedenen Metadateneigenschaften entweder zusammengeführt oder ersetzt.  
  
-   <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> wird zusammengeführt. Wenn Sie ein neues hinzufügen <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, dieser Rückruf in den Metadaten gespeichert ist. Wenn Sie keinen angeben einer <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> in der Überschreibung der Wert des <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> wird höher gestuft, als Verweis vom nächsten Vorgänger, der Metadaten angegeben.  
  
-   Das Verhalten des tatsächlichen Eigenschaftensystems für <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> besteht darin, dass die Implementierungen für alle Metadaten in der Hierarchie beibehalten und einer Tabelle mit der Reihenfolge der Ausführung vom Eigenschaftensystem hinzugefügt, dass die am stärksten abgeleitete Klasse zuerst aufgerufen wird.  
  
-   <xref:System.Windows.PropertyMetadata.DefaultValue%2A> wird ersetzt. Wenn Sie keinen angeben einer <xref:System.Windows.PropertyMetadata.DefaultValue%2A> in der Überschreibung der Wert des <xref:System.Windows.PropertyMetadata.DefaultValue%2A> stammt aus der unmittelbaren Vorgänger, der Metadaten angegeben.  
  
-   <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> -Implementierungen werden ersetzt. Wenn Sie ein neues hinzufügen <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, dieser Rückruf in den Metadaten gespeichert ist. Wenn Sie keinen angeben einer <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in der Überschreibung der Wert des <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> wird höher gestuft, als Verweis vom nächsten Vorgänger, der Metadaten angegeben.  
  
-   Verhalten des Eigenschaftensystems ist, dass nur die <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in den unmittelbaren Metadaten aufgerufen wird. Keine Verweise auf andere <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> Implementierungen in der Hierarchie werden beibehalten.  
  
 Dieses Verhalten wird implementiert, indem <xref:System.Windows.PropertyMetadata.Merge%2A>, und kann für abgeleitete Metadatenklassen überschrieben werden.  
  
#### <a name="overriding-attached-property-metadata"></a>Überschreiben von Metadaten der angefügten Eigenschaft  
 Angefügte Eigenschaften werden in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] als Abhängigkeitseigenschaften implementiert. Dies bedeutet, dass sie auch Metadaten besitzen, die von einzelnen Klassen überschrieben werden können. Die bereichsüberlegungen für eine angefügte Eigenschaft in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] sind in der Regel, die alle <xref:System.Windows.DependencyObject> haben eine angefügte Eigenschaft festgelegt werden. Aus diesem Grund alle <xref:System.Windows.DependencyObject> abgeleitete Klasse kann die Metadaten für eine angefügte Eigenschaft überschreiben, wie sie auf eine Instanz der Klasse festgelegt werden kann. Sie können Standardwerte, Rückrufe oder Eigenschaften der Berichterstattung über Merkmale auf WPF-Frameworkebene überschreiben. Wenn die angefügte Eigenschaft auf eine Instanz Ihrer Klasse festgelegt ist, finden diese Merkmale zum Überschreiben von Metadateneigenschaften Anwendung. Falls die Eigenschaft nicht anderweitig festgelegt ist, können Sie z.B. den Standardwert überschreiben, sodass der Überschreibungswert als der Wert der angefügten Eigenschaft auf Ihren Klasseninstanzen gemeldet wird.  
  
> [!NOTE]
>  Die <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> Eigenschaft ist nicht relevant für angefügte Eigenschaften.  
  
<a name="dp_add_owner"></a>   
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a>Hinzufügen einer Klasse als Besitzer einer vorhandenen Abhängigkeitseigenschaft  
 Eine Klasse kann sich selbst als Besitzer einer Abhängigkeitseigenschaft, die bereits registriert wurde, mithilfe von Hinzufügen der <xref:System.Windows.DependencyProperty.AddOwner%2A> Methode. Dadurch kann die Klasse eine Abhängigkeitseigenschaft verwenden, die ursprünglich für einen anderen Typ registriert wurde. Die hinzugefügte Klasse ist in der Regel keine abgeleitete Klasse des Typs, der die Abhängigkeitseigenschaft zuerst als Besitzer registriert hat. Aus diesem Grund kann die Klasse und ihre abgeleiteten Klassen eine Implementierung von Abhängigkeitseigenschaften ohne die ursprüngliche Besitzerklasse „erben“, und ohne dass die hinzufügende Klasse der gleichen echten Klassenhierarchie angehört. Darüber hinaus kann die hinzufügende Klasse (und auch alle abgeleiteten Klassen) typspezifische Metadaten für die ursprüngliche Abhängigkeitseigenschaft bereitstellen.  
  
 Die hinzufügende Klasse sollte sich nicht nur über die Hilfsprogrammmethoden des Eigenschaftensystems als Besitzer hinzufügen, sondern auch weitere öffentliche Member für sich selbst deklarieren, um die Abhängigkeitseigenschaft in einen vollständigen Bestandteil des Eigenschaftensystems zu verwandeln, der für Code und Markup verfügbar ist. Eine Klasse, die eine vorhandene Abhängigkeitseigenschaft hinzufügt, hat beim Verfügbarmachen des Objektmodells für die Abhängigkeitseigenschaft die gleichen Aufgaben wie eine Klasse, die eine neue benutzerdefinierte Abhängigkeitseigenschaft definiert. Der erste Member, der verfügbar gemacht wird, ist ein Bezeichnerfeld für die Abhängigkeitseigenschaft. Dieses Feld muss eine `public static readonly` -Feld des Typs <xref:System.Windows.DependencyProperty>, die den Rückgabewert zugewiesen ist die <xref:System.Windows.DependencyProperty.AddOwner%2A> aufrufen. Der zweite zu definierende Member ist die „Wrappereigenschaft“ der [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]. Der Wrapper macht es wesentlich bequemer, bearbeiten Ihre Abhängigkeitseigenschaften im Code (Sie vermeiden, Aufrufe von <xref:System.Windows.DependencyObject.SetValue%2A> jedes Mal, und müssen diesen Aufruf nur einmal im Wrapper selbst). Der Wrapper wird genauso implementiert, wie dies auch beim Registrieren einer benutzerdefinierten Abhängigkeitseigenschaft der Fall wäre. Weitere Informationen zum Implementieren einer Abhängigkeitseigenschaft finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](custom-dependency-properties.md) und [Hinzufügen eines Besitzertyps für eine Abhängigkeitseigenschaft](how-to-add-an-owner-type-for-a-dependency-property.md).  
  
#### <a name="addowner-and-attached-properties"></a>AddOwner und angefügte Eigenschaften  
 Rufen Sie <xref:System.Windows.DependencyProperty.AddOwner%2A> für eine Abhängigkeitseigenschaft, die durch die Besitzerklasse als angefügte Eigenschaft definiert ist. Der Zweck liegt im Allgemeinen darin, die zuvor angefügte Eigenschaft als nicht angefügte Abhängigkeitseigenschaft verfügbar zu machen. Sie wird verfügbar machen die <xref:System.Windows.DependencyProperty.AddOwner%2A> Rückgabewert als ein `public static readonly` Feld für die Verwendung als Bezeichner der Abhängigkeitseigenschaft und entsprechenden Wrapper-Eigenschaften definieren, damit die Eigenschaft in der Membertabelle erscheint und nicht angefügte Eigenschaft unterstützt die Verwendung in Ihrer Klasse.  
  
## <a name="see-also"></a>Siehe auch

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md)
- [Framework-Eigenschaftenmetadaten](framework-property-metadata.md)
