---
title: Metadaten für Abhängigkeitseigenschaften
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 3d84510fce69e81929cbe9b6088e12aaf3409769
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186365"
---
# <a name="dependency-property-metadata"></a>Metadaten für Abhängigkeitseigenschaften
Das [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] Eigenschaftensystem umfasst ein Metadatenberichtssystem, das über das hinausgeht, was über eine Eigenschaft durch Reflektion oder allgemeine CLR-Eigenschaften (Common Language Runtime) berichtet werden kann. Metadaten für eine Abhängigkeitseigenschaft können auch eindeutig durch die Klasse zugewiesen werden, die eine Abhängigkeitseigenschaft definiert, sie können geändert werden, wenn die Abhängigkeitseigenschaft zu einer anderen Klasse hinzugefügt wird, und sie können gezielt von allen abgeleiteten Klassen überschrieben werden, die die Abhängigkeitseigenschaft von der definierenden Basisklasse erben.  

<a name="prerequisites"></a>
## <a name="prerequisites"></a>Voraussetzungen  
 In diesem Thema wird davon ausgegangen, dass Sie Abhängigkeitseigenschaften aus Sicht eines Consumers vorhandener Abhängigkeitseigenschaften von [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-Klassen verstehen und die [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md) gelesen haben. Um den Beispielen in diesem Thema zu folgen, sollten Sie zudem mit [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] vertraut sein und wissen, wie [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Anwendungen geschrieben werden.  
  
<a name="dp_metadata_contents"></a>
## <a name="how-dependency-property-metadata-is-used"></a>So werden Metadaten für Abhängigkeitseigenschaften genutzt  
 Metadaten für Abhängigkeitseigenschaften sind ein Objekt vorhanden, das zur Untersuchung der Eigenschaften einer Abhängigkeitseigenschaft abgefragt werden kann. Auch das Eigenschaftensystem greift häufig auf diese Metadaten zu, da es alle Abhängigkeitseigenschaften verarbeitet. Das Metadatenobjekt für eine Abhängigkeitseigenschaft kann die folgenden Informationstypen enthalten:  
  
- Standardwert für die Abhängigkeitseigenschaft, wenn kein anderer Wert für die Abhängigkeitseigenschaft anhand des lokalen Werts, des Stils, der Vererbung usw. bestimmt werden kann. Eine ausführliche Erläuterung, wie Standardwerte an der Vom Eigenschaftensystem beim Zuweisen von Werten für Abhängigkeitseigenschaften verwendeten Priorität beteiligt sind, finden Sie unter [Dependency Property Value Priority](dependency-property-value-precedence.md).  
  
- Verweise auf die Rückrufimplementierungen, die das Umwandlungs- oder Änderungsbenachrichtigungsverhalten pro Besitzertyp beeinflussen. Beachten Sie, dass diese Rückrufe häufig auf nicht öffentlicher Zugriffsebene definiert werden. Die tatsächlichen Verweise aus den Metadaten zu erhalten, ist im Allgemeinen nicht möglich, wenn die Verweise sich nicht innerhalb Ihres zulässigen Zugriffsbereichs befinden. Weitere Informationen zu Abhängigkeitseigenschaftenrückrufen finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](dependency-property-callbacks-and-validation.md).  
  
- Wenn die fragliche Abhängigkeitseigenschaft eine Eigenschaft auf WPF-Frameworkebene ist, enthalten die Metadaten möglicherweise Merkmale der Abhängigkeitseigenschaft auf WPF-Frameworkebene, die Informationen und Zustände von Diensten wie der WPF-Framework-Layout-Engine und Eigenschaftsvererbungslogik melden. Weitere Informationen zu diesem Aspekt der Metadaten für Abhängigkeitseigenschaften finden Sie unter [Framework-Eigenschaftenmetadaten](framework-property-metadata.md).  
  
<a name="APIs"></a>
## <a name="metadata-apis"></a>Metadaten-APIs  
 Der Typ, der die meisten Metadateninformationen meldet, <xref:System.Windows.PropertyMetadata> die vom Eigenschaftensystem verwendet werden, ist die Klasse. Metadateninstanzen werden optional angegeben, wenn Abhängigkeitseigenschaften im Eigenschaftensystem registriert werden, und können erneut für zusätzliche Typen angegeben werden, die sich selbst entweder als Besitzer hinzufügen oder Metadaten überschreiben, die sie von der Basisklasse der Definition der Abhängigkeitseigenschaften erben. (Für Fälle, in denen eine Eigenschaftsregistrierung keine Metadaten angibt, wird ein Standardwert <xref:System.Windows.PropertyMetadata> mit Standardwerten für diese Klasse erstellt.) Die registrierten Metadaten <xref:System.Windows.PropertyMetadata> werden zurückgegeben, <xref:System.Windows.DependencyProperty.GetMetadata%2A> wenn Sie die verschiedenen Überladungen aufrufen, die Metadaten von einer Abhängigkeitseigenschaft auf einer <xref:System.Windows.DependencyObject> Instanz abrufen.  
  
 Die <xref:System.Windows.PropertyMetadata> Klasse wird dann abgeleitet, um spezifischere Metadaten für Architekturbereiche wie die WPF-Framework-Level-Klassen bereitzustellen. <xref:System.Windows.UIPropertyMetadata>fügt Animationsberichte <xref:System.Windows.FrameworkPropertyMetadata> hinzu und stellt die im vorherigen Abschnitt erwähnten WPF-Framework-Eigenschaften bereit. Wenn Abhängigkeitseigenschaften registriert werden, können <xref:System.Windows.PropertyMetadata> sie mit diesen abgeleiteten Klassen registriert werden. Wenn die Metadaten untersucht <xref:System.Windows.PropertyMetadata> werden, kann der Basistyp möglicherweise in die abgeleiteten Klassen umgegeut werden, sodass Sie die spezifischeren Eigenschaften untersuchen können.  
  
> [!NOTE]
> Die Eigenschaftsmerkmale, die <xref:System.Windows.FrameworkPropertyMetadata> in angegeben werden können, werden in dieser Dokumentation manchmal als "Flags" bezeichnet. Wenn Sie neue Metadateninstanzen für die Verwendung in Abhängigkeitseigenschaftsregistrierungen oder Metadatenüberschreibungen erstellen, geben Sie diese Werte mithilfe der flagweisen Enumeration <xref:System.Windows.FrameworkPropertyMetadataOptions> an und geben dann möglicherweise verkettete Werte der Enumeration an den <xref:System.Windows.FrameworkPropertyMetadata> Konstruktor an. Nach der Erstellung werden diese Optionseigenschaften <xref:System.Windows.FrameworkPropertyMetadata> jedoch innerhalb einer Reihe boolescher Eigenschaften und nicht als Konstruktionsaufzählungswert verfügbar gemacht. Mit den booleschen Eigenschaften können Sie jede Bedingung überprüfen, anstatt eine Maske auf einen Flag-Enumerationswert anzuwenden, um die interessanten Informationen abzurufen. Der Konstruktor verwendet die verkettete, <xref:System.Windows.FrameworkPropertyMetadataOptions> um die Länge der Konstruktorsignatur angemessen zu halten, während die tatsächlich erstellten Metadaten die diskreten Eigenschaften verfügbar machen, um das Abfragen der Metadaten intuitiver zu gestalten.  
  
<a name="override_or_subclass"></a>
## <a name="when-to-override-metadata-when-to-derive-a-class"></a>Überschreiben von Metadaten und Ableiten einer Klasse  
 Das [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Eigenschaftensystem verfügt über Funktionen zum Ändern einiger Merkmale von Abhängigkeitseigenschaften, ohne dass sie vollständig neu implementiert werden müssen. Dies geschieht durch das Erstellen einer anderen Instanz von Metadaten für die Abhängigkeitseigenschaft, wie sie auf einem bestimmten Typ vorhanden ist. Beachten Sie, dass die meisten vorhandenen Abhängigkeitseigenschaften keine virtuellen Eigenschaften sind. Ihre „Neuimplementierung“ in geerbten Klassen könnte also nur das Shadowing des vorhandenen Elements erreicht werden.  
  
 Wenn das Szenario, das Sie für eine Abhängigkeitseigenschaft auf einem Typ umsetzen möchten, durch eine Änderung der Eigenschaften vorhandener Abhängigkeitseigenschaften nicht erreicht werden kann, müssen Sie möglicherweise eine abgeleitete Klasse erstellen und dann auf die abgeleitete Klasse eine benutzerdefinierte Abhängigkeitseigenschaft deklarieren. Eine benutzerdefinierte Abhängigkeitseigenschaft verhält sich identisch [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] mit Abhängigkeitseigenschaften, die von den APIs definiert werden. Weitere Informationen zu benutzerdefinierten Abhängigkeitseigenschaften finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](custom-dependency-properties.md).  
  
 Ein wichtiges Merkmal einer Abhängigkeitseigenschaft, das überschrieben werden kann, ist der Werttyp. Wenn Sie eine Abhängigkeitseigenschaft erben, die ungefähr das erforderliche Verhalten, aber einen anderen Typ aufweist, müssen Sie eine benutzerdefinierte Abhängigkeitseigenschaft implementieren und die Eigenschaften möglicherweise über die Typkonvertierung oder eine andere Implementierung auf Ihrer Klasse verknüpfen. Außerdem können Sie einen <xref:System.Windows.ValidateValueCallback>vorhandenen ersetzen, da dieser Rückruf im Registrierungsfeld selbst und nicht in seinen Metadaten vorhanden ist.  
  
<a name="scenarios"></a>
## <a name="scenarios-for-changing-existing-metadata"></a>Szenarios zum Ändern vorhandener Metadaten  
 Wenn Sie mit den Metadaten einer vorhandenen Abhängigkeitseigenschaft arbeiten, besteht ein häufiges Szenario für die Änderung der Metadaten der Abhängigkeitseigenschaft in der Änderung des Standardwerts. Das Ändern oder Hinzufügen von Eigenschaftensystemrückrufen ist ein erweitertes Szenario. Wenn Ihre Implementierung einer abgeleiteten Klasse verschiedene Wechselbeziehungen zwischen Abhängigkeitseigenschaften aufweist, ist dieses Szenario möglicherweise hilfreich. Eine der Voraussetzungen eines Programmiermodells, das sowohl Code als auch deklarative Verwendung unterstützt, ist die Möglichkeit, Eigenschaften in einer beliebigen Reihenfolge festzulegen. Daher müssen alle abhängigen Eigenschaften Just-In-Time ohne Kontext festgelegt werden und dürfen sich nicht auf die Kenntnis einer Festlegungsreihenfolge verlassen, wie z.B. in einem Konstruktor. Weitere Informationen zu diesem Aspekt des Eigenschaftensystems finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](dependency-property-callbacks-and-validation.md). Beachten Sie, dass Überprüfungsrückrufe kein Teil der Metadaten sind. Sie gehören zum Bezeichner der Abhängigkeitseigenschaft. Aus diesem Grund können Überprüfungsrückrufe nicht durch das Überschreiben der Metadaten geändert werden.  
  
 In einigen Fällen möchten Sie möglicherweise auch die Eigenschaftenmetadatenoptionen auf WPF-Frameworkebene für vorhandene Abhängigkeitseigenschaften ändern. Diese Optionen kommunizieren bestimmte bekannte Bedingungen zu Eigenschaften auf WPF-Frameworkebene an andere Prozesse auf WPF-Frameworkebene wie das Layoutsystem.  Das Festlegen der Optionen erfolgt in der Regel nur beim Registrieren einer neuen Abhängigkeitseigenschaft, es ist <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> <xref:System.Windows.DependencyProperty.AddOwner%2A> jedoch auch möglich, die Eigenschaftenmetadaten auf WPF-Frameworkebene als Teil eines Aufrufs oder Aufrufs zu ändern. Die genauen Werte, die verwendet werden müssen, und weitere Informationen finden Sie unter [Framework-Eigenschaftenmetadaten](framework-property-metadata.md). Weitere Informationen zu Festlegung dieser Optionen für neu registrierte Abhängigkeitseigenschaften finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](custom-dependency-properties.md).  
  
<a name="dp_override_metadata"></a>
### <a name="overriding-metadata"></a>Überschreiben von Metadaten  
 Metadaten werden in erster Linie überschrieben, damit Sie die verschiedenen, von Metadaten abgeleiteten Verhaltensweisen ändern können, die auf die Abhängigkeitseigenschaft, so wie sie auf Ihrem Typ vorhanden ist, angewendet werden. Die Gründe hierfür werden ausführlicher im Abschnitt [Metadaten](#dp_metadata_contents) erläutert. Weitere Informationen und Codebeispiele finden Sie unter [Überschreiben von Metadaten für eine Abhängigkeitseigenschaft](how-to-override-metadata-for-a-dependency-property.md).  
  
 Eigenschaftsmetadaten können während des Registrierungsaufrufs<xref:System.Windows.DependencyProperty.Register%2A>( ) für eine Abhängigkeitseigenschaft bereitgestellt werden. In vielen Fällen stellen Sie jedoch typspezifische Metadaten für Ihre Klasse bereit, wenn sie die Abhängigkeitseigenschaft erbt. Sie können dies <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> tun, indem Sie die Methode aufrufen.  Für ein Beispiel [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aus den <xref:System.Windows.FrameworkElement> APIs ist die Klasse <xref:System.Windows.UIElement.Focusable%2A> der Typ, der zuerst die Abhängigkeitseigenschaft registriert. Die <xref:System.Windows.Controls.Control> Klasse überschreibt jedoch Metadaten für die Abhängigkeitseigenschaft, um `false` `true`ihren eigenen ursprünglichen Standardwert <xref:System.Windows.UIElement.Focusable%2A> bereitzustellen, ihn von in zu ändern und andernfalls die ursprüngliche Implementierung erneut zu verwenden.  
  
 Wenn Sie Metadaten überschreiben, werden die verschiedenen Metadateneigenschaften entweder zusammengeführt oder ersetzt.  
  
- <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>wird zusammengeführt. Wenn Sie eine <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>neue hinzufügen, wird dieser Rückruf in den Metadaten gespeichert. Wenn Sie in <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> der Außerkraftsetzung keine <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> angeben, wird der Wert von als Verweis vom nächstgelegenen Vorgänger heraufgestuft, der ihn in Metadaten angegeben hat.  
  
- Das tatsächliche Eigenschaftensystemverhalten für <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> ist, dass Implementierungen für alle Metadatenbesitzer in der Hierarchie beibehalten und einer Tabelle hinzugefügt werden, wobei die Ausführungsreihenfolge durch das Eigenschaftensystem darin besteht, dass die Rückrufe der am häufigsten abgeleiteten Klasse zuerst aufgerufen werden.  
  
- <xref:System.Windows.PropertyMetadata.DefaultValue%2A>wird ersetzt. Wenn Sie in <xref:System.Windows.PropertyMetadata.DefaultValue%2A> der Außerkraftsetzung keine <xref:System.Windows.PropertyMetadata.DefaultValue%2A> angeben, stammt der Wert von vom nächsten Vorgänger, der ihn in Metadaten angegeben hat.  
  
- <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>Implementierungen werden ersetzt. Wenn Sie eine <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>neue hinzufügen, wird dieser Rückruf in den Metadaten gespeichert. Wenn Sie in <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> der Außerkraftsetzung keine <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> angeben, wird der Wert von als Verweis vom nächstgelegenen Vorgänger heraufgestuft, der ihn in Metadaten angegeben hat.  
  
- Das Verhalten des Eigenschaftensystems <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> besteht darin, dass nur die in den unmittelbaren Metadaten aufgerufen werden. Es werden <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> keine Verweise auf andere Implementierungen in der Hierarchie beibehalten.  
  
 Dieses Verhalten wird <xref:System.Windows.PropertyMetadata.Merge%2A>von implementiert und kann für abgeleitete Metadatenklassen überschrieben werden.  
  
#### <a name="overriding-attached-property-metadata"></a>Überschreiben von Metadaten der angefügten Eigenschaft  
 Angefügte Eigenschaften werden in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] als Abhängigkeitseigenschaften implementiert. Dies bedeutet, dass sie auch Metadaten besitzen, die von einzelnen Klassen überschrieben werden können. Die Scoping-Überlegungen für [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] eine angefügte <xref:System.Windows.DependencyObject> Eigenschaft in sind im Allgemeinen, dass jede eine angefügte Eigenschaft für sie festgelegt haben kann. Daher kann <xref:System.Windows.DependencyObject> jede abgeleitete Klasse die Metadaten für jede angefügte Eigenschaft überschreiben, da sie möglicherweise für eine Instanz der Klasse festgelegt wird. Sie können Standardwerte, Rückrufe oder Eigenschaften der Berichterstattung über Merkmale auf WPF-Frameworkebene überschreiben. Wenn die angefügte Eigenschaft auf eine Instanz Ihrer Klasse festgelegt ist, finden diese Merkmale zum Überschreiben von Metadateneigenschaften Anwendung. Falls die Eigenschaft nicht anderweitig festgelegt ist, können Sie z.B. den Standardwert überschreiben, sodass der Überschreibungswert als der Wert der angefügten Eigenschaft auf Ihren Klasseninstanzen gemeldet wird.  
  
> [!NOTE]
> Die <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> Eigenschaft ist für angefügte Eigenschaften nicht relevant.  
  
<a name="dp_add_owner"></a>
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a>Hinzufügen einer Klasse als Besitzer einer vorhandenen Abhängigkeitseigenschaft  
 Eine Klasse kann sich selbst als Besitzer einer Abhängigkeitseigenschaft hinzufügen, die bereits registriert wurde, indem sie die <xref:System.Windows.DependencyProperty.AddOwner%2A> Methode verwendet. Dadurch kann die Klasse eine Abhängigkeitseigenschaft verwenden, die ursprünglich für einen anderen Typ registriert wurde. Die hinzugefügte Klasse ist in der Regel keine abgeleitete Klasse des Typs, der die Abhängigkeitseigenschaft zuerst als Besitzer registriert hat. Aus diesem Grund kann die Klasse und ihre abgeleiteten Klassen eine Implementierung von Abhängigkeitseigenschaften ohne die ursprüngliche Besitzerklasse „erben“, und ohne dass die hinzufügende Klasse der gleichen echten Klassenhierarchie angehört. Darüber hinaus kann die hinzufügende Klasse (und auch alle abgeleiteten Klassen) typspezifische Metadaten für die ursprüngliche Abhängigkeitseigenschaft bereitstellen.  
  
 Die hinzufügende Klasse sollte sich nicht nur über die Hilfsprogrammmethoden des Eigenschaftensystems als Besitzer hinzufügen, sondern auch weitere öffentliche Member für sich selbst deklarieren, um die Abhängigkeitseigenschaft in einen vollständigen Bestandteil des Eigenschaftensystems zu verwandeln, der für Code und Markup verfügbar ist. Eine Klasse, die eine vorhandene Abhängigkeitseigenschaft hinzufügt, hat beim Verfügbarmachen des Objektmodells für die Abhängigkeitseigenschaft die gleichen Aufgaben wie eine Klasse, die eine neue benutzerdefinierte Abhängigkeitseigenschaft definiert. Der erste Member, der verfügbar gemacht wird, ist ein Bezeichnerfeld für die Abhängigkeitseigenschaft. Bei diesem Feld `public static readonly` sollte <xref:System.Windows.DependencyProperty>es sich um ein Feld <xref:System.Windows.DependencyProperty.AddOwner%2A> vom Typ handelt, das dem Rückgabewert des Aufrufs zugewiesen ist. Das zweite zu definierende Element ist die Common Language Runtime (CLR) "wrapper"-Eigenschaft. Der Wrapper macht es viel bequemer, Ihre Abhängigkeitseigenschaft <xref:System.Windows.DependencyObject.SetValue%2A> im Code zu manipulieren (Sie vermeiden Aufrufe jedes Mal und können diesen Aufruf nur einmal im Wrapper selbst tätigen). Der Wrapper wird genauso implementiert, wie dies auch beim Registrieren einer benutzerdefinierten Abhängigkeitseigenschaft der Fall wäre. Weitere Informationen zum Implementieren einer Abhängigkeitseigenschaft finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](custom-dependency-properties.md) und [Hinzufügen eines Besitzertyps für eine Abhängigkeitseigenschaft](how-to-add-an-owner-type-for-a-dependency-property.md).  
  
#### <a name="addowner-and-attached-properties"></a>AddOwner und angefügte Eigenschaften  
 Sie können <xref:System.Windows.DependencyProperty.AddOwner%2A> eine Abhängigkeitseigenschaft aufrufen, die von der Eigentümerklasse als angefügte Eigenschaft definiert ist. Der Zweck liegt im Allgemeinen darin, die zuvor angefügte Eigenschaft als nicht angefügte Abhängigkeitseigenschaft verfügbar zu machen. Anschließend machen Sie <xref:System.Windows.DependencyProperty.AddOwner%2A> den Rückgabewert als `public static readonly` Feld für die Verwendung als Abhängigkeitseigenschaftsbezeichner verfügbar und definieren entsprechende "Wrapper"-Eigenschaften, sodass die Eigenschaft in der Members-Tabelle angezeigt wird und eine nicht angefügte Eigenschaftsverwendung in Ihrer Klasse unterstützt.  
  
## <a name="see-also"></a>Weitere Informationen

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md)
- [Framework-Eigenschaftenmetadaten](framework-property-metadata.md)
