---
title: Priorität von Abhängigkeitseigenschaftswerten
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], classes as owners
- dependency properties [WPF], metadata
- classes [WPF], owners of dependency properties
- metadata [WPF], dependency properties
ms.assetid: 1fbada8e-4867-4ed1-8d97-62c07dad7ebc
ms.openlocfilehash: 1d7c644c7f7581a96ffff1a0fe1fcf2adfe071e0
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186147"
---
# <a name="dependency-property-value-precedence"></a>Priorität von Abhängigkeitseigenschaftswerten
<a name="introduction"></a> In diesem Thema wird erläutert, wie die Funktionsweise des [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-Eigenschaftensystems den Wert einer Abhängigkeitseigenschaft beeinflussen kann. Außerdem wird die Rangfolge beschrieben, nach der Aspekte des Eigenschaftensystems auf den effektiven Wert einer Eigenschaft angewendet werden.  

<a name="prerequisites"></a>
## <a name="prerequisites"></a>Voraussetzungen  
 In diesem Thema wird davon ausgegangen, dass Sie Abhängigkeitseigenschaften aus Sicht eines Consumers vorhandener Abhängigkeitseigenschaften von [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Klassen verstehen und die [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md) gelesen haben. Um den Beispielen in diesem Thema zu folgen, sollten Sie zudem [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] verstehen und wissen, wie [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Anwendungen geschrieben werden.  
  
<a name="intro"></a>
## <a name="the-wpf-property-system"></a>Das WPF-Eigenschaftensystem  
 Das [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Eigenschaftensystem bietet eine leistungsstarke Möglichkeit, den Wert von Abhängigkeitseigenschaften durch eine Vielzahl von Faktoren zu bestimmen, wobei Funktionen wie die Validierung von Eigenschaften in Echtzeit, die späte Bindung und das Benachrichtigen von verknüpften Eigenschaften über Änderungen an Werten für andere Eigenschaften aktiviert werden. Die genaue Reihenfolge und Logik, die zur Bestimmung der Werte von Abhängigkeitseigenschaften verwendet werden, ist relativ komplex. Indem Sie diese Reihenfolge kennen, können Sie unnötige Eigenschafteneinstellungen vermeiden und klären, wieso genau ein Versuch zur Beeinflussung oder zum Vorhersehen eines Werts einer Abhängigkeitseigenschaft nicht zum erwarteten Wert geführt hat.  
  
<a name="multiple_sets"></a>
## <a name="dependency-properties-might-be-set-in-multiple-places"></a>Abhängigkeitseigenschaften können an mehreren Orten festgelegt („Set“) werden  
 Im folgenden [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] Beispiel gibt es<xref:System.Windows.Controls.Control.Background%2A>drei verschiedene "Set"-Operationen, die den Wert beeinflussen können.  
  
 [!code-xaml[PropertiesOvwSupport#DPPrecedence](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#dpprecedence)]  
  
 Was erwarten Sie, welche Farbe hier angewendet wird – rot, grün oder blau?  
  
 Mit Ausnahme von animierten Werten und Koersion werden lokale Eigenschaftensätze mit der höchsten Priorität festgelegt. Wenn Sie einen Wert lokal festlegen, können Sie erwarten, dass der Wert selbst vor Stilen oder Steuerelementvorlagen berücksichtigt wird. Hier im Beispiel, <xref:System.Windows.Controls.Control.Background%2A> wird auf Rot lokal gesetzt. Daher ist der in diesem Bereich definierte Stil, auch wenn es sich um einen impliziten Stil handelt, der <xref:System.Windows.Controls.Control.Background%2A> andernfalls für alle Elemente dieses Typs in diesem Bereich gelten würde, nicht die höchste Priorität, wenn der Eigenschaft ihr Wert gegeben wird.  Wenn Sie den lokalen Wert „Red“ von dieser Schaltflächeninstanz entfernt hätten, hätte der Stil Vorrang, und die Schaltfläche würde den „Background“-Wert vom Stil erhalten.  Innerhalb des Stils haben Trigger Vorrang, sodass die Schaltfläche blau sein wird, wenn die Maus darauf zeigt, und andernfalls grün.  
  
<a name="listing"></a>
## <a name="dependency-property-setting-precedence-list"></a>Rangfolgeliste bei der Einstellung von Abhängigkeitseigenschaften  
 Im Folgenden finden Sie die definitive Reihenfolge, die vom Eigenschaftensystem beim Zuweisen der Laufzeitwerte von Abhängigkeitseigenschaften verwendet wird. Die oberste Priorität ist zuerst aufgeführt. Diese Liste erweitert einige der Verallgemeinerungen aus der [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md).  
  
1. **Eigenschaftensystemkoersion.** Weitere Informationen zur Koersion finden Sie unter [Koersion, Animationen und Basiswert](#animations) weiter unten in diesem Thema.  
  
2. **Aktive Animationen oder Animationen mit einem Halteverhalten.** Damit eine Animation einer Eigenschaft eine praktische Auswirkung hat, muss sie Vorrang vor dem (nicht animierten) Basiswert haben können, selbst wenn dieser Wert lokal festgelegt wurde. Weitere Informationen finden Sie unter [Koersion, Animationen und Basiswert](#animations) weiter unten in diesem Thema.  
  
3. **Lokaler Wert.** Ein lokaler Wert kann durch die Bequemlichkeit der "wrapper"-Eigenschaft festgelegt werden, die [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]auch der Einstellung als <xref:System.Windows.DependencyObject.SetValue%2A> Attribut- oder Eigenschaftselement in oder durch einen Aufruf der API mithilfe einer Eigenschaft einer bestimmten Instanz entspricht. Wenn Sie einen lokalen Wert mithilfe einer Bindung oder eine Ressource festlegen, haben diese jeweils Vorrang, als ob ein direkter Wert festgelegt wurde.  
  
4. **TemplatedParent-Vorlageneigenschaften.** Ein Element <xref:System.Windows.FrameworkElement.TemplatedParent%2A> hat eine, wenn es als <xref:System.Windows.Controls.ControlTemplate> Teil <xref:System.Windows.DataTemplate>einer Vorlage (a oder ) erstellt wurde. Weitere Informationen dazu, wann dies zutrifft, finden Sie unter [TemplatedParent](#templatedparent) weiter unten in diesem Thema. Innerhalb der Vorlage gilt die folgende Rangfolge:  
  
    1. Trigger aus <xref:System.Windows.FrameworkElement.TemplatedParent%2A> der Vorlage.  
  
    2. Eigenschaftssätze (in der Regel über [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] Attribute) in der <xref:System.Windows.FrameworkElement.TemplatedParent%2A> Vorlage.  
  
5. **Impliziter Stil.** Gilt nur für die `Style`-Eigenschaft. Die `Style`-Eigenschaft wird durch eine Stilressource mit einem Schlüssel gefüllt, der mit dem Typ dieses Elements übereinstimmt. Diese Stilressource muss entweder auf der Seite oder in der Anwendung vorhanden sein. Die Suche nach einer impliziten Stilressource wird nicht in den Designs fortgesetzt.  
  
6. **Stiltrigger.** Die Trigger innerhalb von Stilen einer Seite oder Anwendung (bei diesen Stilen kann es sich entweder um explizite oder um implizite Stile, jedoch nicht um Standardstile handeln, die in der Rangfolge weiter unten stehen).  
  
7. **Vorlagentrigger.** Ein Trigger aus einer Vorlage innerhalb eines Stils oder eine direkt angewendete Vorlage.  
  
8. **Stil-Setter.** Werte aus <xref:System.Windows.Setter> einem innerhalb von Formatvorlagen aus Seite oder Anwendung.  
  
9. **Standard(design)stil.** Ausführliche Informationen dazu, wann dies zutrifft und wie sich Designstile auf die Vorlagen innerhalb von Designstilen beziehen, finden Sie unter [Standard(design)stile](#themestyles) weiter unten in diesem Thema. Innerhalb eines Standardstils gilt die folgende Rangfolge:  
  
    1. Aktive Trigger im Designstil  
  
    2. Setter im Designstil  
  
10. **Vererbung.** Einige Abhängigkeitseigenschaften vererben ihre Werte von übergeordneten Elementen an untergeordnete Elemente, sodass sie nicht speziell für jedes Element in einer Anwendung festgelegt werden müssen. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](property-value-inheritance.md).  
  
11. **Standardwert von den Metadaten der Abhängigkeitseigenschaft.** Jede Abhängigkeitseigenschaft kann einen Standardwert haben, wie bei der Registrierung der bestimmten Eigenschaft durch das Eigenschaftensystem festgelegt. Außerdem verfügen abgeleitete Klassen, die eine Abhängigkeitseigenschaft erben, über die Option zum Überschreiben dieser Metadaten (einschließlich des Standardwerts) auf einer Pro-Typ-Basis. Weitere Informationen finden Sie unter [Metadaten für Abhängigkeitseigenschaften](dependency-property-metadata.md). Da die Vererbung vor dem Standardwert überprüft wird, hat bei einer vererbten Eigenschaft der Standardwert eines übergeordneten Elements Vorrang vor einem untergeordneten Element.  Daher wird, wenn eine vererbbare Eigenschaft nicht irgendwo festgelegt ist, der Standardwert verwendet, der im Stamm oder übergeordneten Element festgelegt wurde, anstatt des Standardwerts des untergeordneten Elements.  
  
<a name="templatedparent"></a>
## <a name="templatedparent"></a>TemplatedParent  
 TemplatedParent als Rangfolgenelement gilt für keine Eigenschaft eines Elements, das Sie direkt in Standardanwendungsmarkup deklarieren. Das TemplatedParent-Konzept besteht nur für untergeordnete Elemente in einer visuellen Struktur, die durch die Anwendung der Vorlage erstellt werden. Wenn das Eigenschaftensystem <xref:System.Windows.FrameworkElement.TemplatedParent%2A> die Vorlage nach einem Wert durchsucht, durchsucht es die Vorlage, die dieses Element erstellt hat. Die Eigenschaftswerte <xref:System.Windows.FrameworkElement.TemplatedParent%2A> aus der Vorlage verhalten sich im Allgemeinen so, als wären sie als lokaler Wert für das untergeordnete Element festgelegt, aber diese geringere Priorität im Vergleich zum lokalen Wert ist vorhanden, da die Vorlagen potenziell gemeinsam genutzt werden. Einzelheiten dazu finden Sie unter <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
<a name="style_property"></a>
## <a name="the-style-property"></a>Die Style-Eigenschaft  
 Die zuvor beschriebene Reihenfolge der Suche gilt für <xref:System.Windows.FrameworkElement.Style%2A> alle möglichen Abhängigkeitseigenschaften mit Ausnahme einer: der Eigenschaft. Die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft ist insofern eindeutig, als sie selbst nicht formatiert werden kann, sodass die Prioritätselemente 5 bis 8 nicht gelten. Außerdem wird weder animieren noch <xref:System.Windows.FrameworkElement.Style%2A> coercing empfohlen (und animieren <xref:System.Windows.FrameworkElement.Style%2A> würde eine benutzerdefinierte Animationsklasse erfordern). Dadurch bleiben drei <xref:System.Windows.FrameworkElement.Style%2A> Möglichkeiten, wie die Eigenschaft festgelegt werden kann:  
  
- **Expliziter Stil.** Die <xref:System.Windows.FrameworkElement.Style%2A> Unterkunft befindet sich direkt. In den meisten Szenarios wird der Stil nicht inline definiert, aber stattdessen durch einen expliziten Schlüssel als eine Ressource verwiesen. In diesem Fall verhält sich die Style-Eigenschaft selbst so, als handele es sich um einen lokalen Wert, das Rangfolgenelement 3.  
  
- **Impliziter Stil.** Die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft wird nicht direkt festgelegt. Der <xref:System.Windows.FrameworkElement.Style%2A> ist jedoch auf einer gewissen Ebene in der Ressourcensuchsequenz (Seite, Anwendung) vorhanden und wird mit einem Ressourcenschlüssel verschlüsselt, der dem Typ entspricht, auf den der Stil angewendet werden soll. In diesem Fall <xref:System.Windows.FrameworkElement.Style%2A> handelt die Eigenschaft selbst durch eine Priorität, die in der Sequenz als Punkt 5 identifiziert wird. Diese Bedingung kann erkannt <xref:System.Windows.DependencyPropertyHelper> werden, indem sie gegen die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft verwendet und in den Ergebnissen gesucht wird. <xref:System.Windows.BaseValueSource.ImplicitStyleReference>  
  
- **Standardstil**, auch bekannt als **Designstil.** Die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft wird nicht direkt festgelegt und `null` liest sich bis zur Laufzeit. In diesem Fall stammt der Stil von der Auswertung des Laufzeitdesigns, die Teil der [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Präsentations-Engine ist.  
  
 Bei impliziten Stilen, die nicht in `MyButton` `Button`Designs verwendet werden, muss der `Button`Typ genau übereinstimmen - eine -abgeleitete Klasse verwendet nicht implizit einen Stil für .  
  
<a name="themestyles"></a>
## <a name="default-theme-styles"></a>Standard(design)stile  
 Jedes Steuerelement, das [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] umfasst, verfügt über einen Standardstil. Der Standardstil variiert möglicherweise nach Design, weshalb dieser Standardstil manchmal auch als Designstil bezeichnet wird.  
  
 Die wichtigste Information, die innerhalb eines Standardstils für ein Steuerelement gefunden wird, ist die <xref:System.Windows.Controls.Control.Template%2A> Steuerelementvorlage, die im Designstil als Setter für seine Eigenschaft vorhanden ist. Wenn keine Vorlage von Standardstilen vorhanden wäre, hätte ein Steuerelement ohne eine benutzerdefinierte Vorlage als Teil eines benutzerdefinierten Stils überhaupt keine visuelle Darstellung. Die Vorlage des Standardstils gibt der visuellen Darstellung jedes Steuerelements eine grundlegende Struktur und definiert zudem die Verbindungen zwischen Eigenschaften, die in der visuellen Struktur der Vorlage und der entsprechenden Steuerelementklasse definiert werden. Jedes Steuerelement macht einen Satz von Eigenschaften verfügbar, die die visuelle Darstellung des Steuerelements beeinflussen können, ohne die Vorlage komplett zu ersetzen. Betrachten Sie z. B. <xref:System.Windows.Controls.Primitives.Thumb> die standardmäßige visuelle Darstellung <xref:System.Windows.Controls.Primitives.ScrollBar>eines Steuerelements, das eine Komponente einer ist.  
  
 A <xref:System.Windows.Controls.Primitives.Thumb> verfügt über bestimmte anpassbare Eigenschaften. Die Standardvorlage <xref:System.Windows.Controls.Primitives.Thumb> einer erstellt eine grundlegende Struktur / <xref:System.Windows.Controls.Border> visuelle Struktur mit mehreren verschachtelten Komponenten, um eine Abschrägungsansicht zu erstellen. Wenn eine Eigenschaft, die Teil der Vorlage ist, <xref:System.Windows.Controls.Primitives.Thumb> für die Anpassung durch die Klasse verfügbar gemacht werden soll, muss diese Eigenschaft von einer [TemplateBinding](templatebinding-markup-extension.md)innerhalb der Vorlage verfügbar gemacht werden. Im Fall <xref:System.Windows.Controls.Primitives.Thumb>von verwenden verschiedene Eigenschaften dieser Rahmen eine <xref:System.Windows.Controls.Border.Background%2A> Vorlage, die an Eigenschaften wie oder <xref:System.Windows.Controls.Border.BorderThickness%2A>gebunden ist. Bestimmte andere Eigenschaften oder visuelle Anordnungen sind in der Steuerelementvorlage hartcodiert oder an Werte gebunden, die direkt aus diesem Design stammen. Diese können nicht ersetzt werden, ohne die gesamte Vorlage zu ersetzen. Im Allgemeinen gilt, dass eine Eigenschaft, die von einem vorlagenbasierten übergeordneten Element stammt und nicht von einer Vorlagenbindung verfügbar gemacht wird, nicht durch Stile angepasst werden kann, da nicht auf einfache Weise auf sie abgezielt werden kann. Diese Eigenschaft kann jedoch trotzdem durch die Eigenschaftswertvererbung in der angewandten Vorlage oder durch den Standardwert beeinflusst werden.  
  
 Die Designstile verwenden einen Typ als Schlüssel in ihren Definitionen. Wenn Designs jedoch auf eine bestimmte Elementinstanz angewendet werden, wird die <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> Themes-Suche nach diesem Typ ausgeführt, indem die Eigenschaft auf ein Steuerelement überprüft wird. Dies steht im Gegensatz zur Verwendung des Literaltyps, wie es bei impliziten Stilen der Fall ist. Der Wert <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> von würde abgeleitete Klassen erben, auch wenn der Implementierer sie nicht ändert (die beabsichtigte Möglichkeit, die Eigenschaft zu ändern, besteht nicht darin, sie auf Eigenschaftsebene zu überschreiben, sondern den Standardwert in Eigenschaftenmetadaten zu ändern). Diese Dereferenzierung ermöglicht Basisklassen, die Designstile für abgeleitete Elemente zu definieren, die andernfalls über keinen Stil verfügen (oder noch wichtiger: die über keine Vorlage innerhalb dieses Stils verfügen und somit überhaupt keine visuelle Standarddarstellung haben würden). So können Sie `MyButton` von <xref:System.Windows.Controls.Button> und werden <xref:System.Windows.Controls.Button> immer noch die Standardvorlage ableiten. Wenn Sie der `MyButton` Steuerelementautor von waren und ein anderes Verhalten wollten, <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> `MyButton` können Sie die Metadaten der Abhängigkeitseigenschaft überschreiben, `MyButton` damit ein anderer `MyButton` Schlüssel zurückgegeben wird, und dann die entsprechenden Designstile einschließlich der Vorlage definieren, für die Sie mit dem Steuerelement verpacken müssen. Weitere Informationen über Designs, Stile und das Erstellen von Steuerelementen finden Sie unter [Übersicht über das Erstellen von Steuerelementen](../controls/control-authoring-overview.md).  
  
<a name="resources"></a>
## <a name="dynamic-resource-references-and-binding"></a>Dynamische Ressourcenverweise und Binden  
 Dynamische Ressourcenverweise und Bindungsvorgänge berücksichtigen die Rangfolge des Speicherorts, an dem sie festgelegt werden. Beispielsweise fungiert eine dynamische Ressource, die auf einen lokalen Wert angewendet wird, als Rangfolgenelement 3, eine Bindung für einen Eigenschaften-Setter innerhalb eines Designstils gilt als Rangfolgenelement 9 usw. Da sowohl dynamische Ressourcenreferenzen als auch das Binden Werte aus dem Laufzeitzustand der Anwendung abrufen können muss, hat dies zur Folge, dass der eigentliche Prozess der Bestimmung der Eigenschaftswert-Rangfolge für eine bestimmte Eigenschaft ebenfalls auf die Laufzeit ausgeweitet wird.  
  
 Dynamische Ressourcenverweise sind streng genommen nicht Teil des Eigenschaftensystems, sie verfügen jedoch über eine eigene Suchreihenfolge, die mit der oben aufgeführten Sequenz interagiert. Diese Rangfolge ist in den [XAML-Ressourcen](../../../desktop-wpf/fundamentals/xaml-resources-define.md) genauer dokumentiert. Die grundlegende Zusammenfassung dieser Rangfolge ist: Element zu Seitenstamm, Anwendung, Design, System.  
  
 Dynamische Ressourcen und Bindungen verwenden die Rangfolge von wo sie festgelegt wurden, der Wert ist jedoch zurückgestellt. Eine Folge dessen ist, dass wenn Sie eine dynamische Ressource oder Bindung für einen lokalen Wert festlegen, jede Änderung am lokalen Wert die dynamische Ressource oder Bindung vollständig ersetzt. Selbst wenn Sie <xref:System.Windows.DependencyObject.ClearValue%2A> die Methode aufrufen, um den lokal festgelegten Wert zu löschen, wird die dynamische Ressource oder Bindung nicht wiederhergestellt. Wenn Sie eine <xref:System.Windows.DependencyObject.ClearValue%2A> Eigenschaft aufrufen, die über eine dynamische Ressource oder Bindung verfügt (ohne <xref:System.Windows.DependencyObject.ClearValue%2A> lokalen Literalwert), werden sie auch durch den Aufruf gelöscht.  
  
<a name="setcurrentvalue"></a>
## <a name="setcurrentvalue"></a>SetCurrentValue  
 Die <xref:System.Windows.DependencyObject.SetCurrentValue%2A> Methode ist eine weitere Möglichkeit, eine Eigenschaft festzulegen, aber sie ist nicht in der Rangfolge. Stattdessen <xref:System.Windows.DependencyObject.SetCurrentValue%2A> können Sie den Wert einer Eigenschaft ändern, ohne die Quelle eines vorherigen Werts zu überschreiben. Sie können <xref:System.Windows.DependencyObject.SetCurrentValue%2A> jederzeit verwenden, wenn Sie einen Wert festlegen möchten, ohne diesem Wert die Priorität eines lokalen Werts zu geben. Wenn z. B. eine Eigenschaft durch einen Trigger <xref:System.Windows.DependencyObject.SetCurrentValue%2A>festgelegt und dann über einen anderen Wert zugewiesen wird, respektiert das Eigenschaftensystem weiterhin den Trigger, und die Eigenschaft ändert sich, wenn die Aktion des Triggers auftritt. <xref:System.Windows.DependencyObject.SetCurrentValue%2A>ermöglicht es Ihnen, den Wert der Eigenschaft zu ändern, ohne ihr eine Quelle mit einer höheren Priorität zu geben. Ebenso können <xref:System.Windows.DependencyObject.SetCurrentValue%2A> Sie den Wert einer Eigenschaft ändern, ohne eine Bindung zu überschreiben.  
  
<a name="animations"></a>
## <a name="coercion-animations-and-base-value"></a>Koersion, Animationen und Basiswert  
 Zwang und Animation wirken beide auf einen Wert, der als "Basiswert" in diesem SDK bezeichnet wird. Der Basiswert ist daher der Wert, der dadurch bestimmt wird, dass in den Elementen von unten nach oben geprüft wird, bis das Element 2 erreicht wird.  
  
 Bei einer Animation kann sich der Basiswert auf den animierten Wert auswirken, wenn diese Animation nicht sowohl „From“ (Von) als auch „To“ (Zu) für bestimmte Verhalten angibt, oder wenn die Animation nach Abschluss bewusst auf den Basiswert zurücksetzt. Um dies in der Praxis nachzuvollziehen, führen Sie das [Beispiel für From-, To- und By-Animationszielwerte](https://github.com/Microsoft/WPF-Samples/tree/master/Animation/TargetValues) aus. Versuchen Sie, die lokalen Werte für die Höhe des Rechtecks im Beispiel so festzulegen, dass sich der ursprüngliche lokale Wert von jedem „From“-Wert in der Animation unterscheidet. Sie werden feststellen, dass die Animationen sofort starten, die „From“-Werte verwenden und den Basiswert ersetzen. Die Animation kann angeben, dass sie zu dem Wert zurückkehrt, <xref:System.Windows.Media.Animation.FillBehavior>der vor der Animation gefunden wurde, nachdem sie abgeschlossen ist, indem sie stop . Anschließend wird die normale Rangfolge für die Bestimmung des Basiswerts verwendet.  
  
 Möglicherweise werden mehrere Animationen auf eine einzelne Eigenschaft angewendet, wobei jede dieser Animationen von verschiedenen Punkten in der Wertrangfolge definiert sein kann. Jedoch setzen diese Animationen möglicherweise ihre Werte zusammen, anstatt nur die Animation der höheren Priorität anzuwenden. Dies hängt davon ab, wie die Animationen genau definiert sind, sowie vom Typ des Werts, der animiert wird. Weitere Informationen über das Animieren von Eigenschaften finden Sie unter [Übersicht über Animationen](../graphics-multimedia/animation-overview.md).  
  
 Die Koersion gilt auf der höchsten Ebene von allen. Selbst eine bereits ausgeführte Animation unterliegt der Koersion des Werts. Bestimmte vorhandene Abhängigkeitseigenschaften in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] verfügen über eine integrierte Koersion. Für eine benutzerdefinierte Abhängigkeitseigenschaft definieren Sie das Zwangsverhalten für <xref:System.Windows.CoerceValueCallback> eine benutzerdefinierte Abhängigkeitseigenschaft, indem Sie beim Erstellen der Eigenschaft eine schreiben und den Rückruf als Teil der Metadaten übergeben. Sie können das Koersionsverhalten vorhandener Eigenschaften auch überschreiben, indem Sie die Metadaten dieser Eigenschaft in einer abgeleiteten Klasse überschreiben. Die Koersion interagiert so mit dem Basiswert, dass die zum diesem Zeitpunkt vorliegenden Einschränkungen der Koersion angewendet werden, der Basiswert jedoch trotzdem erhalten bleibt. Wenn Einschränkungen der Koersion später angehoben werden, gibt die Koersion daher den Wert zurück, der diesem Basiswert am nächsten liegt, und der Einfluss der Koersion auf eine Eigenschaft wird möglicherweise gestoppt, sobald alle Einschränkungen angehoben wurden. Weitere Informationen zum Koersionsverhalten finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](dependency-property-callbacks-and-validation.md).  
  
<a name="triggers"></a>
## <a name="trigger-behaviors"></a>Triggerverhalten  
 Steuerelemente definieren Triggerverhalten häufig als Teil ihres Standardstils in Designs. Durch das Festlegen von lokalen Eigenschaften für Steuerelemente wird möglicherweise verhindert, dass die Trigger entweder über die Darstellung oder das Verhalten auf benutzergesteuerte Ereignisse reagieren können. Die häufigste Verwendung eines Eigenschaftstriggers ist für <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>Steuerelement- oder Zustandseigenschaften wie . Wenn z. B. <xref:System.Windows.Controls.Button> ein deaktiviert <xref:System.Windows.UIElement.IsEnabled%2A> ist `false`(Trigger <xref:System.Windows.Controls.Control.Foreground%2A> für ist ), wird der Wert im Designstil standardmäßig dazu geführt, dass das Steuerelement "ausgegraut" angezeigt wird. Wenn Sie jedoch einen <xref:System.Windows.Controls.Control.Foreground%2A> lokalen Wert festgelegt haben, wird diese normale Grau-Aus-Farbe von Ihrem lokalen Eigenschaftssatz in der Vorrangschaft überstimmt, selbst in diesem von Eigenschaften ausgelösten Szenario. Seien Sie vorsichtig mit dem Festlegen von Werten für Eigenschaften, die über Triggerverhalten auf Designebene verfügen, und stellen Sie sicher, dass Sie nicht in die vorgesehene Benutzerfreundlichkeit dieses Steuerelements eingreifen.  
  
<a name="clearvalue"></a>
## <a name="clearvalue-and-value-precedence"></a>ClearValue und Wertrangfolge  
 Die <xref:System.Windows.DependencyObject.ClearValue%2A> Methode stellt eine zweckdienliche Möglichkeit bereit, jeden lokal angewendeten Wert aus einer Abhängigkeitseigenschaft zu löschen, die für ein Element festgelegt ist. Das Aufrufen <xref:System.Windows.DependencyObject.ClearValue%2A> ist jedoch keine Garantie dafür, dass der Standardwert, wie in Metadaten während der Eigenschaftsregistrierung festgelegt wurde, der neue effektive Wert ist. Alle anderen Teilnehmer der Wertrangfolge sind noch immer aktiv. Nur der lokal festgelegte Wert wurde von der Rangfolgensequenz entfernt. Wenn Sie z. <xref:System.Windows.DependencyObject.ClearValue%2A> B. eine Eigenschaft aufrufen, bei der diese Eigenschaft ebenfalls durch einen Designstil festgelegt wird, wird der Designwert als neuer Wert und nicht als metadatenbasierter Standardwert angewendet. Wenn Sie alle Teilnehmer des Eigenschaftswerts aus dem Prozess herausnehmen und den Wert auf den Standardwert für registrierte Metadaten festlegen möchten, können Sie diesen Standardwert <xref:System.Windows.DependencyObject.SetValue%2A>definitiv abrufen, indem Sie die Metadaten der Abhängigkeitseigenschaft abfragen.  
  
## <a name="see-also"></a>Weitere Informationen

- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md)
- [Benutzerdefinierte Abhängigkeitseigenschaften](custom-dependency-properties.md)
- [Rückrufe und Validierung von Abhängigkeitseigenschaften](dependency-property-callbacks-and-validation.md)
