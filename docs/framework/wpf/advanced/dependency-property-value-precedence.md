---
title: Priorität von Abhängigkeitseigenschaftswerten
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], classes as owners
- dependency properties [WPF], metadata
- classes [WPF], owners of dependency properties
- metadata [WPF], dependency properties
ms.assetid: 1fbada8e-4867-4ed1-8d97-62c07dad7ebc
ms.openlocfilehash: 2abe89abf1ab246464c8f7a7ca7c87295b0b3946
ms.sourcegitcommit: 944ddc52b7f2632f30c668815f92b378efd38eea
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/03/2019
ms.locfileid: "73458975"
---
# <a name="dependency-property-value-precedence"></a>Priorität von Abhängigkeitseigenschaftswerten
<a name="introduction"></a> In diesem Thema wird erläutert, wie die Funktionsweise des [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-Eigenschaftensystems den Wert einer Abhängigkeitseigenschaft beeinflussen kann. Außerdem wird die Rangfolge beschrieben, nach der Aspekte des Eigenschaftensystems auf den effektiven Wert einer Eigenschaft angewendet werden.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Erforderliche Voraussetzungen  
 In diesem Thema wird davon ausgegangen, dass Sie Abhängigkeitseigenschaften aus Sicht eines Consumers vorhandener Abhängigkeitseigenschaften von [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Klassen verstehen und die [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md) gelesen haben. Um den Beispielen in diesem Thema zu folgen, sollten Sie zudem [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] verstehen und wissen, wie [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Anwendungen geschrieben werden.  
  
<a name="intro"></a>   
## <a name="the-wpf-property-system"></a>Das WPF-Eigenschaftensystem  
 Das [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Eigenschaftensystem bietet eine leistungsstarke Möglichkeit, den Wert von Abhängigkeitseigenschaften durch eine Vielzahl von Faktoren zu bestimmen, wobei Funktionen wie die Validierung von Eigenschaften in Echtzeit, die späte Bindung und das Benachrichtigen von verknüpften Eigenschaften über Änderungen an Werten für andere Eigenschaften aktiviert werden. Die genaue Reihenfolge und Logik, die zur Bestimmung der Werte von Abhängigkeitseigenschaften verwendet werden, ist relativ komplex. Indem Sie diese Reihenfolge kennen, können Sie unnötige Eigenschafteneinstellungen vermeiden und klären, wieso genau ein Versuch zur Beeinflussung oder zum Vorhersehen eines Werts einer Abhängigkeitseigenschaft nicht zum erwarteten Wert geführt hat.  
  
<a name="multiple_sets"></a>   
## <a name="dependency-properties-might-be-set-in-multiple-places"></a>Abhängigkeitseigenschaften können an mehreren Orten festgelegt („Set“) werden  
 Im folgenden finden Sie ein Beispiel [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], in dem die gleiche Eigenschaft (<xref:System.Windows.Controls.Control.Background%2A>) drei verschiedene "Set"-Vorgänge aufweist, die den Wert beeinflussen können.  
  
 [!code-xaml[PropertiesOvwSupport#DPPrecedence](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#dpprecedence)]  
  
 Was erwarten Sie, welche Farbe hier angewendet wird – rot, grün oder blau?  
  
 Mit Ausnahme von animierten Werten und Koersion werden lokale Eigenschaftensätze mit der höchsten Priorität festgelegt. Wenn Sie einen Wert lokal festlegen, können Sie erwarten, dass der Wert selbst vor Stilen oder Steuerelementvorlagen berücksichtigt wird. In diesem Beispiel ist <xref:System.Windows.Controls.Control.Background%2A> lokal auf Rot festgelegt. Daher ist der in diesem Bereich definierte Stil, auch wenn es sich um einen impliziten Stil handelt, der andernfalls für alle Elemente dieses Typs in diesem Bereich gilt, nicht die höchste Rangfolge, um dem <xref:System.Windows.Controls.Control.Background%2A> Eigenschaft den Wert zu geben.  Wenn Sie den lokalen Wert „Red“ von dieser Schaltflächeninstanz entfernt hätten, hätte der Stil Vorrang, und die Schaltfläche würde den „Background“-Wert vom Stil erhalten.  Innerhalb des Stils haben Trigger Vorrang, sodass die Schaltfläche blau sein wird, wenn die Maus darauf zeigt, und andernfalls grün.  
  
<a name="listing"></a>   
## <a name="dependency-property-setting-precedence-list"></a>Rangfolgeliste bei der Einstellung von Abhängigkeitseigenschaften  
 Im Folgenden finden Sie die definitive Reihenfolge, die vom Eigenschaftensystem beim Zuweisen der Laufzeitwerte von Abhängigkeitseigenschaften verwendet wird. Die oberste Priorität ist zuerst aufgeführt. Diese Liste erweitert einige der Verallgemeinerungen aus der [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md).  
  
1. **Eigenschaftensystemkoersion.** Weitere Informationen zur Koersion finden Sie unter [Koersion, Animationen und Basiswert](#animations) weiter unten in diesem Thema.  
  
2. **Aktive Animationen oder Animationen mit einem Halteverhalten.** Damit eine Animation einer Eigenschaft eine praktische Auswirkung hat, muss sie Vorrang vor dem (nicht animierten) Basiswert haben können, selbst wenn dieser Wert lokal festgelegt wurde. Weitere Informationen finden Sie unter [Koersion, Animationen und Basiswert](#animations) weiter unten in diesem Thema.  
  
3. **Lokaler Wert.** Ein lokaler Wert kann durch die Verwendung der Eigenschaft "Wrapper" festgelegt werden, die auch dem Festlegen von als Attribut-oder Eigenschafts Element in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]entspricht, oder durch einen aufzurufenden <xref:System.Windows.DependencyObject.SetValue%2A> API mithilfe einer Eigenschaft einer bestimmten Instanz. Wenn Sie einen lokalen Wert mithilfe einer Bindung oder eine Ressource festlegen, haben diese jeweils Vorrang, als ob ein direkter Wert festgelegt wurde.  
  
4. **TemplatedParent-Vorlageneigenschaften.** Ein Element verfügt über eine <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, wenn es als Teil einer Vorlage (<xref:System.Windows.Controls.ControlTemplate> oder <xref:System.Windows.DataTemplate>) erstellt wurde. Weitere Informationen dazu, wann dies zutrifft, finden Sie unter [TemplatedParent](#templatedparent) weiter unten in diesem Thema. Innerhalb der Vorlage gilt die folgende Rangfolge:  
  
    1. Trigger aus der <xref:System.Windows.FrameworkElement.TemplatedParent%2A> Vorlage.  
  
    2. Eigenschaften Sätze (in der Regel über [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] Attribute) in der <xref:System.Windows.FrameworkElement.TemplatedParent%2A> Vorlage.  
  
5. **Impliziter Stil.** Gilt nur für die `Style`-Eigenschaft. Die `Style`-Eigenschaft wird durch eine Stilressource mit einem Schlüssel gefüllt, der mit dem Typ dieses Elements übereinstimmt. Diese Stilressource muss entweder auf der Seite oder in der Anwendung vorhanden sein. Die Suche nach einer impliziten Stilressource wird nicht in den Designs fortgesetzt.  
  
6. **Stiltrigger.** Die Trigger innerhalb von Stilen einer Seite oder Anwendung (bei diesen Stilen kann es sich entweder um explizite oder um implizite Stile, jedoch nicht um Standardstile handeln, die in der Rangfolge weiter unten stehen).  
  
7. **Vorlagentrigger.** Ein Trigger aus einer Vorlage innerhalb eines Stils oder eine direkt angewendete Vorlage.  
  
8. **Stil-Setter.** Werte aus einer <xref:System.Windows.Setter> in Stilen von Seite oder Anwendung.  
  
9. **Standard(design)stil.** Ausführliche Informationen dazu, wann dies zutrifft und wie sich Designstile auf die Vorlagen innerhalb von Designstilen beziehen, finden Sie unter [Standard(design)stile](#themestyles) weiter unten in diesem Thema. Innerhalb eines Standardstils gilt die folgende Rangfolge:  
  
    1. Aktive Trigger im Designstil  
  
    2. Setter im Designstil  
  
10. **Vererbung.** Einige Abhängigkeitseigenschaften vererben ihre Werte von übergeordneten Elementen an untergeordnete Elemente, sodass sie nicht speziell für jedes Element in einer Anwendung festgelegt werden müssen. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](property-value-inheritance.md).  
  
11. **Standardwert von den Metadaten der Abhängigkeitseigenschaft.** Jede Abhängigkeitseigenschaft kann einen Standardwert haben, wie bei der Registrierung der bestimmten Eigenschaft durch das Eigenschaftensystem festgelegt. Außerdem verfügen abgeleitete Klassen, die eine Abhängigkeitseigenschaft erben, über die Option zum Überschreiben dieser Metadaten (einschließlich des Standardwerts) auf einer Pro-Typ-Basis. Weitere Informationen finden Sie unter [Metadaten für Abhängigkeitseigenschaften](dependency-property-metadata.md). Da die Vererbung vor dem Standardwert überprüft wird, hat bei einer vererbten Eigenschaft der Standardwert eines übergeordneten Elements Vorrang vor einem untergeordneten Element.  Daher wird, wenn eine vererbbare Eigenschaft nicht irgendwo festgelegt ist, der Standardwert verwendet, der im Stamm oder übergeordneten Element festgelegt wurde, anstatt des Standardwerts des untergeordneten Elements.  
  
<a name="templatedparent"></a>   
## <a name="templatedparent"></a>TemplatedParent  
 TemplatedParent als Rangfolgenelement gilt für keine Eigenschaft eines Elements, das Sie direkt in Standardanwendungsmarkup deklarieren. Das TemplatedParent-Konzept besteht nur für untergeordnete Elemente in einer visuellen Struktur, die durch die Anwendung der Vorlage erstellt werden. Wenn das Eigenschaften System die <xref:System.Windows.FrameworkElement.TemplatedParent%2A> Vorlage nach einem Wert durchsucht, durchsucht Sie die Vorlage, die das Element erstellt hat. Die Eigenschaftswerte aus der <xref:System.Windows.FrameworkElement.TemplatedParent%2A> Vorlage agieren in der Regel so, als ob Sie als lokaler Wert für das untergeordnete Element festgelegt wurden, aber diese geringere Rangfolge im Vergleich zum lokalen Wert liegt vor, weil die Vorlagen potenziell freigegeben werden. Ausführliche Informationen finden Sie unter <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
<a name="style_property"></a>   
## <a name="the-style-property"></a>Die Style-Eigenschaft  
 Die zuvor beschriebene Reihenfolge der Suche gilt für alle möglichen Abhängigkeits Eigenschaften, ausgenommen: die <xref:System.Windows.FrameworkElement.Style%2A>-Eigenschaft. Die <xref:System.Windows.FrameworkElement.Style%2A>-Eigenschaft ist insofern eindeutig, als Sie nicht selbst formatiert werden kann, sodass die Rang Folge Elemente 5 bis 8 nicht zutreffen. Außerdem wird das animieren oder umwandeln <xref:System.Windows.FrameworkElement.Style%2A> nicht empfohlen (und das Animieren <xref:System.Windows.FrameworkElement.Style%2A> eine benutzerdefinierte Animations Klasse erfordern). Dadurch bleiben drei Möglichkeiten bestehen, dass die <xref:System.Windows.FrameworkElement.Style%2A>-Eigenschaft festgelegt werden kann:  
  
- **Expliziter Stil.** Die <xref:System.Windows.FrameworkElement.Style%2A>-Eigenschaft wird direkt festgelegt. In den meisten Szenarios wird der Stil nicht inline definiert, aber stattdessen durch einen expliziten Schlüssel als eine Ressource verwiesen. In diesem Fall verhält sich die Style-Eigenschaft selbst so, als handele es sich um einen lokalen Wert, das Rangfolgenelement 3.  
  
- **Impliziter Stil.** Die <xref:System.Windows.FrameworkElement.Style%2A>-Eigenschaft ist nicht direkt festgelegt. Allerdings ist die <xref:System.Windows.FrameworkElement.Style%2A> auf einer bestimmten Ebene in der Sequenz der Ressourcen Suche (Seite, Anwendung) vorhanden und wird mit einem Ressourcen Schlüssel verschlüsselt, der dem Typ entspricht, auf den der Stil angewendet werden soll. In diesem Fall verhält sich die <xref:System.Windows.FrameworkElement.Style%2A>-Eigenschaft selbst durch eine Rangfolge, die in der Sequenz als Element 5 identifiziert wird. Diese Bedingung kann erkannt werden, indem Sie <xref:System.Windows.DependencyPropertyHelper> für die <xref:System.Windows.FrameworkElement.Style%2A>-Eigenschaft verwenden und in den Ergebnissen nach <xref:System.Windows.BaseValueSource.ImplicitStyleReference> suchen.  
  
- **Standardstil**, auch bekannt als **Designstil.** Die <xref:System.Windows.FrameworkElement.Style%2A>-Eigenschaft wird nicht direkt festgelegt und in der Tat als `null` bis zur Laufzeit gelesen. In diesem Fall stammt der Stil von der Auswertung des Laufzeitdesigns, die Teil der [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Präsentations-Engine ist.  
  
 Bei impliziten Stilen, die nicht in Designs gefunden werden, muss der Typ exakt übereinstimmen. ein `MyButton` `Button`abgeleitete Klasse verwendet nicht implizit einen Stil für `Button`.  
  
<a name="themestyles"></a>   
## <a name="default-theme-styles"></a>Standard(design)stile  
 Jedes Steuerelement, das [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] umfasst, verfügt über einen Standardstil. Der Standardstil variiert möglicherweise nach Design, weshalb dieser Standardstil manchmal auch als Designstil bezeichnet wird.  
  
 Die wichtigsten Informationen, die in einem Standardstil für ein Steuerelement zu finden sind, sind die Steuerelement Vorlage, die im Design Stil als Setter für Ihre <xref:System.Windows.Controls.Control.Template%2A>-Eigenschaft vorhanden ist. Wenn keine Vorlage von Standardstilen vorhanden wäre, hätte ein Steuerelement ohne eine benutzerdefinierte Vorlage als Teil eines benutzerdefinierten Stils überhaupt keine visuelle Darstellung. Die Vorlage des Standardstils gibt der visuellen Darstellung jedes Steuerelements eine grundlegende Struktur und definiert zudem die Verbindungen zwischen Eigenschaften, die in der visuellen Struktur der Vorlage und der entsprechenden Steuerelementklasse definiert werden. Jedes Steuerelement macht einen Satz von Eigenschaften verfügbar, die die visuelle Darstellung des Steuerelements beeinflussen können, ohne die Vorlage komplett zu ersetzen. Nehmen Sie beispielsweise die Standarddarstellung eines <xref:System.Windows.Controls.Primitives.Thumb>-Steuer Elements, bei dem es sich um eine Komponente einer <xref:System.Windows.Controls.Primitives.ScrollBar>handelt.  
  
 Eine <xref:System.Windows.Controls.Primitives.Thumb> verfügt über bestimmte anpassbare Eigenschaften. Die Standardvorlage eines <xref:System.Windows.Controls.Primitives.Thumb> erstellt eine grundlegende Struktur bzw. visuelle Struktur mit mehreren <xref:System.Windows.Controls.Border> Komponenten, die zum Erstellen eines Bild ausschrägungs Elements erforderlich sind. Wenn eine Eigenschaft, die Teil der Vorlage ist, für die Anpassung durch die <xref:System.Windows.Controls.Primitives.Thumb>-Klasse verfügbar gemacht werden soll, muss diese Eigenschaft von einer [TemplateBinding](templatebinding-markup-extension.md)innerhalb der Vorlage verfügbar gemacht werden. Im Fall von <xref:System.Windows.Controls.Primitives.Thumb>Teilen verschiedene Eigenschaften dieser Rahmen eine Vorlagen Bindung an Eigenschaften wie <xref:System.Windows.Controls.Border.Background%2A> oder <xref:System.Windows.Controls.Border.BorderThickness%2A>. Bestimmte andere Eigenschaften oder visuelle Anordnungen sind in der Steuerelementvorlage hartcodiert oder an Werte gebunden, die direkt aus diesem Design stammen. Diese können nicht ersetzt werden, ohne die gesamte Vorlage zu ersetzen. Im Allgemeinen gilt, dass eine Eigenschaft, die von einem vorlagenbasierten übergeordneten Element stammt und nicht von einer Vorlagenbindung verfügbar gemacht wird, nicht durch Stile angepasst werden kann, da nicht auf einfache Weise auf sie abgezielt werden kann. Diese Eigenschaft kann jedoch trotzdem durch die Eigenschaftswertvererbung in der angewandten Vorlage oder durch den Standardwert beeinflusst werden.  
  
 Die Designstile verwenden einen Typ als Schlüssel in ihren Definitionen. Wenn Designs jedoch auf eine bestimmte Element Instanz angewendet werden, wird die Suche nach Designs für diesen Typ durch Überprüfen der <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>-Eigenschaft eines Steuer Elements durchgeführt. Dies steht im Gegensatz zur Verwendung des Literaltyps, wie es bei impliziten Stilen der Fall ist. Der Wert von <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> würde auch dann zu abgeleiteten Klassen erben, wenn der Implementierer die Eigenschaft nicht geändert hat (die beabsichtigte Methode zum Ändern der Eigenschaft ist nicht, Sie auf Eigenschaften Ebene zu überschreiben, sondern stattdessen den Standardwert in den Eigenschafts Metadaten zu ändern). Diese Dereferenzierung ermöglicht Basisklassen, die Designstile für abgeleitete Elemente zu definieren, die andernfalls über keinen Stil verfügen (oder noch wichtiger: die über keine Vorlage innerhalb dieses Stils verfügen und somit überhaupt keine visuelle Standarddarstellung haben würden). Daher können Sie `MyButton` aus <xref:System.Windows.Controls.Button> ableiten und erhalten weiterhin die <xref:System.Windows.Controls.Button> Standardvorlage. Wenn Sie der Autor des Steuer Elements `MyButton` sind und ein anderes Verhalten erwartet haben, können Sie die Metadaten der Abhängigkeits Eigenschaft für <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> auf `MyButton` überschreiben, um einen anderen Schlüssel zurückzugeben, und dann die relevanten Designstile definieren, einschließlich der Vorlage für `MyButton`, die Sie müssen das Paket mit dem `MyButton`-Steuerelement verpacken. Weitere Informationen über Designs, Stile und das Erstellen von Steuerelementen finden Sie unter [Übersicht über das Erstellen von Steuerelementen](../controls/control-authoring-overview.md).  
  
<a name="resources"></a>   
## <a name="dynamic-resource-references-and-binding"></a>Dynamische Ressourcenverweise und Binden  
 Dynamische Ressourcenverweise und Bindungsvorgänge berücksichtigen die Rangfolge des Speicherorts, an dem sie festgelegt werden. Beispielsweise fungiert eine dynamische Ressource, die auf einen lokalen Wert angewendet wird, als Rangfolgenelement 3, eine Bindung für einen Eigenschaften-Setter innerhalb eines Designstils gilt als Rangfolgenelement 9 usw. Da sowohl dynamische Ressourcenreferenzen als auch das Binden Werte aus dem Laufzeitzustand der Anwendung abrufen können muss, hat dies zur Folge, dass der eigentliche Prozess der Bestimmung der Eigenschaftswert-Rangfolge für eine bestimmte Eigenschaft ebenfalls auf die Laufzeit ausgeweitet wird.  
  
 Dynamische Ressourcenverweise sind streng genommen nicht Teil des Eigenschaftensystems, sie verfügen jedoch über eine eigene Suchreihenfolge, die mit der oben aufgeführten Sequenz interagiert. Diese Rangfolge ist in den [XAML-Ressourcen](../../../desktop-wpf/fundamentals/xaml-resources-define.md) genauer dokumentiert. Die grundlegende Zusammenfassung dieser Rangfolge ist: Element zu Seitenstamm, Anwendung, Design, System.  
  
 Dynamische Ressourcen und Bindungen verwenden die Rangfolge von wo sie festgelegt wurden, der Wert ist jedoch zurückgestellt. Eine Folge dessen ist, dass wenn Sie eine dynamische Ressource oder Bindung für einen lokalen Wert festlegen, jede Änderung am lokalen Wert die dynamische Ressource oder Bindung vollständig ersetzt. Auch wenn Sie die <xref:System.Windows.DependencyObject.ClearValue%2A>-Methode zum Löschen des lokal festgelegten Werts aufzurufen, wird die dynamische Ressource oder Bindung nicht wieder hergestellt. Wenn Sie <xref:System.Windows.DependencyObject.ClearValue%2A> für eine Eigenschaft, die eine dynamische Ressource oder eine dynamische Bindung aufweist (ohne literalen lokalen Wert), werden Sie tatsächlich durch den <xref:System.Windows.DependencyObject.ClearValue%2A>-Rückruf gelöscht.  
  
<a name="setcurrentvalue"></a>   
## <a name="setcurrentvalue"></a>SetCurrentValue  
 Die <xref:System.Windows.DependencyObject.SetCurrentValue%2A>-Methode ist eine andere Möglichkeit, eine Eigenschaft festzulegen, Sie liegt jedoch nicht in der Rangfolge. Stattdessen können Sie mit <xref:System.Windows.DependencyObject.SetCurrentValue%2A> den Wert einer Eigenschaft ändern, ohne die Quelle eines vorherigen Werts zu überschreiben. Sie können <xref:System.Windows.DependencyObject.SetCurrentValue%2A> jederzeit verwenden, wenn Sie einen Wert festlegen möchten, ohne diesen Wert der Rangfolge eines lokalen Werts zu geben. Wenn z. b. eine Eigenschaft durch einen-Triggerwert festgelegt und dann über <xref:System.Windows.DependencyObject.SetCurrentValue%2A>einen anderen Wert zugewiesen wird, respektiert das Eigenschaften System den-Triggern, und die-Eigenschaft ändert sich, wenn die Aktion des Auslösers auftritt. <xref:System.Windows.DependencyObject.SetCurrentValue%2A> ermöglicht es Ihnen, den Eigenschafts Wert zu ändern, ohne ihm eine Quelle mit höherer Rangfolge zu geben. Ebenso können Sie <xref:System.Windows.DependencyObject.SetCurrentValue%2A> verwenden, um den Wert einer Eigenschaft zu ändern, ohne eine Bindung zu überschreiben.  
  
<a name="animations"></a>   
## <a name="coercion-animations-and-base-value"></a>Koersion, Animationen und Basiswert  
 Sowohl Koersion als auch Animation wirken auf einen Wert, der in diesem [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)] als „Basiswert“ bezeichnet wird. Der Basiswert ist daher der Wert, der dadurch bestimmt wird, dass in den Elementen von unten nach oben geprüft wird, bis das Element 2 erreicht wird.  
  
 Bei einer Animation kann sich der Basiswert auf den animierten Wert auswirken, wenn diese Animation nicht sowohl „From“ (Von) als auch „To“ (Zu) für bestimmte Verhalten angibt, oder wenn die Animation nach Abschluss bewusst auf den Basiswert zurücksetzt. Um dies in der Praxis nachzuvollziehen, führen Sie das [Beispiel für From-, To- und By-Animationszielwerte](https://go.microsoft.com/fwlink/?LinkID=159988) aus. Versuchen Sie, die lokalen Werte für die Höhe des Rechtecks im Beispiel so festzulegen, dass sich der ursprüngliche lokale Wert von jedem „From“-Wert in der Animation unterscheidet. Sie werden feststellen, dass die Animationen sofort starten, die „From“-Werte verwenden und den Basiswert ersetzen. Die Animation gibt ggf. an, dass der Wert vor der Animation wiedergegeben werden soll, nachdem er durch Angabe des <xref:System.Windows.Media.Animation.FillBehavior>beendet wurde. Anschließend wird die normale Rangfolge für die Bestimmung des Basiswerts verwendet.  
  
 Möglicherweise werden mehrere Animationen auf eine einzelne Eigenschaft angewendet, wobei jede dieser Animationen von verschiedenen Punkten in der Wertrangfolge definiert sein kann. Jedoch setzen diese Animationen möglicherweise ihre Werte zusammen, anstatt nur die Animation der höheren Priorität anzuwenden. Dies hängt davon ab, wie die Animationen genau definiert sind, sowie vom Typ des Werts, der animiert wird. Weitere Informationen über das Animieren von Eigenschaften finden Sie unter [Übersicht über Animationen](../graphics-multimedia/animation-overview.md).  
  
 Die Koersion gilt auf der höchsten Ebene von allen. Selbst eine bereits ausgeführte Animation unterliegt der Koersion des Werts. Bestimmte vorhandene Abhängigkeitseigenschaften in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] verfügen über eine integrierte Koersion. Für eine benutzerdefinierte Abhängigkeits Eigenschaft definieren Sie das Umwandlungs Verhalten für eine benutzerdefinierte Abhängigkeits Eigenschaft, indem Sie eine <xref:System.Windows.CoerceValueCallback> schreiben und den Rückruf als Teil der Metadaten übergeben, wenn Sie die-Eigenschaft erstellen. Sie können das Koersionsverhalten vorhandener Eigenschaften auch überschreiben, indem Sie die Metadaten dieser Eigenschaft in einer abgeleiteten Klasse überschreiben. Die Koersion interagiert so mit dem Basiswert, dass die zum diesem Zeitpunkt vorliegenden Einschränkungen der Koersion angewendet werden, der Basiswert jedoch trotzdem erhalten bleibt. Wenn Einschränkungen der Koersion später angehoben werden, gibt die Koersion daher den Wert zurück, der diesem Basiswert am nächsten liegt, und der Einfluss der Koersion auf eine Eigenschaft wird möglicherweise gestoppt, sobald alle Einschränkungen angehoben wurden. Weitere Informationen zum Koersionsverhalten finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](dependency-property-callbacks-and-validation.md).  
  
<a name="triggers"></a>   
## <a name="trigger-behaviors"></a>Triggerverhalten  
 Steuerelemente definieren Triggerverhalten häufig als Teil ihres Standardstils in Designs. Durch das Festlegen von lokalen Eigenschaften für Steuerelemente wird möglicherweise verhindert, dass die Trigger entweder über die Darstellung oder das Verhalten auf benutzergesteuerte Ereignisse reagieren können. Die häufigste Verwendung eines Eigenschafts Auslösers ist für Steuerelement-oder Zustands Eigenschaften wie z. b. <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>. Wenn z. b. ein <xref:System.Windows.Controls.Button> deaktiviert ist (der <xref:System.Windows.UIElement.IsEnabled%2A> ist `false`), dann wird der <xref:System.Windows.Controls.Control.Foreground%2A> Wert im Design Stil bewirkt, dass das Steuerelement als "abgeblendet" angezeigt wird. Wenn Sie jedoch einen lokalen <xref:System.Windows.Controls.Control.Foreground%2A> Wert festgelegt haben, wird die normale graue Farbe durch Ihren lokalen Eigenschaften Satz überschrieben, selbst in diesem durch die Eigenschaft ausgelösten Szenario. Seien Sie vorsichtig mit dem Festlegen von Werten für Eigenschaften, die über Triggerverhalten auf Designebene verfügen, und stellen Sie sicher, dass Sie nicht in die vorgesehene Benutzerfreundlichkeit dieses Steuerelements eingreifen.  
  
<a name="clearvalue"></a>   
## <a name="clearvalue-and-value-precedence"></a>ClearValue und Wertrangfolge  
 Die <xref:System.Windows.DependencyObject.ClearValue%2A>-Methode ermöglicht das Löschen aller lokal angewendeten Werte aus einer Abhängigkeits Eigenschaft, die für ein Element festgelegt ist. Das Aufrufen von <xref:System.Windows.DependencyObject.ClearValue%2A> ist jedoch keine Garantie dafür, dass der Standardwert, der in den Metadaten während der Eigenschaften Registrierung festgelegt wurde, der neue effektive Wert ist. Alle anderen Teilnehmer der Wertrangfolge sind noch immer aktiv. Nur der lokal festgelegte Wert wurde von der Rangfolgensequenz entfernt. Wenn Sie z. b. <xref:System.Windows.DependencyObject.ClearValue%2A> für eine Eigenschaft aufzurufen, bei der diese Eigenschaft ebenfalls durch einen Design Stil festgelegt wird, wird der Design Wert als neuer Wert und nicht als metadatenbasierter Standardwert angewendet. Wenn Sie alle Eigenschafts Wert Teilnehmer aus dem Prozess entfernen und den Wert auf den Standardwert für registrierte Metadaten festlegen möchten, können Sie diesen Standardwert endgültig abrufen, indem Sie die Metadaten der Abhängigkeits Eigenschaft Abfragen und dann den Standardwert lokal verwenden. Legen Sie die-Eigenschaft mit einem aufzurufenden <xref:System.Windows.DependencyObject.SetValue%2A>fest.  
  
## <a name="see-also"></a>Siehe auch

- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md)
- [Benutzerdefinierte Abhängigkeitseigenschaften](custom-dependency-properties.md)
- [Rückrufe und Validierung von Abhängigkeitseigenschaften](dependency-property-callbacks-and-validation.md)
