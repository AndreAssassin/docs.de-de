---
title: Priorität von Abhängigkeitseigenschaftswerten
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], classes as owners
- dependency properties [WPF], metadata
- classes [WPF], owners of dependency properties
- metadata [WPF], dependency properties
ms.assetid: 1fbada8e-4867-4ed1-8d97-62c07dad7ebc
ms.openlocfilehash: 9adcd19ea48d62f4fdcab3380252ae8ec8398296
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 04/23/2019
ms.locfileid: "62010539"
---
# <a name="dependency-property-value-precedence"></a>Priorität von Abhängigkeitseigenschaftswerten
<a name="introduction"></a> In diesem Thema wird erläutert, wie die Funktionsweise des [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-Eigenschaftensystems den Wert einer Abhängigkeitseigenschaft beeinflussen kann. Außerdem wird die Rangfolge beschrieben, nach der Aspekte des Eigenschaftensystems auf den effektiven Wert einer Eigenschaft angewendet werden.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Vorraussetzungen  
 In diesem Thema wird davon ausgegangen, dass Sie Abhängigkeitseigenschaften aus Sicht eines Consumers vorhandener Abhängigkeitseigenschaften von [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Klassen verstehen und die [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md) gelesen haben. Um den Beispielen in diesem Thema zu folgen, sollten Sie zudem [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] verstehen und wissen, wie [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Anwendungen geschrieben werden.  
  
<a name="intro"></a>   
## <a name="the-wpf-property-system"></a>Das WPF-Eigenschaftensystem  
 Das [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Eigenschaftensystem bietet eine leistungsstarke Möglichkeit, den Wert von Abhängigkeitseigenschaften durch eine Vielzahl von Faktoren zu bestimmen, wobei Funktionen wie die Validierung von Eigenschaften in Echtzeit, die späte Bindung und das Benachrichtigen von verknüpften Eigenschaften über Änderungen an Werten für andere Eigenschaften aktiviert werden. Die genaue Reihenfolge und Logik, die zur Bestimmung der Werte von Abhängigkeitseigenschaften verwendet werden, ist relativ komplex. Indem Sie diese Reihenfolge kennen, können Sie unnötige Eigenschafteneinstellungen vermeiden und klären, wieso genau ein Versuch zur Beeinflussung oder zum Vorhersehen eines Werts einer Abhängigkeitseigenschaft nicht zum erwarteten Wert geführt hat.  
  
<a name="multiple_sets"></a>   
## <a name="dependency-properties-might-be-set-in-multiple-places"></a>Abhängigkeitseigenschaften können an mehreren Orten festgelegt („Set“) werden  
 Im folgenden finden Sie Beispiel [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] , in denen die gleiche Eigenschaft (<xref:System.Windows.Controls.Control.Background%2A>) verfügt über drei verschiedene "set" Vorgänge, die den Wert auswirken könnten.  
  
 [!code-xaml[PropertiesOvwSupport#DPPrecedence](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#dpprecedence)]  
  
 Was erwarten Sie, welche Farbe hier angewendet wird – rot, grün oder blau?  
  
 Mit Ausnahme von animierten Werten und Koersion werden lokale Eigenschaftensätze mit der höchsten Priorität festgelegt. Wenn Sie einen Wert lokal festlegen, können Sie erwarten, dass der Wert selbst vor Stilen oder Steuerelementvorlagen berücksichtigt wird. In diesem Beispiel, <xref:System.Windows.Controls.Control.Background%2A> lokal auf Rot festgelegt wird. Daher ist das Format, die in diesem Bereich definiert werden, obwohl es ein impliziter Stil ist, die andernfalls für alle Elemente dieses Typs in diesem Bereich gelten würde nicht die höchste Priorität bei der Vergabe der <xref:System.Windows.Controls.Control.Background%2A> Eigenschaft den Wert.  Wenn Sie den lokalen Wert „Red“ von dieser Schaltflächeninstanz entfernt hätten, hätte der Stil Vorrang, und die Schaltfläche würde den „Background“-Wert vom Stil erhalten.  Innerhalb des Stils haben Trigger Vorrang, sodass die Schaltfläche blau sein wird, wenn die Maus darauf zeigt, und andernfalls grün.  
  
<a name="listing"></a>   
## <a name="dependency-property-setting-precedence-list"></a>Rangfolgeliste bei der Einstellung von Abhängigkeitseigenschaften  
 Im Folgenden finden Sie die definitive Reihenfolge, die vom Eigenschaftensystem beim Zuweisen der Laufzeitwerte von Abhängigkeitseigenschaften verwendet wird. Die oberste Priorität ist zuerst aufgeführt. Diese Liste erweitert einige der Verallgemeinerungen aus der [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md).  
  
1. **Eigenschaftensystemkoersion.** Weitere Informationen zur Koersion finden Sie unter [Koersion, Animationen und Basiswert](#animations) weiter unten in diesem Thema.  
  
2. **Aktive Animationen oder Animationen mit einem Halteverhalten.** Damit eine Animation einer Eigenschaft eine praktische Auswirkung hat, muss sie Vorrang vor dem (nicht animierten) Basiswert haben können, selbst wenn dieser Wert lokal festgelegt wurde. Weitere Informationen finden Sie unter [Koersion, Animationen und Basiswert](#animations) weiter unten in diesem Thema.  
  
3. **Lokaler Wert.** Ein lokaler Wert festgelegt werden kann, über die Vorteile der Eigenschaft "Wrapper", was auch Einstellung als ein Attribut oder Eigenschaftenelement in entspricht [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], oder durch einen Aufruf der <xref:System.Windows.DependencyObject.SetValue%2A> [!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)] mithilfe einer Eigenschaft einer bestimmten Instanz. Wenn Sie einen lokalen Wert mithilfe einer Bindung oder eine Ressource festlegen, haben diese jeweils Vorrang, als ob ein direkter Wert festgelegt wurde.  
  
4. **TemplatedParent-Vorlageneigenschaften.** Ein Element verfügt über eine <xref:System.Windows.FrameworkElement.TemplatedParent%2A> , wenn es als Teil einer Vorlage erstellt wurde (eine <xref:System.Windows.Controls.ControlTemplate> oder <xref:System.Windows.DataTemplate>). Weitere Informationen dazu, wann dies zutrifft, finden Sie unter [TemplatedParent](#templatedparent) weiter unten in diesem Thema. Innerhalb der Vorlage gilt die folgende Rangfolge:  
  
    1. Wird ausgelöst, von der <xref:System.Windows.FrameworkElement.TemplatedParent%2A> Vorlage.  
  
    2. Eigenschaftensätze (normalerweise über [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] Attribute) in der <xref:System.Windows.FrameworkElement.TemplatedParent%2A> Vorlage.  
  
5. **Impliziter Stil.** Gilt nur für die `Style`-Eigenschaft. Die `Style`-Eigenschaft wird durch eine Stilressource mit einem Schlüssel gefüllt, der mit dem Typ dieses Elements übereinstimmt. Diese Stilressource muss entweder auf der Seite oder in der Anwendung vorhanden sein. Die Suche nach einer impliziten Stilressource wird nicht in den Designs fortgesetzt.  
  
6. **Stiltrigger.** Die Trigger innerhalb von Stilen einer Seite oder Anwendung (bei diesen Stilen kann es sich entweder um explizite oder um implizite Stile, jedoch nicht um Standardstile handeln, die in der Rangfolge weiter unten stehen).  
  
7. **Vorlagentrigger.** Ein Trigger aus einer Vorlage innerhalb eines Stils oder eine direkt angewendete Vorlage.  
  
8. **Stil-Setter.** Werte aus einer <xref:System.Windows.Setter> innerhalb von Stilen einer Seite oder Anwendung.  
  
9. **Standard(design)stil.** Ausführliche Informationen dazu, wann dies zutrifft und wie sich Designstile auf die Vorlagen innerhalb von Designstilen beziehen, finden Sie unter [Standard(design)stile](#themestyles) weiter unten in diesem Thema. Innerhalb eines Standardstils gilt die folgende Rangfolge:  
  
    1. Aktive Trigger im Designstil  
  
    2. Setter im Designstil  
  
10. **Vererbung.** Einige Abhängigkeitseigenschaften vererben ihre Werte von übergeordneten Elementen an untergeordnete Elemente, sodass sie nicht speziell für jedes Element in einer Anwendung festgelegt werden müssen. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](property-value-inheritance.md).  
  
11. **Standardwert von den Metadaten der Abhängigkeitseigenschaft.** Jede Abhängigkeitseigenschaft kann einen Standardwert haben, wie bei der Registrierung der bestimmten Eigenschaft durch das Eigenschaftensystem festgelegt. Außerdem verfügen abgeleitete Klassen, die eine Abhängigkeitseigenschaft erben, über die Option zum Überschreiben dieser Metadaten (einschließlich des Standardwerts) auf einer Pro-Typ-Basis. Weitere Informationen finden Sie unter [Metadaten für Abhängigkeitseigenschaften](dependency-property-metadata.md). Da die Vererbung vor dem Standardwert überprüft wird, hat bei einer vererbten Eigenschaft der Standardwert eines übergeordneten Elements Vorrang vor einem untergeordneten Element.  Daher wird, wenn eine vererbbare Eigenschaft nicht irgendwo festgelegt ist, der Standardwert verwendet, der im Stamm oder übergeordneten Element festgelegt wurde, anstatt des Standardwerts des untergeordneten Elements.  
  
<a name="templatedparent"></a>   
## <a name="templatedparent"></a>TemplatedParent  
 TemplatedParent als Rangfolgenelement gilt für keine Eigenschaft eines Elements, das Sie direkt in Standardanwendungsmarkup deklarieren. Das TemplatedParent-Konzept besteht nur für untergeordnete Elemente in einer visuellen Struktur, die durch die Anwendung der Vorlage erstellt werden. Wenn das Eigenschaftensystem sucht die <xref:System.Windows.FrameworkElement.TemplatedParent%2A> -Vorlage für einen Wert, sucht er die Vorlage, die das Element erstellt. Die Eigenschaftswerte aus der <xref:System.Windows.FrameworkElement.TemplatedParent%2A> Vorlage im allgemeinen Verhalten, als wären Sie als einen lokalen Wert auf dem untergeordneten Element festgelegt wurden, aber diese geringere Priorität gegenüber den lokalen Wert vorhanden ist, da die Vorlagen potenziell geteilt werden. Ausführliche Informationen finden Sie unter <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
<a name="style_property"></a>   
## <a name="the-style-property"></a>Die Style-Eigenschaft  
 Die zuvor beschriebene gilt für alle möglichen Abhängigkeitseigenschaften, außer einer: die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft. Die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft ist eindeutig, da es sich selbst gestaltet werden kann, damit die rangfolgenelemente 5 bis 8 nicht relevant sind. Darüber hinaus entweder Animation noch die Koersion <xref:System.Windows.FrameworkElement.Style%2A> wird nicht empfohlen (und Animieren von <xref:System.Windows.FrameworkElement.Style%2A> würde eine benutzerdefinierte Animationsklasse erfordern). Dies bewirkt, dass drei Möglichkeiten, die die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft kann festgelegt werden:  
  
- **Expliziter Stil.** Die <xref:System.Windows.FrameworkElement.Style%2A> -Eigenschaft direkt festgelegt. In den meisten Szenarios wird der Stil nicht inline definiert, aber stattdessen durch einen expliziten Schlüssel als eine Ressource verwiesen. In diesem Fall verhält sich die Style-Eigenschaft selbst so, als handele es sich um einen lokalen Wert, das Rangfolgenelement 3.  
  
- **Impliziter Stil.** Die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft wird nicht direkt festgelegt werden. Allerdings die <xref:System.Windows.FrameworkElement.Style%2A> auf einer bestimmten Ebene in der Ressourcensuchsequenz (Seite, Anwendung) ist vorhanden und wird ein Schlüssel mithilfe von ein Ressourcenschlüssel, der dem Typ übereinstimmt, das Format ist auf angewendet werden. In diesem Fall die <xref:System.Windows.FrameworkElement.Style%2A> -Eigenschaft selbst fungiert, in der Sequenz als Element 5 identifizierte Priorität. Diese Bedingung kann erkannt werden, mithilfe von <xref:System.Windows.DependencyPropertyHelper> für die <xref:System.Windows.FrameworkElement.Style%2A> -Eigenschaft und nach <xref:System.Windows.BaseValueSource.ImplicitStyleReference> in den Ergebnissen.  
  
- **Standardstil**, auch bekannt als **Designstil.** Die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft wird nicht direkt festgelegt, und in der Tat wird als `null` bis zur Laufzeit. In diesem Fall stammt der Stil von der Auswertung des Laufzeitdesigns, die Teil der [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Präsentations-Engine ist.  
  
 Bei impliziten Stilen außerhalb von Designs muss der Typ genau - übereinstimmen eine `MyButton` `Button`-abgeleiteten Klasse verwendet nicht implizit einen Stil für `Button`.  
  
<a name="themestyles"></a>   
## <a name="default-theme-styles"></a>Standard(design)stile  
 Jedes Steuerelement, das [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] umfasst, verfügt über einen Standardstil. Der Standardstil variiert möglicherweise nach Design, weshalb dieser Standardstil manchmal auch als Designstil bezeichnet wird.  
  
 Die wichtigsten Informationen, die innerhalb eines Standardstils gefunden wird, für ein Steuerelement, dessen Steuerelementvorlage, ist die im Designstil als Setter für vorhanden ist die <xref:System.Windows.Controls.Control.Template%2A> Eigenschaft. Wenn keine Vorlage von Standardstilen vorhanden wäre, hätte ein Steuerelement ohne eine benutzerdefinierte Vorlage als Teil eines benutzerdefinierten Stils überhaupt keine visuelle Darstellung. Die Vorlage des Standardstils gibt der visuellen Darstellung jedes Steuerelements eine grundlegende Struktur und definiert zudem die Verbindungen zwischen Eigenschaften, die in der visuellen Struktur der Vorlage und der entsprechenden Steuerelementklasse definiert werden. Jedes Steuerelement macht einen Satz von Eigenschaften verfügbar, die die visuelle Darstellung des Steuerelements beeinflussen können, ohne die Vorlage komplett zu ersetzen. Betrachten Sie beispielsweise die Standardeinstellung für die visuelle Darstellung des eine <xref:System.Windows.Controls.Primitives.Thumb> -Steuerelement, das eine Komponente ist von einem <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Ein <xref:System.Windows.Controls.Primitives.Thumb> verfügt über bestimmte anpassbare Eigenschaften. Die Standardvorlage eine <xref:System.Windows.Controls.Primitives.Thumb> erstellt eine grundlegende Struktur / visuelle Struktur mit mehreren geschachtelten <xref:System.Windows.Controls.Border> Komponenten zum Erstellen eines. Wenn eine Eigenschaft, die Teil der Vorlage ist für die Anpassung von verfügbar gemacht werden soll die <xref:System.Windows.Controls.Primitives.Thumb> Klasse, und klicken Sie dann die Eigenschaft durch verfügbar gemacht werden muss eine [TemplateBinding](templatebinding-markup-extension.md), in der Vorlage. Im Fall von <xref:System.Windows.Controls.Primitives.Thumb>, verschiedene Eigenschaften dieser Rahmen eine vorlagenbindung zu Eigenschaften wie z. B. Freigeben von <xref:System.Windows.Controls.Border.Background%2A> oder <xref:System.Windows.Controls.Border.BorderThickness%2A>. Bestimmte andere Eigenschaften oder visuelle Anordnungen sind in der Steuerelementvorlage hartcodiert oder an Werte gebunden, die direkt aus diesem Design stammen. Diese können nicht ersetzt werden, ohne die gesamte Vorlage zu ersetzen. Im Allgemeinen gilt, dass eine Eigenschaft, die von einem vorlagenbasierten übergeordneten Element stammt und nicht von einer Vorlagenbindung verfügbar gemacht wird, nicht durch Stile angepasst werden kann, da nicht auf einfache Weise auf sie abgezielt werden kann. Diese Eigenschaft kann jedoch trotzdem durch die Eigenschaftswertvererbung in der angewandten Vorlage oder durch den Standardwert beeinflusst werden.  
  
 Die Designstile verwenden einen Typ als Schlüssel in ihren Definitionen. Wenn jedoch Designs auf eine bestimmte Elementinstanz angewendet werden, Designsuche für diesen Typ wird ausgeführt durch Überprüfen der <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> Eigenschaft eines Steuerelements. Dies steht im Gegensatz zur Verwendung des Literaltyps, wie es bei impliziten Stilen der Fall ist. Der Wert des <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> würde auf die abgeleitete Klassen erben, auch wenn die Implementierung es nicht geändert haben (die vorgesehene Weise ändern der Eigenschaft ist nicht für die sie auf der Eigenschaftenebene überschreiben, sondern auf ihren Standardwert in Eigenschaftsmetadaten ändern). Diese Dereferenzierung ermöglicht Basisklassen, die Designstile für abgeleitete Elemente zu definieren, die andernfalls über keinen Stil verfügen (oder noch wichtiger: die über keine Vorlage innerhalb dieses Stils verfügen und somit überhaupt keine visuelle Standarddarstellung haben würden). Sie können daher ableiten `MyButton` aus <xref:System.Windows.Controls.Button> und erhalten trotzdem die <xref:System.Windows.Controls.Button> Standardvorlage. Würden Sie den Autor des Steuerelements der `MyButton` und ein anderes Verhalten gewünscht, können Sie die Metadaten für die Eigenschaft überschreiben <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> auf `MyButton` auf einen anderen Schlüssel zurückzugeben, und definieren Sie dann die entsprechenden Designstile, einschließlich einer Vorlage für `MyButton` , die Sie mit Packen müssen Ihre `MyButton` Steuerelement. Weitere Informationen über Designs, Stile und das Erstellen von Steuerelementen finden Sie unter [Übersicht über das Erstellen von Steuerelementen](../controls/control-authoring-overview.md).  
  
<a name="resources"></a>   
## <a name="dynamic-resource-references-and-binding"></a>Dynamische Ressourcenverweise und Binden  
 Dynamische Ressourcenverweise und Bindungsvorgänge berücksichtigen die Rangfolge des Speicherorts, an dem sie festgelegt werden. Beispielsweise fungiert eine dynamische Ressource, die auf einen lokalen Wert angewendet wird, als Rangfolgenelement 3, eine Bindung für einen Eigenschaften-Setter innerhalb eines Designstils gilt als Rangfolgenelement 9 usw. Da sowohl dynamische Ressourcenreferenzen als auch das Binden Werte aus dem Laufzeitzustand der Anwendung abrufen können muss, hat dies zur Folge, dass der eigentliche Prozess der Bestimmung der Eigenschaftswert-Rangfolge für eine bestimmte Eigenschaft ebenfalls auf die Laufzeit ausgeweitet wird.  
  
 Dynamische Ressourcenverweise sind streng genommen nicht Teil des Eigenschaftensystems, sie verfügen jedoch über eine eigene Suchreihenfolge, die mit der oben aufgeführten Sequenz interagiert. Diese Rangfolge ist in den [XAML-Ressourcen](xaml-resources.md) genauer dokumentiert. Die grundlegende Zusammenfassung dieser Rangfolge ist: Element zu Seitenstamm, Anwendung, Design, System.  
  
 Dynamische Ressourcen und Bindungen verwenden die Rangfolge von wo sie festgelegt wurden, der Wert ist jedoch zurückgestellt. Eine Folge dessen ist, dass wenn Sie eine dynamische Ressource oder Bindung für einen lokalen Wert festlegen, jede Änderung am lokalen Wert die dynamische Ressource oder Bindung vollständig ersetzt. Auch wenn Sie Aufrufen der <xref:System.Windows.DependencyObject.ClearValue%2A> Methode zum Löschen der lokal festgelegten Wert, der dynamische Ressource oder Bindung nicht wiederhergestellt. In der Tat, wenn Sie aufrufen <xref:System.Windows.DependencyObject.ClearValue%2A> auf eine Eigenschaft, die eine dynamische Ressource oder Bindung (ohne literalen lokalen Wert) verfügt, sie werden gelöscht, indem die <xref:System.Windows.DependencyObject.ClearValue%2A> zu aufrufen.  
  
<a name="setcurrentvalue"></a>   
## <a name="setcurrentvalue"></a>SetCurrentValue  
 Die <xref:System.Windows.DependencyObject.SetCurrentValue%2A> Methode ist eine weitere Möglichkeit, eine Eigenschaft festzulegen, aber es ist nicht in der Rangfolge. Stattdessen <xref:System.Windows.DependencyObject.SetCurrentValue%2A> ermöglicht es Ihnen, den Wert einer Eigenschaft zu ändern, ohne die Quelle eines vorherigen Werts zu überschreiben. Sie können <xref:System.Windows.DependencyObject.SetCurrentValue%2A> jedes Mal, die Sie einen Wert ohne diesem Wert die Rangfolge einen lokalen Wert festlegen möchten. Angenommen, eine Eigenschaft durch einen Trigger festgelegt ist, und klicken Sie dann einen anderen Wert über zugewiesen <xref:System.Windows.DependencyObject.SetCurrentValue%2A>, das Eigenschaftensystem trotzdem berücksichtigt des Triggers und die Eigenschaft wird geändert, wenn die Aktion des Triggers auftritt. <xref:System.Windows.DependencyObject.SetCurrentValue%2A> ermöglicht es Ihnen, den Wert der Eigenschaft zu ändern, ohne ihr eine Quelle mit einer höheren Priorität. Ebenso können Sie <xref:System.Windows.DependencyObject.SetCurrentValue%2A> , den Wert einer Eigenschaft zu ändern, ohne eine Bindung zu überschreiben.  
  
<a name="animations"></a>   
## <a name="coercion-animations-and-base-value"></a>Koersion, Animationen und Basiswert  
 Sowohl Koersion als auch Animation wirken auf einen Wert, der in diesem [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)] als „Basiswert“ bezeichnet wird. Der Basiswert ist daher der Wert, der dadurch bestimmt wird, dass in den Elementen von unten nach oben geprüft wird, bis das Element 2 erreicht wird.  
  
 Bei einer Animation kann sich der Basiswert auf den animierten Wert auswirken, wenn diese Animation nicht sowohl „From“ (Von) als auch „To“ (Zu) für bestimmte Verhalten angibt, oder wenn die Animation nach Abschluss bewusst auf den Basiswert zurücksetzt. Um dies in der Praxis nachzuvollziehen, führen Sie das [Beispiel für From-, To- und By-Animationszielwerte](https://go.microsoft.com/fwlink/?LinkID=159988) aus. Versuchen Sie, die lokalen Werte für die Höhe des Rechtecks im Beispiel so festzulegen, dass sich der ursprüngliche lokale Wert von jedem „From“-Wert in der Animation unterscheidet. Sie werden feststellen, dass die Animationen sofort starten, die „From“-Werte verwenden und den Basiswert ersetzen. Die Animation könnte angeben, um zurück auf den Wert vor der Animation gefunden wird, sobald er abgeschlossen ist, durch Angabe der Unterbrechungspunkt <xref:System.Windows.Media.Animation.FillBehavior>. Anschließend wird die normale Rangfolge für die Bestimmung des Basiswerts verwendet.  
  
 Möglicherweise werden mehrere Animationen auf eine einzelne Eigenschaft angewendet, wobei jede dieser Animationen von verschiedenen Punkten in der Wertrangfolge definiert sein kann. Jedoch setzen diese Animationen möglicherweise ihre Werte zusammen, anstatt nur die Animation der höheren Priorität anzuwenden. Dies hängt davon ab, wie die Animationen genau definiert sind, sowie vom Typ des Werts, der animiert wird. Weitere Informationen zum Animieren von Eigenschaften finden Sie unter [Übersicht über Animationen](../graphics-multimedia/animation-overview.md).  
  
 Die Koersion gilt auf der höchsten Ebene von allen. Selbst eine bereits ausgeführte Animation unterliegt der Koersion des Werts. Bestimmte vorhandene Abhängigkeitseigenschaften in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] verfügen über eine integrierte Koersion. Für eine benutzerdefinierte Abhängigkeitseigenschaft können Sie das Koersionsverhalten für eine benutzerdefinierte Abhängigkeitseigenschaft definieren, indem Sie das Schreiben einer <xref:System.Windows.CoerceValueCallback> und den Rückruf als Teil der Metadaten übergeben, wenn Sie die Eigenschaft zu erstellen. Sie können das Koersionsverhalten vorhandener Eigenschaften auch überschreiben, indem Sie die Metadaten dieser Eigenschaft in einer abgeleiteten Klasse überschreiben. Die Koersion interagiert so mit dem Basiswert, dass die zum diesem Zeitpunkt vorliegenden Einschränkungen der Koersion angewendet werden, der Basiswert jedoch trotzdem erhalten bleibt. Wenn Einschränkungen der Koersion später angehoben werden, gibt die Koersion daher den Wert zurück, der diesem Basiswert am nächsten liegt, und der Einfluss der Koersion auf eine Eigenschaft wird möglicherweise gestoppt, sobald alle Einschränkungen angehoben wurden. Weitere Informationen zum Koersionsverhalten finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](dependency-property-callbacks-and-validation.md).  
  
<a name="triggers"></a>   
## <a name="trigger-behaviors"></a>Triggerverhalten  
 Steuerelemente definieren Triggerverhalten häufig als Teil ihres Standardstils in Designs. Durch das Festlegen von lokalen Eigenschaften für Steuerelemente wird möglicherweise verhindert, dass die Trigger entweder über die Darstellung oder das Verhalten auf benutzergesteuerte Ereignisse reagieren können. Die häufigste Verwendung von einem Eigenschaftsauslöser ist für Steuerelement- oder Zustandseigenschaften wie <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>. Beispielsweise standardmäßig bei der ein <xref:System.Windows.Controls.Button> ist deaktiviert (auslösen für <xref:System.Windows.UIElement.IsEnabled%2A> ist `false`) und dann die <xref:System.Windows.Controls.Control.Foreground%2A> Wert im Designstil ist, was bewirkt, dass das Steuerelement "ausgegraut" angezeigt. Aber wenn Sie eine lokale festgelegt haben <xref:System.Windows.Controls.Control.Foreground%2A> Wert, der, dass normale Farbe in der Rangfolge durch Ihre lokal festgelegte Eigenschaft, auch in dieser Eigenschaft ausgelösten Szenario überschrieben wird. Seien Sie vorsichtig mit dem Festlegen von Werten für Eigenschaften, die über Triggerverhalten auf Designebene verfügen, und stellen Sie sicher, dass Sie nicht in die vorgesehene Benutzerfreundlichkeit dieses Steuerelements eingreifen.  
  
<a name="clearvalue"></a>   
## <a name="clearvalue-and-value-precedence"></a>ClearValue und Wertrangfolge  
 Die <xref:System.Windows.DependencyObject.ClearValue%2A> Methode bietet ein sinnvolles Mittel zum von lokal angewendeten Werten einer Abhängigkeitseigenschaft zu löschen, die für ein Element festgelegt ist. Das Aufrufen von jedoch <xref:System.Windows.DependencyObject.ClearValue%2A> ist keine Garantie, dass die Standardeinstellung, wie in den Metadaten eingerichtet, bei der Registrierung der den neuen gültigen Wert ist. Alle anderen Teilnehmer der Wertrangfolge sind noch immer aktiv. Nur der lokal festgelegte Wert wurde von der Rangfolgensequenz entfernt. Wenn Sie aufrufen, z. B. <xref:System.Windows.DependencyObject.ClearValue%2A> für eine Eigenschaft, in dem diese Eigenschaft auch durch einen Designstil festgelegt ist, wird der Designwert wird als der neue Wert statt auf die Standardwerte angewendet. Wenn Sie alle von eigenschaftswerteteilnehmer aus dem Prozess nehmen und den Wert in den registrierten Metadatenstandard festlegen möchten, erhalten Sie, dass Standardwert definitiv durch Abfragen der Metadaten für Abhängigkeitseigenschaften, und klicken Sie dann Sie den Standardwert, der lokal verwendet werden kann Legen Sie die Eigenschaft mit einem Aufruf von <xref:System.Windows.DependencyObject.SetValue%2A>.  
  
## <a name="see-also"></a>Siehe auch

- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md)
- [Benutzerdefinierte Abhängigkeitseigenschaften](custom-dependency-properties.md)
- [Rückrufe und Validierung von Abhängigkeitseigenschaften](dependency-property-callbacks-and-validation.md)
