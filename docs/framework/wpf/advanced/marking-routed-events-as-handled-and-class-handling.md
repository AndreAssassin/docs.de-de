---
title: Markieren von Routingereignissen als behandelt und Klassenbehandlung
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 8cce3d1effa163c35cd219a6a52504b0f4d98c73
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/28/2019
ms.locfileid: "64598659"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Markieren von Routingereignissen als behandelt und Klassenbehandlung
Handler für ein Routingereignis können das Ereignis innerhalb der Ereignisdaten als behandelt markieren. Das Behandeln des Ereignisses verkürzt die Route. Die Klassenbehandlung ist ein Programmierkonzept, das von Routingereignissen unterstützt wird. Ein Klassenhandler hat die Möglichkeit, ein bestimmtes Routingereignis auf Klassenebene mit einem Ereignishandler zu verarbeiten, der vor jedem Instanzenhandler auf jeder Instanz der Klasse aufgerufen wird.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Vorraussetzungen  
 In diesem Thema werden unter [Übersicht über Routingereignisse](routed-events-overview.md) eingeführte Konzepte näher erläutert.  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Markieren von Ereignissen als behandelt  
 Den Wert, der beim Festlegen der <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft, um `true` in dieser Daten für ein Routingereignis, dies wird als bezeichnet "das Ereignis als behandelt markieren". Es gibt keine absolute Regel dafür, wann Sie Routingereignisse als Anwendungsentwickler oder als Autor von Steuerelementen, der auf vorhandenen Routingereignisse reagiert oder neue Routingereignisse implementiert, als behandelt markieren sollten. Das Konzept „behandelt“, so wie es in den Ereignisdaten des Routingereignisses ausgeführt wird, sollte als begrenztes Protokoll für die Antworten Ihrer eigenen Anwendung auf verschiedene weitergeleitete Ereignisse in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] sowie für alle benutzerdefinierten Routingereignisse verwendet werden. Eine weitere Möglichkeit, das Problem als „behandelt“ zu markieren ist, wenn Code auf eine Weise signifikant und relativ vollständig auf das Routingereignis geantwortet hat. In der Regel sollte es nicht mehr als eine signifikante Antwort geben, die separate Handlerimplementierungen für Routingereignisse erfordern muss. Wenn mehr Antworten erforderlich sind, sollte der erforderliche Code über Anwendungslogik implementiert werden, die in einem einzelnen Handler, nicht mithilfe des Weiterleitungssystems des Routingereignisses verkettet ist. Das Konzept von „erheblich“ ist ebenfalls subjektiv und hängt von der Anwendung oder dem Code ab. „Signifikante Antworten“ sind z.B.: das Festlegen des Fokus, die Änderung des öffentlichen Zustands, das Festlegen von Eigenschaften, die sich auf die visuelle Darstellung auswirken, und das Auslösen neuer Ereignisse. Beispiele für nicht signifikante Antworten sind: die Änderung des privaten Status (mit keiner visuellen Auswirkung oder eine programmgesteuerte Darstellung), das Protokollieren von Ereignissen, oder das Anzeigen eines Ereignisses und die Wahl, nicht darauf zu reagieren.  
  
 Das Routingereignisverhalten des Routingereignissystems verstärkt dieses Modell der "signifikanten Antworten" für die Verwendung des behandelten Zustands eines Routingereignisses, da der Handler hinzugefügt [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] oder die allgemeine Signatur der <xref:System.Windows.UIElement.AddHandler%2A> nicht als Antwort auf ein Routingereignis aufgerufen werden, in dem das Ereignis Daten werden bereits als behandelt gekennzeichnet. Wechseln Sie über der zusätzliche Aufwand für das Hinzufügen eines Handlers mit der `handledEventsToo` -Parameterversion (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) um verarbeiten Routingereignisse, die von früheren Teilnehmern behandelt gekennzeichnet sind in der Ereignisroute.  
  
 In einigen Fällen markieren Steuerelemente selbst bestimmte Routingereignisse als behandelt. Mit einem behandelten Rountingereignis gibt der Autor eines [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Steuerelements zu verstehen, dass die Antwort des Steuerelements auf das Routingereignis signifikant bzw. im Rahmen der Implementierung vollständig ist und dass das Ereignis keine weitere Behandelung benötigt. Dies erfolgt normalerweise durch Hinzufügen eines Klassenhandlers für ein Ereignis oder durch Überschreiben eines der virtuellen Klassenhandler, die in einer Basisklasse vorhanden sind. Sie können dieses Ereignisbehandlung, wenn notwendig, umgehen. Informationen dazu finden Sie weiter unten im Abschnitt [Umgehen der Ereignisunterdrückung von Steuerelementen](#WorkingAroundEventSuppressionByControls) in diesem Thema.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>"Preview" (Tunneling-Ereignisse) Visual Studio. Bubbling-Ereignissen und Behandlung von Ereignissen  
 Vorschaurountingereignisse sind Ereignisse, die einer Tunnelingroute in der Elementstruktur folgen. Die „Vorschau“ in der Benennungskonvention weist auf das allgemeine Prinzip bei Eingabeereignissen hin, nach dem Vorschau-/ Tunneling-Routingereignisse vor den entsprechenden Bubbling-Rountingereignissen ausgelöst werden. Außerdem haben Eingaberountingereignisse mit einem Tunneling- und einem Bubblingereignis eine andere Behandlungslogik. Wenn das Tunneling-/ Vorschauroutingereignis von einem Ereignislistener als behandelt markiert wurde, dann wird das Bubblingereignis als behandelt markiert, noch bevor alle Listener des Bubblingereignisses es erhalten. Die Tunneling- und Bubblingroutingereignisse sind technisch separate Ereignisse. Sie teilen sich aber absichtlich dieselbe Ereignisdateninstanz, um dieses Verhalten zu ermöglichen.  
  
 Die Verbindung zwischen Tunneling- und Bubbling-Rountingereignissen wird mithilfe der internen Implementierung erreicht, die angibt, wie jede gegebene [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Klasse die eigenen deklarierten Routingereignisse auslöst. Dies gilt für alle gekoppelten Eingaberountingereignisse. Es besteht keine Verbindung zwischen einem Tunneling- und einem Bubbling-Routnigereignis, die dasselbe Benennungsschema nutzen, wenn diese Implementierung auf Klassenebene nicht vorhanden: Ohne diese Implementierung wären beide Routingereignisse zwei vollständig getrennt und würden weder in der Sequenz ausgelöst werden, noch dieselben Ereignisdaten haben.  
  
 Weitere Informationen dazu, wie Sie Tunneling-/Bubbling-Eingabeereignispaare in einer benutzerdefinierten Klasse implementieren, finden Sie unter [Erstellen eines benutzerdefinierten Routingereignisses](how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Klassenhandler und Instanzhandler  
 Rountingereignisse sollten Sie zwei verschiedene Arten von Ereignislistenern beachten: Klassenlistener und Instanzlistener. Klassenlistener vorhanden sind, da die Typen mit eine bestimmten aufgerufen haben <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in ihrem statischen Konstruktor oder haben eine Handler für die virtuelle Methode von einer Element-Basisklasse überschreiben. Instanzlistener sind bestimmte Klasseninstanzen/Elemente, in dem ein oder mehrere Handler für dieses Routingereignis durch einen Aufruf von angefügt haben wurde <xref:System.Windows.UIElement.AddHandler%2A>. Vorhandene [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Routingereignisse Aufrufe an <xref:System.Windows.UIElement.AddHandler%2A> als Teil der [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] -Ereigniswrapper hinzufügen{} und Entfernen von{} Implementierungen des Ereignisses, handelt es sich auch wie die einfache [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] Mechanismus zum Anfügen Ereignishandler über eine Attributsyntax aktiviert ist. Daher auch die einfache [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] Nutzung letztlich entspricht einer <xref:System.Windows.UIElement.AddHandler%2A> aufrufen.  
  
 Elemente innerhalb der visuellen Struktur werden auf registrierte Handlerimplementierungen überprüft. Handler werden möglicherweise in der gesamten Route aufgerufen, und zwar in der Reihenfolge, die im Typ der Routingstrategie für das Routingereignis inhärent ist. Bubbling-Routingereignisse rufen z.B. zuerst die Handler auf, die dem gleichen Element zugeordnet sind, das das Routingereignis ausgelöst hat. Das Routingereignis bubblet dann zu dem nächsten übergeordneten Element und so weiter, bis das Stammelement der Anwendung erreicht ist.  
  
 Wenn aus der Perspektive des Stammelements in einer Bubblingroute die Klassenbehandlung oder ein beliebiges Element, das sich näher an der Quelle des Routingereignisses befindet, Handler aufrufen, die die Ereignisargumente als behandelt markieren, werden Handler in den Stammelementen nicht aufgerufen, und die Ereignisroute wird effektiv verkürzt, bevor das Stammelement erreicht wird. Die Route wird jedoch nicht vollständig angehalten, da Handler mithilfe der bestimmten Bedingung hinzugefügt werden können, dass sie trotzdem noch aufgerufen werden sollen, auch wenn ein Klassen- oder Instanzhandler das Routingereignis als behandelt markiert hat. Informationen hierzu finden Sie im Abschnitt [Hinzufügen von Instanzhandlern, die ausgelöst werden, obwohl Ereignisse als behandelt markiert wurden](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled) weiter unten in diesem Thema.  
  
 Auf einer tieferen Ebene als die Ereignisroute operieren möglicherweise mehrere Klassenhandler auf jeder gegebenen Instanz einer Klasse. Das liegt daran, dass das Klassenbehandlungsmodell für Routingereignisse es allen möglichen Klassen in einer Klassenhierarchie ermöglicht, einen eigenen Klassenhandler für jedes Routingereignis zu registrieren. Jeder Klassenhandler wird einem internen Speicher hinzugefügt, und wenn die Ereignisroute für eine Anwendung erstellt wird, werden die Klassenhandler werden alle der Ereignisroute hinzugefügt. Klassenhandler werden der Route so hinzugefügt, dass der am stärksten abgeleitete Klassenhandler zuerst und die Klassenhandler aus jeder nachfolgenden Basisklasse im Anschluss aufgerufen werden. Klassenhandler werden im Allgemeinen nicht registriert, sodass sie auch auf Routingereignisse reagieren, die bereits als behandelt markiert wurden. Dieser Mechanismus zur Klassenbehandlung ermöglicht eine dieser zwei Optionen:  
  
- Abgeleitete Klassen können die Klassenbehandlung ergänzen, die von der Basisklasse geerbt wird, indem ein Handler hinzugefügt wird, der das Routingereignis nicht als behandelt markiert, da der Basisklassenhandler nach dem Handler der abgeleiteten Klasse aufgerufen wird.  
  
- Abgeleitete Klassen können die Klassenbehandlung der Basisklasse ersetzen, indem ein Klassenhandler hinzugefügt wird, der das Routingereignis als behandelt markiert. Bei diesem Ansatz sollten Sie sorgfältig vorgehen, da er möglicherweise das vorgesehene Design des Basissteuerelements in Bereichen wie der visuelle Darstellung, der Zustandslogik, der Eingabeverarbeitung und der Befehlsbehandlung ändert.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Klassenbehandlung von Routingereignissen durch Steuerelementbasisklassen  
 Auf jedem gegebene Elementknoten in einer Ereignisroute haben Klassenlistener die Möglichkeit, vor jedem Instanzlistener auf dem Element auf das Routingereignis zu reagieren. Aus diesem Grund werden Klassenhandler manchmal verwendet, um Routingereignisse zu unterdrücken, die von der Implementierung einer bestimmten Steuerelementklasse nicht weitergegeben werden sollen, oder um eine besondere Behandlung des Routingereignisses bereitzustellen, das eine Funktion der Klasse ist. Eine Klasse kann z.B. ein eigenes klassenspezifisches Ereignis auslösen, das weitere Details über die Bedeutung einer Benutzereingabebedingung im Kontext der jeweiligen Klasse enthält. Die Implementierung der Klasse kann das allgemeinere Routingereignis dann als behandelt markieren. Klassenhandler werden in der Regel hinzugefügt, dass sie für Routingereignisse nicht aufgerufen werden, in denen gemeinsam genutzte Ereignisdaten bereits gekennzeichneten, Ereignisse behandelt, aber für atypische Fälle gibt es ist auch eine <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> Signatur, die Klassen-Handler zum Aufrufen, selbst wenn Routingereignisse werden registriert als behandelt markiert wurden.  
  
### <a name="class-handler-virtuals"></a>Virtuelle Klassenhandler  
 Einige Elemente, insbesondere Basiselemente wie z. B. <xref:System.Windows.UIElement>, machen leer "auf * Event" und "OnPreview\*Ereignis" virtuelle Methoden, die ihre Liste der öffentlichen Routingereignisse entsprechen. Diese virtuellen Methoden können überschrieben werden, um einen Klassenhandler für dieses Routingereignis zu implementieren. Die Basiselementklassen registrieren diese virtuellen Methoden als ihren Klassenhandler für jedes dieser weitergeleitet Ereignis mit <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> wie zuvor beschrieben. Die virtuellen On\*Event-Methoden vereinfachen die Implementierung der Klassenbehandlung für die relevanten Routingereignisse, ohne eine spezielle Initialisierung in statischen Konstruktoren für jeden Typ zu erfordern. Sie können z. B. eine Klassenbehandlung für das Hinzufügen der <xref:System.Windows.UIElement.DragEnter> Ereignis in einem <xref:System.Windows.UIElement> abgeleitete Klasse durch Überschreiben der <xref:System.Windows.UIElement.OnDragEnter%2A> virtuelle Methode. In der Überschreibung können Sie das Routingereignis behandeln, andere Ereignisse auslösen, klassenspezifische Logik initialisieren, die Elementeigenschaften für Instanzen ändern kann, oder jede beliebige Kombination dieser Aktionen ausführen. Sie sollten die Basisimplementierung solcher Überschreibungen generell aufrufen, selbst wenn Sie das Ereignis als behandelt markieren. Das Aufrufen der Basisimplementierung wird dringend empfohlen, da sich die virtuelle Methode in der Basisklasse befindet. Das geschützte virtuelle Standardmuster, bei dem die Basisimplementierungen aus jeder virtuellen Methode aufgerufen werden, ersetzt und entspricht einem ähnlichen Mechanismus, der nativ in der Klassenbehandlung von Routingereignissen vorkommt. Dabei werden Klassenhandler für alle Klassen in einer Klassenhierarchie auf jeder Instanz aufgerufen, beginnend mit dem Handler der am stärksten abgeleiteten Klasse und anschließend mit den Handlern der Basisklasse. Sie sollten den Aufruf der Basisimplementierung nur weglassen, wenn Ihre Klasse eine explizite Anforderung enthält, die Logik der Basisklassenbehandlung zu ändern. Es hängt von der Art Ihrer Implementierung ab, ob Sie die Basisimplementierung vor oder nach dem überschreibenden Code aufrufen.  
  
#### <a name="input-event-class-handling"></a>Klassenbehandlung von Eingabeereignissen  
 Virtuelle Methoden des Klassenhandlers werden alle so registriert, dass sie nur dann aufgerufen werden, wenn gemeinsam genutzte Ereignisdaten nicht bereits als behandelt markiert wurden. Außerdem werden nur bei Eingabeereignissen die Tunneling- und Bubblingversionen in der Regel nacheinander ausgelöst und verwenden dieselben Ereignisdaten. Dazu sollten Sie ein Ereignis für ein bestimmtes Paar von Eingabeereignis-Klassenhandlern, von denen einer die Tunneling-und der andere die Bubblingversion darstellt, nicht sofort als behandelt markieren. Wenn Sie die virtuelle Methode der Tunneling-Klassenbehandlung implementieren, um das Ereignis als behandelt zu markieren, wird der Bubbling-Klassenhandler daran gehindert, aufgerufen zu werden (außerdem wird verhindert, dass alle normal registrierten Instanzhandler für das Tunneling- oder das Bubblingereignis aufgerufen werden).  
  
 Nach Abschluss der Klassenbehandlung für einen Knoten werden die Instanzlistener berücksichtigt.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Hinzufügen von Instanzhandlern, die ausgelöst werden, obwohl Ereignisse als behandelt markiert wurden  
 Die <xref:System.Windows.UIElement.AddHandler%2A> Methode stellt eine bestimmte Überladung mit dem Sie Handler hinzuzufügen, die vom Ereignissystem aufgerufen werden, wenn ein Ereignis das behandelnde Element in der Route erreicht, selbst wenn ein anderer Handler bereits angepasst hat, um zu kennzeichnen, die die Daten bereit. das Ereignis als behandelt. Dies wird in der Regel nicht ausgeführt. Ereignishandler können generell geschrieben werden, um alle Bereiche des Anwendungscodes anzupassen, die von einem Ereignis beeinflusst werden können, unabhängig davon, wo es in einer Elementstruktur behandelt wurde, auch wenn mehrere Ergebnisse gewünscht sind. Darüber hinaus gibt es in der Regel nur ein Element, das auf dieses Ereignis reagieren muss, und die entsprechende Anwendungslogik ist bereits geschehen. Für Ausnahmefälle steht die `handledEventsToo`-Überladung zur Verfügung, in der ein anderes Element in einer Elementstruktur oder Zusammensetzung von Steuerelementen ein Ereignis bereits als behandelt markiert hat, während andere, in der Elementstruktur höhere oder niedrigere Elemente (je nach Route) ihre eigenen Handler aber aufrufen möchten.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Markieren von behandelten Ereignisse als nicht behandelt  
 Im Allgemeinen Routingereignisse, die als behandelt markiert werden sollte nicht als unbehandelt markiert werden (<xref:System.Windows.RoutedEventArgs.Handled%2A> Zurücksetzung `false`) selbst mit Handlern, die auf `handledEventsToo`. Allerdings haben einige Ereignisse Ereignisdarstellungen auf hoher und niedriger Ebene, die sich überlappen können, wenn das Ereignis auf höherer Ebene an einer Position in der Struktur und das Ereignis auf niedrigerer Ebene an einer anderen Position angezeigt wird. Betrachten Sie beispielsweise den Fall, in dem ein untergeordnetes Element auf ein Ereignis wie z. B. lauscht <xref:System.Windows.UIElement.TextInput> und ein übergeordnetes Element auf niedrigerer Ebene wie z. B. <xref:System.Windows.UIElement.KeyDown>. Wenn das übergeordnete Element das Ereignis auf niedrigerer Ebene behandelt, kann das Ereignis auf höherer Ebene sogar im untergeordneten Element unterdrückt werden, das intuitiv als Erstes die Möglichkeit haben sollte, das Ereignis zu behandeln.  
  
 In diesen Situationen kann es erforderlich sein, für das Ereignis auf niedrigerer Ebene sowohl dem übergeordneten als auch dem untergeordneten Element Handler hinzuzufügen. Die Handlerimplementierung für das untergeordnete Element kann das Ereignis auf niedrigerer Ebene als behandelt markieren, aber die Handlerimplementierung des übergeordneten Elements würde dies wieder rückgängig machen, damit andere Elemente weiter oben in der Struktur (und das Ereignis auf höherer Ebene) die Möglichkeit haben, zu reagieren. Diese Situation ist aber relativ selten.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Beabsichtigtes Unterdrücken von Eingabeereignissen für die Zusammensetzung von Steuerelementen  
 Das Hauptszenario, in dem die Klassenbehandlung von Routingereignissen dazu verwendet wird, sind Eingabeereignisse und zusammengesetzte Steuerelemente. Ein zusammengesetztes Steuerelement besteht per definitionem aus mehreren praktischen Steuerelementen oder Steuerelement-Basisklassen. Häufig möchte der Autor des Steuerelements alle möglichen Eingabeereignisse verbinden, die von den einzelnen Unterkomponenten ausgelöst werden können, um das gesamte Steuerelement als Ereignisquelle zu melden. In einigen Fällen möchte der Autor des Steuerelements die Ereignisse von Komponenten möglicherweise vollständig unterdrücken oder ein komponentendefiniertes Ereignis ersetzen, das weitere Informationen enthält oder ein spezifischeres Verhalten impliziert. Die für jeden Komponentenautor sofort sichtbare ist ein typisches Beispiel ist wie ein [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> behandelt Mausereignis, das letztlich in ein intuitives Ereignis aufgelöst wird, das alle Schaltflächen aufweisen: einen <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 Die <xref:System.Windows.Controls.Button> Basisklasse (<xref:System.Windows.Controls.Primitives.ButtonBase>) leitet sich von <xref:System.Windows.Controls.Control> dem wiederum leitet sich von <xref:System.Windows.FrameworkElement> und <xref:System.Windows.UIElement>, und einen Großteil der Ereignisinfrastruktur, die für die Verarbeitung der Steuerelementeingabe erhältlich ist erforderlich. die <xref:System.Windows.UIElement> Ebene. Insbesondere <xref:System.Windows.UIElement> verarbeitet allgemeine <xref:System.Windows.Input.Mouse> Ereignisse, die Treffertests für den Mauscursor innerhalb seiner Grenzen zu behandeln, und stellt verschiedene Ereignisse für die am häufigsten verwendeten Schaltfläche Aktionen, z. B. <xref:System.Windows.UIElement.MouseLeftButtonDown>. <xref:System.Windows.UIElement> bietet auch eine leere virtuelle <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> als vorab registrierten Klassenhandler für <xref:System.Windows.UIElement.MouseLeftButtonDown>, und <xref:System.Windows.Controls.Primitives.ButtonBase> außer Kraft gesetzt. Auf ähnliche Weise <xref:System.Windows.Controls.Primitives.ButtonBase> verwendet Klassenhandler für <xref:System.Windows.UIElement.MouseLeftButtonUp>. In den überschreibungen, die die Ereignisdaten übergeben werden, markieren die Implementierungen, die <xref:System.Windows.RoutedEventArgs> wie behandelt, indem Instanzen <xref:System.Windows.RoutedEventArgs.Handled%2A> zu `true`, und dieselben Ereignisdaten ist, was in der verbleibenden Route, die anderen Klassenhandler wird fortgesetzt, und Instanzhandler oder Ereignissetter. Darüber hinaus die <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> Außerkraftsetzung anschließend löst der <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis. Das Endergebnis für die meisten Listener werden, die die <xref:System.Windows.UIElement.MouseLeftButtonDown> und <xref:System.Windows.UIElement.MouseLeftButtonUp> Ereignisse "verschwinden" und werden stattdessen durch ersetzt <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, ein Ereignis, das mehr Aussagekraft, weil es bekannt ist, dass dieses Ereignis stammt aus einer echten Schaltfläche und nicht nur ein Teil Zusammengesetzte Verknüpfungen vollständig der Schaltfläche oder ein anderes Element.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Umgehen der Ereignisunterdrückung von Steuerelementen  
 Manchmal kann dieses Ereignis unterdrückende Verhalten in einzelnen Steuerelementen einige allgemeinere Absichten der Ereignisbehandlungslogik der Anwendung behindern. Beispielsweise, wenn aus irgendeinem Grund Ihrer Anwendung einen Handler für <xref:System.Windows.UIElement.MouseLeftButtonDown> im Stammelement der Anwendung befindet, werden Sie bemerken, dass ein Mausklick auf eine Schaltfläche, und nicht aufrufen würden <xref:System.Windows.UIElement.MouseLeftButtonDown> oder <xref:System.Windows.UIElement.MouseLeftButtonUp> Handler auf der Stammebene. Das Ereignis selbst würde aufbubblen (wie gesagt, Ereignisroutes werden nicht tatsächlich beendet, das Routingereignissystem ändert nur deren Aufrufverhalten für Ereignishandler, nachdem sie als behandelt markiert wurden). Wenn das Routingereignis die Schaltfläche, erreicht der <xref:System.Windows.Controls.Primitives.ButtonBase> Klassenbehandlung markiert die <xref:System.Windows.UIElement.MouseLeftButtonDown> behandelt, da durch Ersetzen der <xref:System.Windows.Controls.Primitives.ButtonBase.Click> -Ereignis mit mehr Bedeutung. Aus diesem Grund alle standardmäßigen <xref:System.Windows.UIElement.MouseLeftButtonDown> Handler weiter oben in der Route wird nicht aufgerufen werden. Es gibt zwei Verfahren, mit denen Sie sicherzustellen können, dass die Handler unter diesen Umständen aufgerufen werden würden.  
  
 Die erste Technik ist absichtlich Hinzufügen des Handlers mithilfe der `handledEventsToo` Signatur <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>. Dieses Verfahren zum Anhängen eines Ereignishandlers ist aber nur im Code und nicht in Markup möglich. Die einfache Syntax für die Angabe des Ereignishandlernamens als Ereignisattributwert über [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] ermöglicht dieses Verhalten nicht.  
  
 Das zweite Verfahren funktioniert nur für Eingabeereignisse, in denen die Tunneling- und Bubblingversionen des Routingereignisses kombiniert werden. Für diese Routingereignisse können Sie stattdessen der Vorschau-/Tunnelingversion des Routingereignisses Handler hinzufügen. Dieses Routingereignis tunnelt ausgehend vom Stamm durch die Route, damit der Code für die Behandlung der Schaltflächenklasse es nicht abfängt, vorausgesetzt, dass Sie den Vorschauhandler in einer Vorgängerebene in der Anwendungsstruktur angefügt haben. Wenn Sie diesen Ansatz verwenden, sollten Sie beim Markieren von Vorschauereignissen als behandelt vorsichtig vorgehen. Für das Beispiel mit <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> im Stammelement behandelt werden, wenn Sie das Ereignis als markiert <xref:System.Windows.RoutedEventArgs.Handled%2A> in die Implementierung des Handlers, würde unterdrückt die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis. Dies ist in der Regel kein erwünschtes Verhalten.  
  
## <a name="see-also"></a>Siehe auch

- <xref:System.Windows.EventManager>
- [Vorschauereignisse](preview-events.md)
- [Erstellen eines benutzerdefinierten Routingereignisses](how-to-create-a-custom-routed-event.md)
- [Übersicht über Routingereignisse](routed-events-overview.md)
