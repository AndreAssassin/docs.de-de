---
title: Markieren von Routingereignissen als behandelt und Klassenbehandlung
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 6e3f314de07948e53ffed13ddc1289c1de115edd
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 07/23/2019
ms.locfileid: "68401632"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Markieren von Routingereignissen als behandelt und Klassenbehandlung
Handler für ein Routingereignis können das Ereignis innerhalb der Ereignisdaten als behandelt markieren. Das Behandeln des Ereignisses verkürzt die Route. Die Klassenbehandlung ist ein Programmierkonzept, das von Routingereignissen unterstützt wird. Ein Klassenhandler hat die Möglichkeit, ein bestimmtes Routingereignis auf Klassenebene mit einem Ereignishandler zu verarbeiten, der vor jedem Instanzenhandler auf jeder Instanz der Klasse aufgerufen wird.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Erforderliche Komponenten  
 In diesem Thema werden unter [Übersicht über Routingereignisse](routed-events-overview.md) eingeführte Konzepte näher erläutert.  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Markieren von Ereignissen als behandelt  
 Wenn Sie den Wert der <xref:System.Windows.RoutedEventArgs.Handled%2A> -Eigenschaft in den Ereignisdaten für ein Routing Ereignis auf `true` festlegen, wird dies als "kennzeichnen des behandelten Ereignisses" bezeichnet. Es gibt keine absolute Regel dafür, wann Sie Routingereignisse als Anwendungsentwickler oder als Autor von Steuerelementen, der auf vorhandenen Routingereignisse reagiert oder neue Routingereignisse implementiert, als behandelt markieren sollten. Zum größten Teil sollte das Konzept "behandelt", das in den Ereignisdaten des Routing Ereignisses enthalten ist, als eingeschränktes Protokoll für die Antworten ihrer eigenen Anwendung auf die verschiedenen Routing Ereignisse, die in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs verfügbar gemacht werden, sowie für alle benutzerdefinierten Routing Ereignisse verwendet werden. Eine weitere Möglichkeit, das Problem als „behandelt“ zu markieren ist, wenn Code auf eine Weise signifikant und relativ vollständig auf das Routingereignis geantwortet hat. In der Regel sollte es nicht mehr als eine signifikante Antwort geben, die separate Handlerimplementierungen für Routingereignisse erfordern muss. Wenn mehr Antworten erforderlich sind, sollte der erforderliche Code über Anwendungslogik implementiert werden, die in einem einzelnen Handler, nicht mithilfe des Weiterleitungssystems des Routingereignisses verkettet ist. Das Konzept von „erheblich“ ist ebenfalls subjektiv und hängt von der Anwendung oder dem Code ab. „Signifikante Antworten“ sind z.B.: das Festlegen des Fokus, die Änderung des öffentlichen Zustands, das Festlegen von Eigenschaften, die sich auf die visuelle Darstellung auswirken, und das Auslösen neuer Ereignisse. Beispiele für nicht signifikante Antworten sind: die Änderung des privaten Status (mit keiner visuellen Auswirkung oder eine programmgesteuerte Darstellung), das Protokollieren von Ereignissen, oder das Anzeigen eines Ereignisses und die Wahl, nicht darauf zu reagieren.  
  
 Das Verhalten des Routing Ereignis Systems verstärkt dieses "bedeutende Antwort Modell" für die Verwendung des behandelten Zustands eines Routing Ereignisses, da in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] hinzugefügte Handler oder die allgemeine Signatur von <xref:System.Windows.UIElement.AddHandler%2A> nicht als Antwort auf ein Routing Ereignis aufgerufen werden, bei dem das Ereignis die Daten sind bereits als behandelt markiert. Sie müssen den zusätzlichen Aufwand für das Hinzufügen eines Handlers mit `handledEventsToo` der Parameter Version<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>() durchlaufen, um Routing Ereignisse zu verarbeiten, die von früheren Teilnehmern in der Ereignis Route behandelt werden.  
  
 In einigen Fällen markieren Steuerelemente selbst bestimmte Routingereignisse als behandelt. Mit einem behandelten Rountingereignis gibt der Autor eines [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Steuerelements zu verstehen, dass die Antwort des Steuerelements auf das Routingereignis signifikant bzw. im Rahmen der Implementierung vollständig ist und dass das Ereignis keine weitere Behandelung benötigt. Dies erfolgt normalerweise durch Hinzufügen eines Klassenhandlers für ein Ereignis oder durch Überschreiben eines der virtuellen Klassenhandler, die in einer Basisklasse vorhanden sind. Sie können dieses Ereignisbehandlung, wenn notwendig, umgehen. Informationen dazu finden Sie weiter unten im Abschnitt [Umgehen der Ereignisunterdrückung von Steuerelementen](#WorkingAroundEventSuppressionByControls) in diesem Thema.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>"Vorschau" (tunnelingereignisse) im Vergleich zu Blasen Ereignisse und Ereignis Behandlung  
 Vorschaurountingereignisse sind Ereignisse, die einer Tunnelingroute in der Elementstruktur folgen. Die „Vorschau“ in der Benennungskonvention weist auf das allgemeine Prinzip bei Eingabeereignissen hin, nach dem Vorschau-/ Tunneling-Routingereignisse vor den entsprechenden Bubbling-Rountingereignissen ausgelöst werden. Außerdem haben Eingaberountingereignisse mit einem Tunneling- und einem Bubblingereignis eine andere Behandlungslogik. Wenn das Tunneling-/ Vorschauroutingereignis von einem Ereignislistener als behandelt markiert wurde, dann wird das Bubblingereignis als behandelt markiert, noch bevor alle Listener des Bubblingereignisses es erhalten. Die Tunneling- und Bubblingroutingereignisse sind technisch separate Ereignisse. Sie teilen sich aber absichtlich dieselbe Ereignisdateninstanz, um dieses Verhalten zu ermöglichen.  
  
 Die Verbindung zwischen Tunneling- und Bubbling-Rountingereignissen wird mithilfe der internen Implementierung erreicht, die angibt, wie jede gegebene [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Klasse die eigenen deklarierten Routingereignisse auslöst. Dies gilt für alle gekoppelten Eingaberountingereignisse. Es besteht keine Verbindung zwischen einem Tunneling- und einem Bubbling-Routnigereignis, die dasselbe Benennungsschema nutzen, wenn diese Implementierung auf Klassenebene nicht vorhanden: Ohne diese Implementierung wären beide Routingereignisse zwei vollständig getrennt und würden weder in der Sequenz ausgelöst werden, noch dieselben Ereignisdaten haben.  
  
 Weitere Informationen dazu, wie Sie Tunneling-/Bubbling-Eingabeereignispaare in einer benutzerdefinierten Klasse implementieren, finden Sie unter [Erstellen eines benutzerdefinierten Routingereignisses](how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Klassenhandler und Instanzhandler  
 Rountingereignisse sollten Sie zwei verschiedene Arten von Ereignislistenern beachten: Klassenlistener und Instanzlistener. Klassenlistener existieren, weil Typen eine bestimmte <xref:System.Windows.EventManager> API,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in Ihrem statischen Konstruktor aufgerufen haben oder eine virtuelle Klassen Handler-Methode von einer Element Basisklasse überschrieben haben. Instanzlistener sind bestimmte Klassen Instanzen/-Elemente, bei denen mindestens ein Handler für dieses Routing Ereignis durch einen-Rückruf <xref:System.Windows.UIElement.AddHandler%2A>angefügt wurde. Vorhandene [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Routing Ereignisse machen Aufrufe an <xref:System.Windows.UIElement.AddHandler%2A> als Teil der Common Language Runtime (CLR)-Ereignis Wrapper Add{} -und{} remove-Implementierungen des Ereignisses, das auch den einfachen [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] Mechanismus von das Anfügen von Ereignis Handlern über eine Attribut Syntax ist aktiviert. Daher entspricht auch die [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] einfache Verwendung letztendlich einem <xref:System.Windows.UIElement.AddHandler%2A> -Rückruf.  
  
 Elemente innerhalb der visuellen Struktur werden auf registrierte Handlerimplementierungen überprüft. Handler werden möglicherweise in der gesamten Route aufgerufen, und zwar in der Reihenfolge, die im Typ der Routingstrategie für das Routingereignis inhärent ist. Bubbling-Routingereignisse rufen z.B. zuerst die Handler auf, die dem gleichen Element zugeordnet sind, das das Routingereignis ausgelöst hat. Das Routingereignis bubblet dann zu dem nächsten übergeordneten Element und so weiter, bis das Stammelement der Anwendung erreicht ist.  
  
 Wenn aus der Perspektive des Stammelements in einer Bubblingroute die Klassenbehandlung oder ein beliebiges Element, das sich näher an der Quelle des Routingereignisses befindet, Handler aufrufen, die die Ereignisargumente als behandelt markieren, werden Handler in den Stammelementen nicht aufgerufen, und die Ereignisroute wird effektiv verkürzt, bevor das Stammelement erreicht wird. Die Route wird jedoch nicht vollständig angehalten, da Handler mithilfe der bestimmten Bedingung hinzugefügt werden können, dass sie trotzdem noch aufgerufen werden sollen, auch wenn ein Klassen- oder Instanzhandler das Routingereignis als behandelt markiert hat. Informationen hierzu finden Sie im Abschnitt [Hinzufügen von Instanzhandlern, die ausgelöst werden, obwohl Ereignisse als behandelt markiert wurden](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled) weiter unten in diesem Thema.  
  
 Auf einer tieferen Ebene als die Ereignisroute operieren möglicherweise mehrere Klassenhandler auf jeder gegebenen Instanz einer Klasse. Das liegt daran, dass das Klassenbehandlungsmodell für Routingereignisse es allen möglichen Klassen in einer Klassenhierarchie ermöglicht, einen eigenen Klassenhandler für jedes Routingereignis zu registrieren. Jeder Klassenhandler wird einem internen Speicher hinzugefügt, und wenn die Ereignisroute für eine Anwendung erstellt wird, werden die Klassenhandler werden alle der Ereignisroute hinzugefügt. Klassenhandler werden der Route so hinzugefügt, dass der am stärksten abgeleitete Klassenhandler zuerst und die Klassenhandler aus jeder nachfolgenden Basisklasse im Anschluss aufgerufen werden. Klassenhandler werden im Allgemeinen nicht registriert, sodass sie auch auf Routingereignisse reagieren, die bereits als behandelt markiert wurden. Dieser Mechanismus zur Klassenbehandlung ermöglicht eine dieser zwei Optionen:  
  
- Abgeleitete Klassen können die Klassenbehandlung ergänzen, die von der Basisklasse geerbt wird, indem ein Handler hinzugefügt wird, der das Routingereignis nicht als behandelt markiert, da der Basisklassenhandler nach dem Handler der abgeleiteten Klasse aufgerufen wird.  
  
- Abgeleitete Klassen können die Klassenbehandlung der Basisklasse ersetzen, indem ein Klassenhandler hinzugefügt wird, der das Routingereignis als behandelt markiert. Bei diesem Ansatz sollten Sie sorgfältig vorgehen, da er möglicherweise das vorgesehene Design des Basissteuerelements in Bereichen wie der visuelle Darstellung, der Zustandslogik, der Eingabeverarbeitung und der Befehlsbehandlung ändert.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Klassenbehandlung von Routingereignissen durch Steuerelementbasisklassen  
 Auf jedem gegebene Elementknoten in einer Ereignisroute haben Klassenlistener die Möglichkeit, vor jedem Instanzlistener auf dem Element auf das Routingereignis zu reagieren. Aus diesem Grund werden Klassenhandler manchmal verwendet, um Routingereignisse zu unterdrücken, die von der Implementierung einer bestimmten Steuerelementklasse nicht weitergegeben werden sollen, oder um eine besondere Behandlung des Routingereignisses bereitzustellen, das eine Funktion der Klasse ist. Eine Klasse kann z.B. ein eigenes klassenspezifisches Ereignis auslösen, das weitere Details über die Bedeutung einer Benutzereingabebedingung im Kontext der jeweiligen Klasse enthält. Die Implementierung der Klasse kann das allgemeinere Routingereignis dann als behandelt markieren. Klassen Handler werden in der Regel so hinzugefügt, dass Sie nicht für Routing Ereignisse aufgerufen werden, bei denen freigegebene Ereignisdaten bereits als behandelt markiert wurden, aber <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> für atypische Fälle gibt es auch eine Signatur, die Klassen Handler zum Aufrufen registriert, auch wenn Routing Ereignisse als behandelt markiert.  
  
### <a name="class-handler-virtuals"></a>Virtuelle Klassenhandler  
 Einige-Elemente, insbesondere die Basiselemente wie <xref:System.Windows.UIElement>, machen die virtuellen Methoden "on * Event" und "\*OnPreview Event" verfügbar, die Ihrer Liste der öffentlichen Routing Ereignisse entsprechen. Diese virtuellen Methoden können überschrieben werden, um einen Klassenhandler für dieses Routingereignis zu implementieren. Die Basiselement Klassen registrieren diese virtuellen Methoden als Klassen Handler für jedes Routing Ereignis mithilfe <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> von, wie zuvor beschrieben. Die virtuellen On\*Event-Methoden vereinfachen die Implementierung der Klassenbehandlung für die relevanten Routingereignisse, ohne eine spezielle Initialisierung in statischen Konstruktoren für jeden Typ zu erfordern. Beispielsweise können Sie eine Klassen Behandlung für das <xref:System.Windows.UIElement.DragEnter> -Ereignis in einer <xref:System.Windows.UIElement> abgeleiteten Klasse hinzufügen, indem Sie die <xref:System.Windows.UIElement.OnDragEnter%2A> virtuelle-Methode überschreiben. In der Überschreibung können Sie das Routingereignis behandeln, andere Ereignisse auslösen, klassenspezifische Logik initialisieren, die Elementeigenschaften für Instanzen ändern kann, oder jede beliebige Kombination dieser Aktionen ausführen. Sie sollten die Basisimplementierung solcher Überschreibungen generell aufrufen, selbst wenn Sie das Ereignis als behandelt markieren. Das Aufrufen der Basisimplementierung wird dringend empfohlen, da sich die virtuelle Methode in der Basisklasse befindet. Das geschützte virtuelle Standardmuster, bei dem die Basisimplementierungen aus jeder virtuellen Methode aufgerufen werden, ersetzt und entspricht einem ähnlichen Mechanismus, der nativ in der Klassenbehandlung von Routingereignissen vorkommt. Dabei werden Klassenhandler für alle Klassen in einer Klassenhierarchie auf jeder Instanz aufgerufen, beginnend mit dem Handler der am stärksten abgeleiteten Klasse und anschließend mit den Handlern der Basisklasse. Sie sollten den Aufruf der Basisimplementierung nur weglassen, wenn Ihre Klasse eine explizite Anforderung enthält, die Logik der Basisklassenbehandlung zu ändern. Es hängt von der Art Ihrer Implementierung ab, ob Sie die Basisimplementierung vor oder nach dem überschreibenden Code aufrufen.  
  
#### <a name="input-event-class-handling"></a>Klassenbehandlung von Eingabeereignissen  
 Virtuelle Methoden des Klassenhandlers werden alle so registriert, dass sie nur dann aufgerufen werden, wenn gemeinsam genutzte Ereignisdaten nicht bereits als behandelt markiert wurden. Außerdem werden nur bei Eingabeereignissen die Tunneling- und Bubblingversionen in der Regel nacheinander ausgelöst und verwenden dieselben Ereignisdaten. Dazu sollten Sie ein Ereignis für ein bestimmtes Paar von Eingabeereignis-Klassenhandlern, von denen einer die Tunneling-und der andere die Bubblingversion darstellt, nicht sofort als behandelt markieren. Wenn Sie die virtuelle Methode der Tunneling-Klassenbehandlung implementieren, um das Ereignis als behandelt zu markieren, wird der Bubbling-Klassenhandler daran gehindert, aufgerufen zu werden (außerdem wird verhindert, dass alle normal registrierten Instanzhandler für das Tunneling- oder das Bubblingereignis aufgerufen werden).  
  
 Nach Abschluss der Klassenbehandlung für einen Knoten werden die Instanzlistener berücksichtigt.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Hinzufügen von Instanzhandlern, die ausgelöst werden, obwohl Ereignisse als behandelt markiert wurden  
 Die <xref:System.Windows.UIElement.AddHandler%2A> -Methode stellt eine bestimmte Überladung bereit, mit der Sie Handler hinzufügen können, die vom Ereignis System aufgerufen werden, wenn ein Ereignis das Behandlungs Element in der Route erreicht, selbst wenn ein anderer Handler die Ereignisdaten bereits so angepasst hat, dass diese Ereignis als behandelt. Dies wird in der Regel nicht ausgeführt. Ereignishandler können generell geschrieben werden, um alle Bereiche des Anwendungscodes anzupassen, die von einem Ereignis beeinflusst werden können, unabhängig davon, wo es in einer Elementstruktur behandelt wurde, auch wenn mehrere Ergebnisse gewünscht sind. Darüber hinaus gibt es in der Regel nur ein Element, das auf dieses Ereignis reagieren muss, und die entsprechende Anwendungslogik ist bereits geschehen. Für Ausnahmefälle steht die `handledEventsToo`-Überladung zur Verfügung, in der ein anderes Element in einer Elementstruktur oder Zusammensetzung von Steuerelementen ein Ereignis bereits als behandelt markiert hat, während andere, in der Elementstruktur höhere oder niedrigere Elemente (je nach Route) ihre eigenen Handler aber aufrufen möchten.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Markieren von behandelten Ereignisse als nicht behandelt  
 Im Allgemeinen sollten Routing Ereignisse, die als behandelt markiert sind, auch durch Handler<xref:System.Windows.RoutedEventArgs.Handled%2A> , die auf `false` `handledEventsToo`reagieren, nicht als nicht behandelt gekennzeichnet werden. Allerdings haben einige Ereignisse Ereignisdarstellungen auf hoher und niedriger Ebene, die sich überlappen können, wenn das Ereignis auf höherer Ebene an einer Position in der Struktur und das Ereignis auf niedrigerer Ebene an einer anderen Position angezeigt wird. Nehmen Sie beispielsweise <xref:System.Windows.UIElement.TextInput> an, dass ein untergeordnetes Element auf ein allgemeines Schlüsselereignis lauscht, z <xref:System.Windows.UIElement.KeyDown>. b., während ein übergeordnetes Element auf ein Ereignis auf niedriger Ebene, z. b., lauscht. Wenn das übergeordnete Element das Ereignis auf niedrigerer Ebene behandelt, kann das Ereignis auf höherer Ebene sogar im untergeordneten Element unterdrückt werden, das intuitiv als Erstes die Möglichkeit haben sollte, das Ereignis zu behandeln.  
  
 In diesen Situationen kann es erforderlich sein, für das Ereignis auf niedrigerer Ebene sowohl dem übergeordneten als auch dem untergeordneten Element Handler hinzuzufügen. Die Handlerimplementierung für das untergeordnete Element kann das Ereignis auf niedrigerer Ebene als behandelt markieren, aber die Handlerimplementierung des übergeordneten Elements würde dies wieder rückgängig machen, damit andere Elemente weiter oben in der Struktur (und das Ereignis auf höherer Ebene) die Möglichkeit haben, zu reagieren. Diese Situation ist aber relativ selten.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Beabsichtigtes Unterdrücken von Eingabeereignissen für die Zusammensetzung von Steuerelementen  
 Das Hauptszenario, in dem die Klassenbehandlung von Routingereignissen dazu verwendet wird, sind Eingabeereignisse und zusammengesetzte Steuerelemente. Ein zusammengesetztes Steuerelement besteht per definitionem aus mehreren praktischen Steuerelementen oder Steuerelement-Basisklassen. Häufig möchte der Autor des Steuerelements alle möglichen Eingabeereignisse verbinden, die von den einzelnen Unterkomponenten ausgelöst werden können, um das gesamte Steuerelement als Ereignisquelle zu melden. In einigen Fällen möchte der Autor des Steuerelements die Ereignisse von Komponenten möglicherweise vollständig unterdrücken oder ein komponentendefiniertes Ereignis ersetzen, das weitere Informationen enthält oder ein spezifischeres Verhalten impliziert. Das kanonische Beispiel, das für jeden Komponenten Autor sofort sichtbar ist, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] ist, wie ein <xref:System.Windows.Controls.Button> beliebiges Maus Ereignis behandelt, das letztendlich in das intuitive Ereignis aufgelöst wird <xref:System.Windows.Controls.Primitives.ButtonBase.Click> , das alle Schaltflächen aufweisen: ein-Ereignis.  
  
 Die <xref:System.Windows.Controls.Button> -Basisklasse<xref:System.Windows.Controls.Primitives.ButtonBase>() ist <xref:System.Windows.Controls.Control> abgeleitet, von der wiederum <xref:System.Windows.FrameworkElement> von <xref:System.Windows.UIElement>und abgeleitet ist, und ein Großteil der für die Steuerelement Eingabe erforderlichen Ereignis Infrastruktur <xref:System.Windows.UIElement> ist auf der-Ebene verfügbar. Insbesondere <xref:System.Windows.UIElement> verarbeitet allgemeine <xref:System.Windows.Input.Mouse> Ereignisse, die Treffer Tests für den Maus Cursor innerhalb seiner Grenzen behandeln, und bietet unterschiedliche Ereignisse für die gängigsten <xref:System.Windows.UIElement.MouseLeftButtonDown>Schaltflächen Aktionen, wie z. b. <xref:System.Windows.UIElement>stellt außerdem eine leere virtuelle <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> als den vorab registrierten Klassen Handler für <xref:System.Windows.UIElement.MouseLeftButtonDown>bereit und <xref:System.Windows.Controls.Primitives.ButtonBase> überschreibt Sie. Ebenso werden <xref:System.Windows.Controls.Primitives.ButtonBase> von Klassen Handler für <xref:System.Windows.UIElement.MouseLeftButtonUp>verwendet. In den über schreibungen, an die die Ereignisdaten weitergegeben werden, markieren die <xref:System.Windows.RoutedEventArgs> Implementierungen diese Instanz als verarbeitet <xref:System.Windows.RoutedEventArgs.Handled%2A> , `true`indem auf festgelegt wird, und dass die gleichen Ereignisdaten entlang der restlichen Route zu anderen Klassen Handlern fortgesetzt werden. auch für Instanzhandler oder Ereignis Setter. Außerdem wird das <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> - <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis durch die außer Kraft Setzung als nächstes angehoben. Das Endergebnis für die meisten Listener besteht darin, dass <xref:System.Windows.UIElement.MouseLeftButtonDown> das <xref:System.Windows.UIElement.MouseLeftButtonUp> -Ereignis und das-Ereignis "verschwinden" <xref:System.Windows.Controls.Primitives.ButtonBase.Click>und stattdessen durch ersetzt werden, einem Ereignis, das mehr Bedeutung hat, da es bekannt ist, dass dieses Ereignis aus einer True-Schaltfläche stammt und nicht aus einigen zusammengesetzter Teil der Schaltfläche oder von einem anderen Element vollständig.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Umgehen der Ereignisunterdrückung von Steuerelementen  
 Manchmal kann dieses Ereignis unterdrückende Verhalten in einzelnen Steuerelementen einige allgemeinere Absichten der Ereignisbehandlungslogik der Anwendung behindern. Wenn beispielsweise die Anwendung aus irgendeinem Grund über einen Handler <xref:System.Windows.UIElement.MouseLeftButtonDown> verfügt, der sich im Stamm Element der Anwendung befindet, würden Sie feststellen, dass jeder Maus Klick auf einer Schaltfläche <xref:System.Windows.UIElement.MouseLeftButtonDown> keine-oder <xref:System.Windows.UIElement.MouseLeftButtonUp> -Handler auf der Stamm Ebene aufruft. Das Ereignis selbst würde aufbubblen (wie gesagt, Ereignisroutes werden nicht tatsächlich beendet, das Routingereignissystem ändert nur deren Aufrufverhalten für Ereignishandler, nachdem sie als behandelt markiert wurden). Wenn das Routing Ereignis die Schaltfläche erreicht hat <xref:System.Windows.Controls.Primitives.ButtonBase> , wurde die Klasse <xref:System.Windows.UIElement.MouseLeftButtonDown> verarbeitet, die behandelt hat, da <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Sie das Ereignis durch mehr Bedeutung ersetzen wollte. Daher würde jeder Standard <xref:System.Windows.UIElement.MouseLeftButtonDown> Handler, der die Route weiter oben durchführt, nicht aufgerufen werden. Es gibt zwei Verfahren, mit denen Sie sicherzustellen können, dass die Handler unter diesen Umständen aufgerufen werden würden.  
  
 Die erste Methode besteht darin, den Handler absichtlich mithilfe der `handledEventsToo` Signatur von <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>hinzuzufügen. Dieses Verfahren zum Anhängen eines Ereignishandlers ist aber nur im Code und nicht in Markup möglich. Die einfache Syntax für die Angabe des Ereignishandlernamens als Ereignisattributwert über [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] ermöglicht dieses Verhalten nicht.  
  
 Das zweite Verfahren funktioniert nur für Eingabeereignisse, in denen die Tunneling- und Bubblingversionen des Routingereignisses kombiniert werden. Für diese Routingereignisse können Sie stattdessen der Vorschau-/Tunnelingversion des Routingereignisses Handler hinzufügen. Dieses Routingereignis tunnelt ausgehend vom Stamm durch die Route, damit der Code für die Behandlung der Schaltflächenklasse es nicht abfängt, vorausgesetzt, dass Sie den Vorschauhandler in einer Vorgängerebene in der Anwendungsstruktur angefügt haben. Wenn Sie diesen Ansatz verwenden, sollten Sie beim Markieren von Vorschauereignissen als behandelt vorsichtig vorgehen. Wenn Sie das-Ereignis in der Handlerimplementierung als behandelt haben, <xref:System.Windows.RoutedEventArgs.Handled%2A> <xref:System.Windows.Controls.Primitives.ButtonBase.Click> wird das-Ereignis tatsächlich unterdrückt, wenn Sie das-Ereignis in der Handlerimplementierung als gekennzeichnet haben. <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> Dies ist in der Regel kein erwünschtes Verhalten.  
  
## <a name="see-also"></a>Siehe auch

- <xref:System.Windows.EventManager>
- [Vorschauereignisse](preview-events.md)
- [Erstellen eines benutzerdefinierten Routingereignisses](how-to-create-a-custom-routed-event.md)
- [Übersicht über Routingereignisse](routed-events-overview.md)
