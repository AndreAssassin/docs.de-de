---
title: Markieren von Routingereignissen als behandelt und Klassenbehandlung
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 55ed91a848ce69fa6ce3e69a654a56d7875912b5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401040"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Markieren von Routingereignissen als behandelt und Klassenbehandlung
Handler für ein Routingereignis können das Ereignis innerhalb der Ereignisdaten als behandelt markieren. Das Behandeln des Ereignisses verkürzt die Route. Die Klassenbehandlung ist ein Programmierkonzept, das von Routingereignissen unterstützt wird. Ein Klassenhandler hat die Möglichkeit, ein bestimmtes Routingereignis auf Klassenebene mit einem Ereignishandler zu verarbeiten, der vor jedem Instanzenhandler auf jeder Instanz der Klasse aufgerufen wird.  

<a name="prerequisites"></a>
## <a name="prerequisites"></a>Voraussetzungen  
 In diesem Thema werden unter [Übersicht über Routingereignisse](routed-events-overview.md) eingeführte Konzepte näher erläutert.  
  
<a name="When_to_Mark_Events_as_Handled"></a>
## <a name="when-to-mark-events-as-handled"></a>Markieren von Ereignissen als behandelt  
 Wenn Sie den Wert <xref:System.Windows.RoutedEventArgs.Handled%2A> der `true` Eigenschaft in den Ereignisdaten für ein routingiertes Ereignis festlegen, wird dies als "Markieren des behandelten Ereignisses" bezeichnet. Es gibt keine absolute Regel dafür, wann Sie Routingereignisse als Anwendungsentwickler oder als Autor von Steuerelementen, der auf vorhandenen Routingereignisse reagiert oder neue Routingereignisse implementiert, als behandelt markieren sollten. Das Konzept des "behandelt" in den Ereignisdaten des gerouteten Ereignisses sollte größtenteils als begrenztes Protokoll für die Antworten Ihrer eigenen [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Anwendung auf die verschiedenen gerouteten Ereignisse verwendet werden, die in APIs verfügbar gemacht werden, sowie für alle benutzerdefinierten gerouteten Ereignisse. Eine weitere Möglichkeit, das Problem als „behandelt“ zu markieren ist, wenn Code auf eine Weise signifikant und relativ vollständig auf das Routingereignis geantwortet hat. In der Regel sollte es nicht mehr als eine signifikante Antwort geben, die separate Handlerimplementierungen für Routingereignisse erfordern muss. Wenn mehr Antworten erforderlich sind, sollte der erforderliche Code über Anwendungslogik implementiert werden, die in einem einzelnen Handler, nicht mithilfe des Weiterleitungssystems des Routingereignisses verkettet ist. Das Konzept von „erheblich“ ist ebenfalls subjektiv und hängt von der Anwendung oder dem Code ab. „Signifikante Antworten“ sind z.B.: das Festlegen des Fokus, die Änderung des öffentlichen Zustands, das Festlegen von Eigenschaften, die sich auf die visuelle Darstellung auswirken, und das Auslösen neuer Ereignisse. Beispiele für nicht signifikante Antworten sind: die Änderung des privaten Status (mit keiner visuellen Auswirkung oder eine programmgesteuerte Darstellung), das Protokollieren von Ereignissen, oder das Anzeigen eines Ereignisses und die Wahl, nicht darauf zu reagieren.  
  
 Das Verhalten des gerouteten Ereignissystems verstärkt dieses "signifikante Antwortmodell" für die Verwendung [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] des behandelten <xref:System.Windows.UIElement.AddHandler%2A> Zustands eines gerouteten Ereignisses, da die in oder die gemeinsame Signatur von hinzugefügten Handler nicht als Reaktion auf ein geroutetes Ereignis aufgerufen werden, bei dem die Ereignisdaten bereits als behandelt markiert sind. Sie müssen den zusätzlichen Aufwand durchlaufen, `handledEventsToo` einen Handler<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>mit der Parameterversion ( ) hinzuzufügen, um geroutete Ereignisse zu verarbeiten, die von früheren Teilnehmern der Ereignisroute behandelt werden.  
  
 In einigen Fällen markieren Steuerelemente selbst bestimmte Routingereignisse als behandelt. Mit einem behandelten Rountingereignis gibt der Autor eines [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Steuerelements zu verstehen, dass die Antwort des Steuerelements auf das Routingereignis signifikant bzw. im Rahmen der Implementierung vollständig ist und dass das Ereignis keine weitere Behandelung benötigt. Dies erfolgt normalerweise durch Hinzufügen eines Klassenhandlers für ein Ereignis oder durch Überschreiben eines der virtuellen Klassenhandler, die in einer Basisklasse vorhanden sind. Sie können dieses Ereignisbehandlung, wenn notwendig, umgehen. Informationen dazu finden Sie weiter unten im Abschnitt [Umgehen der Ereignisunterdrückung von Steuerelementen](#WorkingAroundEventSuppressionByControls) in diesem Thema.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>"Vorschau" (Tunneling)-Ereignisse im Vergleich zu Bubbling-Ereignissen und Ereignisbehandlung  
 Vorschaurountingereignisse sind Ereignisse, die einer Tunnelingroute in der Elementstruktur folgen. Die „Vorschau“ in der Benennungskonvention weist auf das allgemeine Prinzip bei Eingabeereignissen hin, nach dem Vorschau-/ Tunneling-Routingereignisse vor den entsprechenden Bubbling-Rountingereignissen ausgelöst werden. Außerdem haben Eingaberountingereignisse mit einem Tunneling- und einem Bubblingereignis eine andere Behandlungslogik. Wenn das Tunneling-/ Vorschauroutingereignis von einem Ereignislistener als behandelt markiert wurde, dann wird das Bubblingereignis als behandelt markiert, noch bevor alle Listener des Bubblingereignisses es erhalten. Die Tunneling- und Bubblingroutingereignisse sind technisch separate Ereignisse. Sie teilen sich aber absichtlich dieselbe Ereignisdateninstanz, um dieses Verhalten zu ermöglichen.  
  
 Die Verbindung zwischen Tunneling- und Bubbling-Rountingereignissen wird mithilfe der internen Implementierung erreicht, die angibt, wie jede gegebene [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Klasse die eigenen deklarierten Routingereignisse auslöst. Dies gilt für alle gekoppelten Eingaberountingereignisse. Es besteht keine Verbindung zwischen einem Tunneling- und einem Bubbling-Routnigereignis, die dasselbe Benennungsschema nutzen, wenn diese Implementierung auf Klassenebene nicht vorhanden: Ohne diese Implementierung wären beide Routingereignisse zwei vollständig getrennt und würden weder in der Sequenz ausgelöst werden, noch dieselben Ereignisdaten haben.  
  
 Weitere Informationen dazu, wie Sie Tunneling-/Bubbling-Eingabeereignispaare in einer benutzerdefinierten Klasse implementieren, finden Sie unter [Erstellen eines benutzerdefinierten Routingereignisses](how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>
## <a name="class-handlers-and-instance-handlers"></a>Klassenhandler und Instanzhandler  
 Rountingereignisse sollten Sie zwei verschiedene Arten von Ereignislistenern beachten: Klassenlistener und Instanzlistener. Klassenlistener sind vorhanden, <xref:System.Windows.EventManager> weil<xref:System.Windows.EventManager.RegisterClassHandler%2A>Typen eine bestimmte API aufgerufen haben , , in ihrem statischen Konstruktor oder eine virtuelle Klassenhandlermethode aus einer Elementbasisklasse überschrieben haben. Instanzlistener sind bestimmte Klasseninstanzen/-elemente, bei denen ein oder mehrere <xref:System.Windows.UIElement.AddHandler%2A>Handler für dieses routingierte Ereignis durch einen Aufruf von angefügt wurden. Vorhandene [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] geroutete Ereignisse <xref:System.Windows.UIElement.AddHandler%2A> führen Aufrufe zu als Teil der Common Language{} Runtime (CLR) Ereigniswrapper hinzufügen und entfernen{} Implementierungen des Ereignisses, was auch der einfache [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] Mechanismus des Anfügens von Ereignishandlern über eine Attributsyntax ist. Daher ist [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] auch die einfache <xref:System.Windows.UIElement.AddHandler%2A> Verwendung letztlich gleichbedeutend mit einem Anruf.  
  
 Elemente innerhalb der visuellen Struktur werden auf registrierte Handlerimplementierungen überprüft. Handler werden möglicherweise in der gesamten Route aufgerufen, und zwar in der Reihenfolge, die im Typ der Routingstrategie für das Routingereignis inhärent ist. Bubbling-Routingereignisse rufen z.B. zuerst die Handler auf, die dem gleichen Element zugeordnet sind, das das Routingereignis ausgelöst hat. Das Routingereignis bubblet dann zu dem nächsten übergeordneten Element und so weiter, bis das Stammelement der Anwendung erreicht ist.  
  
 Wenn aus der Perspektive des Stammelements in einer Bubblingroute die Klassenbehandlung oder ein beliebiges Element, das sich näher an der Quelle des Routingereignisses befindet, Handler aufrufen, die die Ereignisargumente als behandelt markieren, werden Handler in den Stammelementen nicht aufgerufen, und die Ereignisroute wird effektiv verkürzt, bevor das Stammelement erreicht wird. Die Route wird jedoch nicht vollständig angehalten, da Handler mithilfe der bestimmten Bedingung hinzugefügt werden können, dass sie trotzdem noch aufgerufen werden sollen, auch wenn ein Klassen- oder Instanzhandler das Routingereignis als behandelt markiert hat. Informationen hierzu finden Sie im Abschnitt [Hinzufügen von Instanzhandlern, die ausgelöst werden, obwohl Ereignisse als behandelt markiert wurden](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled) weiter unten in diesem Thema.  
  
 Auf einer tieferen Ebene als die Ereignisroute operieren möglicherweise mehrere Klassenhandler auf jeder gegebenen Instanz einer Klasse. Das liegt daran, dass das Klassenbehandlungsmodell für Routingereignisse es allen möglichen Klassen in einer Klassenhierarchie ermöglicht, einen eigenen Klassenhandler für jedes Routingereignis zu registrieren. Jeder Klassenhandler wird einem internen Speicher hinzugefügt, und wenn die Ereignisroute für eine Anwendung erstellt wird, werden die Klassenhandler werden alle der Ereignisroute hinzugefügt. Klassenhandler werden der Route so hinzugefügt, dass der am stärksten abgeleitete Klassenhandler zuerst und die Klassenhandler aus jeder nachfolgenden Basisklasse im Anschluss aufgerufen werden. Klassenhandler werden im Allgemeinen nicht registriert, sodass sie auch auf Routingereignisse reagieren, die bereits als behandelt markiert wurden. Dieser Mechanismus zur Klassenbehandlung ermöglicht eine dieser zwei Optionen:  
  
- Abgeleitete Klassen können die Klassenbehandlung ergänzen, die von der Basisklasse geerbt wird, indem ein Handler hinzugefügt wird, der das Routingereignis nicht als behandelt markiert, da der Basisklassenhandler nach dem Handler der abgeleiteten Klasse aufgerufen wird.  
  
- Abgeleitete Klassen können die Klassenbehandlung der Basisklasse ersetzen, indem ein Klassenhandler hinzugefügt wird, der das Routingereignis als behandelt markiert. Bei diesem Ansatz sollten Sie sorgfältig vorgehen, da er möglicherweise das vorgesehene Design des Basissteuerelements in Bereichen wie der visuelle Darstellung, der Zustandslogik, der Eingabeverarbeitung und der Befehlsbehandlung ändert.  
  
<a name="Class_Handling_of_Routed_Events"></a>
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Klassenbehandlung von Routingereignissen durch Steuerelementbasisklassen  
 Auf jedem gegebene Elementknoten in einer Ereignisroute haben Klassenlistener die Möglichkeit, vor jedem Instanzlistener auf dem Element auf das Routingereignis zu reagieren. Aus diesem Grund werden Klassenhandler manchmal verwendet, um Routingereignisse zu unterdrücken, die von der Implementierung einer bestimmten Steuerelementklasse nicht weitergegeben werden sollen, oder um eine besondere Behandlung des Routingereignisses bereitzustellen, das eine Funktion der Klasse ist. Eine Klasse kann z.B. ein eigenes klassenspezifisches Ereignis auslösen, das weitere Details über die Bedeutung einer Benutzereingabebedingung im Kontext der jeweiligen Klasse enthält. Die Implementierung der Klasse kann das allgemeinere Routingereignis dann als behandelt markieren. Klassenhandler werden in der Regel so hinzugefügt, dass sie nicht für routingierte Ereignisse aufgerufen werden, bei <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> denen freigegebene Ereignisdaten bereits als behandelt markiert wurden, aber für atypische Fälle gibt es auch eine Signatur, die Klassenhandler registriert, die auch dann aufgerufen werden, wenn geroutete Ereignisse als behandelt markiert werden.  
  
### <a name="class-handler-virtuals"></a>Virtuelle Klassenhandler  
 Einige Elemente, insbesondere die <xref:System.Windows.UIElement>Basiselemente wie , machen leere virtuelle\*Methoden "On*Event" und "OnPreview-Ereignis" verfügbar, die ihrer Liste der öffentlichen Routingereignisse entsprechen. Diese virtuellen Methoden können überschrieben werden, um einen Klassenhandler für dieses Routingereignis zu implementieren. Die Basiselementklassen registrieren diese virtuellen Methoden als Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> für jedes solche geroutete Ereignis, das wie zuvor beschrieben verwendet wird. Die virtuellen On\*Event-Methoden vereinfachen die Implementierung der Klassenbehandlung für die relevanten Routingereignisse, ohne eine spezielle Initialisierung in statischen Konstruktoren für jeden Typ zu erfordern. Sie können z. B. <xref:System.Windows.UIElement.DragEnter> klassenbehandlung <xref:System.Windows.UIElement> für das Ereignis <xref:System.Windows.UIElement.OnDragEnter%2A> in jeder abgeleiteten Klasse hinzufügen, indem Sie die virtuelle Methode überschreiben. In der Überschreibung können Sie das Routingereignis behandeln, andere Ereignisse auslösen, klassenspezifische Logik initialisieren, die Elementeigenschaften für Instanzen ändern kann, oder jede beliebige Kombination dieser Aktionen ausführen. Sie sollten die Basisimplementierung solcher Überschreibungen generell aufrufen, selbst wenn Sie das Ereignis als behandelt markieren. Das Aufrufen der Basisimplementierung wird dringend empfohlen, da sich die virtuelle Methode in der Basisklasse befindet. Das geschützte virtuelle Standardmuster, bei dem die Basisimplementierungen aus jeder virtuellen Methode aufgerufen werden, ersetzt und entspricht einem ähnlichen Mechanismus, der nativ in der Klassenbehandlung von Routingereignissen vorkommt. Dabei werden Klassenhandler für alle Klassen in einer Klassenhierarchie auf jeder Instanz aufgerufen, beginnend mit dem Handler der am stärksten abgeleiteten Klasse und anschließend mit den Handlern der Basisklasse. Sie sollten den Aufruf der Basisimplementierung nur weglassen, wenn Ihre Klasse eine explizite Anforderung enthält, die Logik der Basisklassenbehandlung zu ändern. Es hängt von der Art Ihrer Implementierung ab, ob Sie die Basisimplementierung vor oder nach dem überschreibenden Code aufrufen.  
  
#### <a name="input-event-class-handling"></a>Klassenbehandlung von Eingabeereignissen  
 Virtuelle Methoden des Klassenhandlers werden alle so registriert, dass sie nur dann aufgerufen werden, wenn gemeinsam genutzte Ereignisdaten nicht bereits als behandelt markiert wurden. Außerdem werden nur bei Eingabeereignissen die Tunneling- und Bubblingversionen in der Regel nacheinander ausgelöst und verwenden dieselben Ereignisdaten. Dazu sollten Sie ein Ereignis für ein bestimmtes Paar von Eingabeereignis-Klassenhandlern, von denen einer die Tunneling-und der andere die Bubblingversion darstellt, nicht sofort als behandelt markieren. Wenn Sie die virtuelle Methode der Tunneling-Klassenbehandlung implementieren, um das Ereignis als behandelt zu markieren, wird der Bubbling-Klassenhandler daran gehindert, aufgerufen zu werden (außerdem wird verhindert, dass alle normal registrierten Instanzhandler für das Tunneling- oder das Bubblingereignis aufgerufen werden).  
  
 Nach Abschluss der Klassenbehandlung für einen Knoten werden die Instanzlistener berücksichtigt.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Hinzufügen von Instanzhandlern, die ausgelöst werden, obwohl Ereignisse als behandelt markiert wurden  
 Die <xref:System.Windows.UIElement.AddHandler%2A> Methode stellt eine bestimmte Überladung bereit, mit der Sie Handler hinzufügen können, die vom Ereignissystem aufgerufen werden, wenn ein Ereignis das Handlingelement in der Route erreicht, auch wenn ein anderer Handler die Ereignisdaten bereits angepasst hat, um dieses Ereignis als behandelt zu markieren. Dies wird in der Regel nicht ausgeführt. Ereignishandler können generell geschrieben werden, um alle Bereiche des Anwendungscodes anzupassen, die von einem Ereignis beeinflusst werden können, unabhängig davon, wo es in einer Elementstruktur behandelt wurde, auch wenn mehrere Ergebnisse gewünscht sind. Darüber hinaus gibt es in der Regel nur ein Element, das auf dieses Ereignis reagieren muss, und die entsprechende Anwendungslogik ist bereits geschehen. Für Ausnahmefälle steht die `handledEventsToo`-Überladung zur Verfügung, in der ein anderes Element in einer Elementstruktur oder Zusammensetzung von Steuerelementen ein Ereignis bereits als behandelt markiert hat, während andere, in der Elementstruktur höhere oder niedrigere Elemente (je nach Route) ihre eigenen Handler aber aufrufen möchten.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Markieren von behandelten Ereignisse als nicht behandelt  
 Im Allgemeinen sollten geroutete Ereignisse, die als behandelt<xref:System.Windows.RoutedEventArgs.Handled%2A> markiert `false`sind, nicht als nicht `handledEventsToo`behandelt markiert werden (zurückgesetzt auf ), auch nicht von Handlern, die auf . Allerdings haben einige Ereignisse Ereignisdarstellungen auf hoher und niedriger Ebene, die sich überlappen können, wenn das Ereignis auf höherer Ebene an einer Position in der Struktur und das Ereignis auf niedrigerer Ebene an einer anderen Position angezeigt wird. Betrachten Sie z. B. den Fall, dass ein untergeordnetes <xref:System.Windows.UIElement.TextInput> Element ein Schlüsselereignis auf hoher Ebene <xref:System.Windows.UIElement.KeyDown>abhört, z. B. während ein übergeordnetes Element ein Ereignis auf niedriger Ebene abhört, z. B. . Wenn das übergeordnete Element das Ereignis auf niedrigerer Ebene behandelt, kann das Ereignis auf höherer Ebene sogar im untergeordneten Element unterdrückt werden, das intuitiv als Erstes die Möglichkeit haben sollte, das Ereignis zu behandeln.  
  
 In diesen Situationen kann es erforderlich sein, für das Ereignis auf niedrigerer Ebene sowohl dem übergeordneten als auch dem untergeordneten Element Handler hinzuzufügen. Die Handlerimplementierung für das untergeordnete Element kann das Ereignis auf niedrigerer Ebene als behandelt markieren, aber die Handlerimplementierung des übergeordneten Elements würde dies wieder rückgängig machen, damit andere Elemente weiter oben in der Struktur (und das Ereignis auf höherer Ebene) die Möglichkeit haben, zu reagieren. Diese Situation ist aber relativ selten.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Beabsichtigtes Unterdrücken von Eingabeereignissen für die Zusammensetzung von Steuerelementen  
 Das Hauptszenario, in dem die Klassenbehandlung von Routingereignissen dazu verwendet wird, sind Eingabeereignisse und zusammengesetzte Steuerelemente. Ein zusammengesetztes Steuerelement besteht per definitionem aus mehreren praktischen Steuerelementen oder Steuerelement-Basisklassen. Häufig möchte der Autor des Steuerelements alle möglichen Eingabeereignisse verbinden, die von den einzelnen Unterkomponenten ausgelöst werden können, um das gesamte Steuerelement als Ereignisquelle zu melden. In einigen Fällen möchte der Autor des Steuerelements die Ereignisse von Komponenten möglicherweise vollständig unterdrücken oder ein komponentendefiniertes Ereignis ersetzen, das weitere Informationen enthält oder ein spezifischeres Verhalten impliziert. Das kanonische Beispiel, das für jeden Komponentenautor sofort sichtbar ist, ist, wie ein [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> Mausereignis <xref:System.Windows.Controls.Primitives.ButtonBase.Click> behandelt wird, das schließlich zu dem intuitiven Ereignis auflöst, das alle Schaltflächen haben: ein Ereignis.  
  
 Die <xref:System.Windows.Controls.Button> Basisklasse<xref:System.Windows.Controls.Primitives.ButtonBase>( ) <xref:System.Windows.Controls.Control> leitet sich von <xref:System.Windows.FrameworkElement> und <xref:System.Windows.UIElement>ab, und ein Großteil der Ereignisinfrastruktur, die <xref:System.Windows.UIElement> für die Eingabeverarbeitung benötigt wird, ist auf der Ebene verfügbar. Verarbeitet insbesondere <xref:System.Windows.UIElement> allgemeine <xref:System.Windows.Input.Mouse> Ereignisse, die Treffertests für den Mauszeiger innerhalb seiner Grenzen behandeln, und <xref:System.Windows.UIElement.MouseLeftButtonDown>stellt unterschiedliche Ereignisse für die gängigsten Schaltflächenaktionen bereit, z. B. . <xref:System.Windows.UIElement>stellt auch eine <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> leere virtuelle als <xref:System.Windows.UIElement.MouseLeftButtonDown>vorregistrierte <xref:System.Windows.Controls.Primitives.ButtonBase> Klassenhandler für bereit und überschreibt sie. In <xref:System.Windows.Controls.Primitives.ButtonBase> ähnlicher Weise werden <xref:System.Windows.UIElement.MouseLeftButtonUp>Klassenhandler für verwendet. In den Überschreibungen, die die Ereignisdaten übergeben <xref:System.Windows.RoutedEventArgs> werden, markieren <xref:System.Windows.RoutedEventArgs.Handled%2A> die `true`Implementierungen diese Instanz als durch Festlegen auf behandelt, und dieselben Ereignisdaten werden entlang des restlichen Weges zu anderen Klassenhandlern und auch zu Instanzhandlern oder Ereignissettern fortgesetzt. Außerdem wird <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> das <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis durch die Außerkraftsetzung als nächstes ausdemitagefahren. Das Endergebnis für die meisten <xref:System.Windows.UIElement.MouseLeftButtonDown> Listener wird sein, dass die und <xref:System.Windows.UIElement.MouseLeftButtonUp> Ereignisse "verschwinden" und stattdessen durch ersetzt werden, <xref:System.Windows.Controls.Primitives.ButtonBase.Click>ein Ereignis, das mehr Bedeutung hat, weil bekannt ist, dass dieses Ereignis von einer echten Schaltfläche und nicht von einem zusammengesetzten Teil der Schaltfläche oder von einem anderen Element vollständig stammt.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>
### <a name="working-around-event-suppression-by-controls"></a>Umgehen der Ereignisunterdrückung von Steuerelementen  
 Manchmal kann dieses Ereignis unterdrückende Verhalten in einzelnen Steuerelementen einige allgemeinere Absichten der Ereignisbehandlungslogik der Anwendung behindern. Wenn Ihre Anwendung z. B. aus <xref:System.Windows.UIElement.MouseLeftButtonDown> irgendeinem Grund über einen Handler für das Stammelement der <xref:System.Windows.UIElement.MouseLeftButtonDown> Anwendung <xref:System.Windows.UIElement.MouseLeftButtonUp> verfügt, würden Sie feststellen, dass ein Mausklick auf eine Schaltfläche keine Handler auf der Stammebene aufrufen oder handler. Das Ereignis selbst würde aufbubblen (wie gesagt, Ereignisroutes werden nicht tatsächlich beendet, das Routingereignissystem ändert nur deren Aufrufverhalten für Ereignishandler, nachdem sie als behandelt markiert wurden). Wenn das geroutete Ereignis <xref:System.Windows.Controls.Primitives.ButtonBase> die Schaltfläche <xref:System.Windows.UIElement.MouseLeftButtonDown> erreicht hat, markierte die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Klassenbehandlung den behandelten Wert, da es das Ereignis durch mehr Bedeutung ersetzen wollte. Daher wird <xref:System.Windows.UIElement.MouseLeftButtonDown> kein Standardhandler weiter oben auf der Route aufgerufen. Es gibt zwei Verfahren, mit denen Sie sicherzustellen können, dass die Handler unter diesen Umständen aufgerufen werden würden.  
  
 Die erste Technik besteht darin, `handledEventsToo` den <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>Handler absichtlich mithilfe der Signatur von hinzuzufügen. Dieses Verfahren zum Anhängen eines Ereignishandlers ist aber nur im Code und nicht in Markup möglich. Die einfache Syntax für die Angabe des Ereignishandlernamens als Ereignisattributwert über [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] ermöglicht dieses Verhalten nicht.  
  
 Das zweite Verfahren funktioniert nur für Eingabeereignisse, in denen die Tunneling- und Bubblingversionen des Routingereignisses kombiniert werden. Für diese Routingereignisse können Sie stattdessen der Vorschau-/Tunnelingversion des Routingereignisses Handler hinzufügen. Dieses Routingereignis tunnelt ausgehend vom Stamm durch die Route, damit der Code für die Behandlung der Schaltflächenklasse es nicht abfängt, vorausgesetzt, dass Sie den Vorschauhandler in einer Vorgängerebene in der Anwendungsstruktur angefügt haben. Wenn Sie diesen Ansatz verwenden, sollten Sie beim Markieren von Vorschauereignissen als behandelt vorsichtig vorgehen. Wenn Sie das <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> Ereignis in der Handlerimplementierung als in <xref:System.Windows.RoutedEventArgs.Handled%2A> der Handlerimplementierung markiert haben, <xref:System.Windows.Controls.Primitives.ButtonBase.Click> würden Sie das Ereignis tatsächlich unterdrücken, wenn Sie das Ereignis als in der Handlerimplementierung markiert haben. Dies ist in der Regel kein erwünschtes Verhalten.  
  
## <a name="see-also"></a>Weitere Informationen

- <xref:System.Windows.EventManager>
- [Vorschauereignisse](preview-events.md)
- [Erstellen eines benutzerdefinierten Routingereignisses](how-to-create-a-custom-routed-event.md)
- [Übersicht über Routingereignisse](routed-events-overview.md)
