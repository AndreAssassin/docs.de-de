---
title: Strukturen in WPF
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: 1b1763f2fcad60da757a3d6ff23dc289e7506ead
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/22/2019
ms.locfileid: "69966096"
---
# <a name="trees-in-wpf"></a>Strukturen in WPF
In vielen Technologien werden Elemente und Komponenten in einer Baumstruktur organisiert, in denen Entwickler die Objektknoten direkt in der Struktur bearbeiten, um das Rendering oder das Verhalten einer Anwendung zu beeinflussen. Außerdem verwendet [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] mehrere Baumstrukturmetaphern, um Beziehungen zwischen Programmelementen festzulegen. Da die WPF-Entwickler meist eine Anwendung im Code erstellen können oder Teile der Anwendung in XAML festlegen, obwohl sie konzeptionell über die Baumstrukturobjektmetapher denken, rufen sie trotzdem eine bestimmte API auf oder verwenden bestimmte Markups, um dies zu tun, anstatt einige allgemeine API-Strukturobjektmanipulationen vorzunehmen, wie Sie sie möglicherweise im XML-DOM verwenden. WPF macht zwei Hilfsklassen verfügbar, die eine Struktur-Metapher <xref:System.Windows.LogicalTreeHelper> - <xref:System.Windows.Media.VisualTreeHelper>Ansicht bereitstellen, und. Die Begriffe „visuelle Struktur“ und „logische Struktur“ werden auch in der WPF-Dokumentation verwendet, da diese Strukturen für das Verstehen des Verhaltens bestimmter WPF-Schlüsselfunktionen hilfreich sind. In diesem Thema wird definiert, was die visuelle Struktur und die logische Struktur darstellen. Außerdem wird erläutert, wie sich diese Strukturen auf ein <xref:System.Windows.LogicalTreeHelper> Allgemeines <xref:System.Windows.Media.VisualTreeHelper>Objektstruktur Konzept beziehen und und sind.  

<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a>Strukturen in WPF  
 Die umfassendste Struktur in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ist die Objektstruktur. Wenn Sie eine Anwendungsseite in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] festlegen und anschließend [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] laden, wird die Baumstruktur basierend auf den Schachtelungsbeziehungen der Elemente im Markup erstellt. Wenn Sie eine Anwendung oder einen Teil der Anwendung im Code festlegen, wird die Baumstruktur basierend darauf erstellt, wie Sie Eigenschaftswerte für Eigenschaften zuweisen, die das Inhaltsmodell für ein bestimmtes Objekt implementieren. In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] gibt es zwei Möglichkeiten, wie die vollständige Objektstruktur konzipiert wird und an die öffentliche API gemeldet werden kann: Als logische Struktur und als visuelle Struktur. Die Unterschiede zwischen logischer Struktur und visueller Struktur sind nicht immer unbedingt wichtig, aber sie können gelegentlich Probleme mit bestimmten [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Subsystemen verursachen und Auswählen im Markup oder im Code beeinträchtigen.  
  
 Obwohl Sie nicht immer die logische Struktur oder die visuelle Struktur direkt bearbeiten, ist das Verstehen der Konzepte, wie die Strukturen interagieren, nützlich, um WPF als eine Technologie zu verstehen. Sich WPF als eine Baumstrukturmetapher vorzustellen, ist auch wichtig, um zu verstehen, wie Eigenschaftsvererbung und Ereignisrouting in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] funktionieren.  
  
> [!NOTE]
> Da die Objektstruktur eher ein Konzept als eine tatsächliche API ist, ist es eine weitere Möglichkeit, sich das Konzept als Objektdiagramm vorzustellen. In der Praxis gibt es Beziehungen zwischen Objekten während der Laufzeit, die die Baumstrukturmetapher aufschlüsseln können. Trotzdem ist die Baumstrukturmetapher, insbesondere bei XAML-definierten Benutzeroberflächen, ausreichend relevant, sodass die meisten WPF-Dokumentationen den Begriff „Objektstruktur“ verwenden werden, wenn auf dieses allgemeine Konzept verwiesen wird.  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a>Die logische Struktur  
 In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fügen Sie Inhalte zu Benutzeroberflächenelementen hinzu, indem Sie Eigenschaften der Objekte festlegen, die diese Elemente unterstützen. Beispielsweise fügen Sie Elemente zu einem <xref:System.Windows.Controls.ListBox> Steuerelement hinzu, indem Sie die <xref:System.Windows.Controls.ItemsControl.Items%2A> zugehörige-Eigenschaft bearbeiten. Auf diese Weise platzieren Sie Elemente in der <xref:System.Windows.Controls.ItemCollection> , die den <xref:System.Windows.Controls.ItemsControl.Items%2A> Eigenschafts Wert ist. Entsprechend können Sie den <xref:System.Windows.Controls.DockPanel> <xref:System.Windows.Controls.Panel.Children%2A> Eigenschafts Wert bearbeiten, um einem Objekte hinzuzufügen. Hier fügen Sie-Objekte <xref:System.Windows.Controls.UIElementCollection>hinzu. Ein Codebeispiel finden [Sie unter Gewusst wie: Fügen Sie ein Element](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100))dynamisch hinzu.  
  
 Wenn [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]Sie in Listenelemente in einem-Steuer <xref:System.Windows.Controls.ListBox> Element oder einem-Steuerelement oder anderen <xref:System.Windows.Controls.DockPanel>Benutzeroberflächen Elementen in einer <xref:System.Windows.Controls.ItemsControl.Items%2A> platzieren <xref:System.Windows.Controls.Panel.Children%2A> , verwenden Sie die-Eigenschaft und die-Eigenschaft, entweder explizit oder implizit, wie im folgenden Beispiel gezeigt.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Wenn Sie diesen XAML-Code als XML unter einem Dokumentobjektmodell verarbeiten würden und die auskommentierten Tags als implizit eingeschlossen hätten (was zulässig gewesen wäre), hätte die entstandene XML-DOM-Struktur Elemente für `<ListBox.Items>` und für die anderen impliziten Elemente eingeschlossen. XAML verarbeitet jedoch nicht auf diese Weise, und wenn Sie das Markup lesen und in Objekte schreiben, enthält das daraus entstehende Objektdiagramm nicht wirklich `ListBox.Items`. Es verfügt jedoch über eine <xref:System.Windows.Controls.ListBox> Eigenschaft mit `Items` dem Namen, <xref:System.Windows.Controls.ItemCollection>die eine <xref:System.Windows.Controls.ItemCollection> enthält und initialisiert, aber leer ist <xref:System.Windows.Controls.ListBox> , wenn der XAML-Code verarbeitet wird. Dann wird jedes untergeordnete Objekt Element, das als Inhalt für <xref:System.Windows.Controls.ListBox> das vorhanden ist, <xref:System.Windows.Controls.ItemCollection> dem von Parser- `ItemCollection.Add`Aufrufen von hinzugefügt. Dieses Beispiel über die Verarbeitung von XAML in einer Objektstruktur ist bisher scheinbar ein Beispiel, bei dem die erstellte Objektstruktur im Grunde die logische Struktur ist.  
  
 Die logische Struktur ist jedoch nicht das gesamte Objektdiagramm, das für die Anwendungsbenutzeroberfläche zur Laufzeit vorhanden ist, dies gilt selbst wenn die impliziten XAML-Syntaxelemente nicht berücksichtigt werden. Der Hauptgrund dafür sind die visuellen Objekte und Vorlagen. Beispiel: <xref:System.Windows.Controls.Button>. Die logische Struktur meldet sowohl <xref:System.Windows.Controls.Button> das-Objekt als auch `Content`seine Zeichenfolge. Es gibt jedoch noch mehr zu dieser Schaltfläche in der Laufzeit-Objektstruktur. Insbesondere wird die Schaltfläche auf dem Bildschirm auf die gleiche Weise wie möglich angezeigt <xref:System.Windows.Controls.Button> , weil eine bestimmte Steuerelement Vorlage angewendet wurde. Die visuellen Elemente, die aus einer angewendeten Vorlage stammen (z. <xref:System.Windows.Controls.Border> b. die durch die Vorlage definierte, dunkelgraue um die visuelle Schaltfläche), werden nicht in der logischen Struktur angezeigt, auch wenn Sie die logische Struktur zur Laufzeit betrachten (z. b. das Behandeln eines Eingabe Ereignisses aus dem sichtbare Benutzeroberfläche und anschließendes Lesen der logischen Struktur). Sie müssten stattdessen die visuelle Struktur untersuchen, um die visuellen Vorlagen zu suchen.  
  
 Weitere Informationen dazu, wie die [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]-Syntax das erstellte Objektdiagramm sowie die implizite Syntax in XAML zuordnet, finden Sie unter [Ausführliche Erläuterung der XAML-Syntax](xaml-syntax-in-detail.md) oder [Übersicht über XAML (WPF)](xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a>Der Zweck der logischen Struktur  
 Die logische Struktur ist vorhanden, damit Inhaltsmodelle ihre potenziellen untergeordneten Objekte leicht durchlaufen können und damit Inhaltsmodelle erweiterbar sind. Darüber hinaus bietet die logische Struktur ein Framework für bestimmte Benachrichtigungen, z.B. wenn alle Objekte in der logischen Struktur geladen werden. Im Grunde ist die logische Struktur eine Annäherung an ein Laufzeit-Objektdiagramm auf der Frameworkebene, das visuelle Elemente ausschließt, aber für viele Abfragevorgänge für Ihre eigene Laufzeit-Anwendungskomposition ausreichend ist.  
  
 Außerdem werden sowohl statische als auch dynamische Ressourcen Verweise aufgelöst, indem die logische <xref:System.Windows.FrameworkElement.Resources%2A> Struktur nach Auflistungen auf dem ersten anfordernden Objekt durchsucht wird, und dann die logische Struktur fortgesetzt und jede <xref:System.Windows.FrameworkElement> (oder <xref:System.Windows.FrameworkContentElement>) für einen `Resources` anderen Wert, der <xref:System.Windows.ResourceDictionary>einen enthält, der möglicherweise den Schlüssel enthält. Die logische Struktur wird für die Ressourcensuche verwendet, wenn sowohl die logische Struktur als auch die visuelle Struktur vorhanden sind. Weitere Informationen zu Ressourcenwörterbüchern und der Suche finden Sie unter [XAML-Ressourcen](xaml-resources.md).  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a>Zusammensetzung der logischen Struktur  
 Die logische Struktur wird auf der WPF-Frameworkebene definiert. Dies bedeutet, dass das WPF-Basiselement, das für logische Struktur Vorgänge <xref:System.Windows.FrameworkElement> am <xref:System.Windows.FrameworkContentElement>relevantesten ist, entweder oder ist. Wie Sie jedoch sehen können, wenn Sie tatsächlich die <xref:System.Windows.LogicalTreeHelper> API verwenden, enthält die logische Struktur manchmal Knoten, die weder <xref:System.Windows.FrameworkElement> noch <xref:System.Windows.FrameworkContentElement>sind. Die logische Struktur meldet z. b. <xref:System.Windows.Controls.TextBlock.Text%2A> den Wert einer <xref:System.Windows.Controls.TextBlock>, bei der es sich um eine Zeichenfolge handelt.  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a>Überschreiben der logischen Struktur  
 Autoren von erweiterten Steuerelementen können die logische Struktur überschreiben, indem Sie mehrere APIs überschreiben, die definieren, wie ein allgemeines Objekt oder Inhalts Modell Objekte innerhalb der logischen Struktur hinzufügt oder entfernt. Ein Beispiel zum Überschreiben der logischen Struktur finden Sie unter [Überschreiben der logischen Struktur](how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a>Vererbung von Eigenschaftswerten  
 Die Vererbung von Eigenschaftswerten funktioniert mithilfe einer Hybridstruktur. Die eigentlichen Metadaten, die die <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> Eigenschaft enthalten, die die Eigenschafts Vererbung ermöglicht, sind <xref:System.Windows.FrameworkPropertyMetadata> die WPF-Frameworkebene. Daher müssen sowohl das übergeordnete Element, das den ursprünglichen Wert enthält, als auch das untergeordnete Objekt, das <xref:System.Windows.FrameworkElement> diesen <xref:System.Windows.FrameworkContentElement>Wert erbt, oder sein, und beide müssen Teil einer logischen Struktur sein. Allerdings kann für vorhandene WPF-Eigenschaften, die die Vererbung von Eigenschaften unterstützen, die Vererbung von Eigenschaftswerten durch ein beteiligtes Objekt aufrechterhalten werden, das nicht in der logischen Struktur ist. Dies ist vor allem relevant, wenn Vorlagenelemente alle geerbten Eigenschaftswerte verwenden, die entweder auf die Instanz festgelegt wurden, die als Vorlage verwendet wird, oder auf noch höheren Ebenen der Seitenebenen-Zusammensetzung und aus diesem Grund höher in der logischen Struktur sind. Damit die Vererbung von Eigenschaftswerten über eine solche Grenze hinweg konsistent funktioniert, muss die erbende Eigenschaft als angefügte Eigenschaft registriert werden, und Sie sollten dieses Muster befolgen, wenn Sie beabsichtigen, eine benutzerdefinierte Abhängigkeitseigenschaft mit Eigenschaftenvererbungsverhalten festzulegen. Die genaue Struktur, die für die Vererbung von Eigenschaften verwendet wurde, kann nicht vollständig von einer Hilfsprogrammklassen-Dienstmethode vorhergesehen werden, dies gilt selbst während der Laufzeit. Weitere Informationen finden Sie unter [ Vererbung von Eigenschaftswerten](property-value-inheritance.md).  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a>Die visuelle Struktur  
 Neben dem Konzept der logischen Struktur, gibt es auch das Konzept der visuellen Struktur in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Die visuelle Struktur beschreibt die Struktur von visuellen Objekten, wie von der <xref:System.Windows.Media.Visual> -Basisklasse dargestellt. Wenn Sie eine Vorlage für ein Steuerelement erstellen, werden Sie die visuelle Struktur festlegen oder neu festlegen, die für dieses Steuerelement angewendet wird. Die visuelle Struktur ist auch für Entwickler interessant, die die Kontrolle über Zeichnungen auf niedrigerer Ebene aus Leistungs- und Optimierungsgründen möchten. Eine Belichtung der visuellen Struktur als Teil der konventionellen [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Programmierschnittstellen ist, dass das Ereignis für ein Routingereignis größtenteils entlang der visuellen Struktur steuert, nicht aber entlang der logischen Struktur. Diese Besonderheit des Routingereignisverhaltens ist möglicherweise nicht sofort erkennbar, es sei denn, Sie sind ein Autor des Steuerelements. Routingereignisse über die visuelle Struktur ermöglichen Steuerelemente, die die Komposition auf der visuellen Ebene implementieren, um Ereignisse zu bearbeiten oder Ereignissetter zu erstellen.  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a>Strukturen, Inhaltselemente und Inhaltshosts  
 Inhaltselemente (Klassen, die von <xref:System.Windows.ContentElement>abgeleitet werden) sind nicht Teil der visuellen Struktur; Sie erben nicht von <xref:System.Windows.Media.Visual> und verfügen nicht über eine visuelle Darstellung. Um überhaupt in einer Benutzeroberfläche angezeigt zu werden, muss <xref:System.Windows.ContentElement> ein in einem Inhalts Host gehostet werden, der sowohl ein <xref:System.Windows.Media.Visual> als auch ein logischer Struktur Teilnehmer ist. Normalerweise ist ein solches Objekt <xref:System.Windows.FrameworkElement>ein. Sie können konzipieren, dass der Inhaltshost wie ein „Browser“ für den Inhalt ist und wählt, wie der Inhalt innerhalb des Bildschirmbereichs, den der Host steuert, anzuzeigen ist. Wenn der Inhalt gehostet wird, kann der Inhalt zu einem Teilnehmer bestimmter Prozessstrukturen gemacht werden, die normalerweise der visuellen Struktur zugeordnet sind. Im Allgemeinen enthält <xref:System.Windows.FrameworkElement> die Host Klasse Implementierungs Code, der alle gehosteten <xref:System.Windows.ContentElement> der Ereignis Route durch untergeordnete Knoten der logischen Inhaltsstruktur hinzufügt, auch wenn der gehostete Inhalt nicht Teil der echten visuellen Struktur ist. Dies ist erforderlich, damit eine <xref:System.Windows.ContentElement> ein Routing Ereignis, das an ein beliebiges Element weiterleitet, an sich selbst weiterleiten kann.  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a>Traversierung der Struktur  
 Die <xref:System.Windows.LogicalTreeHelper> -Klasse stellt <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>die <xref:System.Windows.LogicalTreeHelper.GetParent%2A>Methoden, <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> und für die Durchquerung der logischen Struktur bereit. In den meisten Fällen sollte Sie nicht die logische Struktur von vorhandenen Steuerelementen durchlaufen müssen, da diese Steuerelemente fast immer ihre logisch untergeordneten Elemente als dedizierte Auflistungseigenschaft verfügbar machen, die Auflistungszugriff, wie z.B. `Add`, einen Indexer und so weiter, unterstützt. Die Struktur Traversierung ist hauptsächlich ein Szenario, das von Steuerelement Autoren verwendet wird, die sich nicht von beabsichtigten <xref:System.Windows.Controls.ItemsControl> Steuerungs <xref:System.Windows.Controls.Panel> Mustern ableiten lassen, wie z. b. oder wenn Sammlungs Eigenschaften bereits definiert sind und eine eigene Sammlung bereitstellen möchten. Eigenschafts Unterstützung.  
  
 Die visuelle Struktur unterstützt auch eine Hilfsklasse für den visuellen Struktur Durchlauf <xref:System.Windows.Media.VisualTreeHelper>,. Die visuelle Struktur ist nicht so einfach wie Steuerelement spezifische Eigenschaften verfügbar. Daher ist <xref:System.Windows.Media.VisualTreeHelper> die Klasse die empfohlene Methode, um die visuelle Struktur zu durchlaufen, wenn dies für das Programmier Szenario erforderlich ist. Weitere Informationen finden Sie unter [Übersicht über das WPF-Grafikenrendering](../graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
> Manchmal ist es notwendig, die visuelle Struktur einer angewendeten Vorlage zu untersuchen. Gehen Sie bei dieser Technik vorsichtig vor. Auch wenn Sie eine visuelle Struktur für ein Steuerelement durchlaufen, in dem Sie die Vorlage definieren, können Consumer Ihres Steuer Elements die Vorlage jederzeit ändern, <xref:System.Windows.Controls.Control.Template%2A> indem Sie die-Eigenschaft für Instanzen festlegen, und sogar der Endbenutzer kann die angewendete Vorlage beeinflussen, indem Sie das Systemdesign.  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a>Routen für Routingereignisse als „Struktur“  
 Wie bereits erwähnt, durchläuft die Route aller angegebenen Routingereignisse entlang eines einzelnen und vordefinierten Pfads einer Struktur, die eine Mischung aus den Darstellungen visueller und logischer Strukturen ist. Die Ereignisroute kann innerhalb der Struktur nach oben oder nach unten passieren, je nachdem, ob es ein Tunnel- oder Bubbling-Routingereignis ist. Das Konzept der Ereignisroute hat keine direkt unterstützende Hilfsprogrammklasse, die verwendet werden kann, um die Ereignisroute unabhängig vom Auslösen eines Ereignisses, das tatsächlich weiterleitet, zu „durchlaufen“. Es gibt eine Klasse, die die Route <xref:System.Windows.EventRoute>darstellt, aber die Methoden dieser Klasse sind im Allgemeinen nur für die interne Verwendung vorgesehen.  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a>Ressourcenwörterbücher und Strukturen  
 Wörterbuchressourcensuche für alle `Resources`, die auf einer Seite festgelegt sind, durchlaufen im Grunde die logische Struktur. Objekte, die nicht in der logischen Struktur sind, können auf verschlüsselte Ressourcen verweisen, aber die Ressourcensuchsequenz beginnt an dem Punkt, an dem das Objekt mit der logischen Struktur verbunden ist. In WPF können nur logische Struktur Knoten über eine `Resources` Eigenschaft verfügen, die eine <xref:System.Windows.ResourceDictionary>enthält. aus diesem Grund gibt es keinen Vorteil beim Durchlaufen der visuellen Struktur, die nach Schlüssel gebundenen Ressourcen von einem <xref:System.Windows.ResourceDictionary>sucht.  
  
 Die Ressourcensuche kann jedoch auch über die unmittelbare logische Struktur hinaus erweitert werden. Bei Anwendungsmarkups kann die Ressourcensuche auf Anwendungsebene von Ressourcenwörterbüchern weitergeführt werden, und anschließend bei der Designunterstützung und den Systemwerten fortgesetzt werden, die als statische Eigenschaften oder Schlüssel referenziert werden. Designs selbst können auch auf Systemwerte außerhalb der logischen Struktur des Designs verweisen, wenn die Ressourcenverweise dynamisch sind. Weitere Informationen zu Ressourcenwörterbüchern und der Suchlogik, finden Sie unter [XAML-Ressourcen](xaml-resources.md).  
  
## <a name="see-also"></a>Siehe auch

- [Übersicht über die Eingabe](input-overview.md)
- [Übersicht über das WPF-Grafikrendering](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [Übersicht über Routingereignisse](routed-events-overview.md)
- [Initialisierung für Objektelemente außerhalb einer Objektstruktur](initialization-for-object-elements-not-in-an-object-tree.md)
- [WPF-Architektur](wpf-architecture.md)
