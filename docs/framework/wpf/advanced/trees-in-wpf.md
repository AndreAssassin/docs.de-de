---
title: Strukturen in WPF
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: 0dfae3a601a07c68b2dfe029f061dcf838e98af7
ms.sourcegitcommit: 944ddc52b7f2632f30c668815f92b378efd38eea
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/03/2019
ms.locfileid: "73459496"
---
# <a name="trees-in-wpf"></a>Strukturen in WPF
In vielen Technologien werden Elemente und Komponenten in einer Baumstruktur organisiert, in denen Entwickler die Objektknoten direkt in der Struktur bearbeiten, um das Rendering oder das Verhalten einer Anwendung zu beeinflussen. Außerdem verwendet [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] mehrere Baumstrukturmetaphern, um Beziehungen zwischen Programmelementen festzulegen. Da die WPF-Entwickler meist eine Anwendung im Code erstellen können oder Teile der Anwendung in XAML festlegen, obwohl sie konzeptionell über die Baumstrukturobjektmetapher denken, rufen sie trotzdem eine bestimmte API auf oder verwenden bestimmte Markups, um dies zu tun, anstatt einige allgemeine API-Strukturobjektmanipulationen vorzunehmen, wie Sie sie möglicherweise im XML-DOM verwenden. WPF macht zwei Hilfsklassen verfügbar, die eine Struktur-Metapher-Ansicht, <xref:System.Windows.LogicalTreeHelper> und <xref:System.Windows.Media.VisualTreeHelper>bereitstellen. Die Begriffe „visuelle Struktur“ und „logische Struktur“ werden auch in der WPF-Dokumentation verwendet, da diese Strukturen für das Verstehen des Verhaltens bestimmter WPF-Schlüsselfunktionen hilfreich sind. In diesem Thema wird definiert, was die visuelle Struktur und die logische Struktur darstellen. Außerdem wird erläutert, wie sich diese Strukturen auf ein allgemeines Objektstruktur Konzept beziehen, und es werden <xref:System.Windows.LogicalTreeHelper> und <xref:System.Windows.Media.VisualTreeHelper>s eingeführt.  

<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a>Strukturen in WPF  
 Die umfassendste Struktur in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ist die Objektstruktur. Wenn Sie eine Anwendungsseite in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] festlegen und anschließend [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] laden, wird die Baumstruktur basierend auf den Schachtelungsbeziehungen der Elemente im Markup erstellt. Wenn Sie eine Anwendung oder einen Teil der Anwendung im Code festlegen, wird die Baumstruktur basierend darauf erstellt, wie Sie Eigenschaftswerte für Eigenschaften zuweisen, die das Inhaltsmodell für ein bestimmtes Objekt implementieren. In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] gibt es zwei Möglichkeiten, wie die vollständige Objektstruktur konzipiert wird und an die öffentliche API gemeldet werden kann: Als logische Struktur und als visuelle Struktur. Die Unterschiede zwischen logischer Struktur und visueller Struktur sind nicht immer unbedingt wichtig, aber sie können gelegentlich Probleme mit bestimmten [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Subsystemen verursachen und Auswählen im Markup oder im Code beeinträchtigen.  
  
 Obwohl Sie nicht immer die logische Struktur oder die visuelle Struktur direkt bearbeiten, ist das Verstehen der Konzepte, wie die Strukturen interagieren, nützlich, um WPF als eine Technologie zu verstehen. Sich WPF als eine Baumstrukturmetapher vorzustellen, ist auch wichtig, um zu verstehen, wie Eigenschaftsvererbung und Ereignisrouting in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] funktionieren.  
  
> [!NOTE]
> Da die Objektstruktur eher ein Konzept als eine tatsächliche API ist, ist es eine weitere Möglichkeit, sich das Konzept als Objektdiagramm vorzustellen. In der Praxis gibt es Beziehungen zwischen Objekten während der Laufzeit, die die Baumstrukturmetapher aufschlüsseln können. Trotzdem ist die Baumstrukturmetapher, insbesondere bei XAML-definierten Benutzeroberflächen, ausreichend relevant, sodass die meisten WPF-Dokumentationen den Begriff „Objektstruktur“ verwenden werden, wenn auf dieses allgemeine Konzept verwiesen wird.  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a>Die logische Struktur  
 In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fügen Sie Inhalte zu Benutzeroberflächenelementen hinzu, indem Sie Eigenschaften der Objekte festlegen, die diese Elemente unterstützen. Beispielsweise fügen Sie Elemente zu einem <xref:System.Windows.Controls.ListBox>-Steuerelement hinzu, indem Sie dessen <xref:System.Windows.Controls.ItemsControl.Items%2A>-Eigenschaft bearbeiten. Auf diese Weise platzieren Sie Elemente in der <xref:System.Windows.Controls.ItemCollection>, die den <xref:System.Windows.Controls.ItemsControl.Items%2A>-Eigenschafts Wert ist. Wenn Sie einer <xref:System.Windows.Controls.DockPanel>Objekte hinzufügen möchten, ändern Sie den Wert der <xref:System.Windows.Controls.Panel.Children%2A>-Eigenschaft. Hier fügen Sie dem <xref:System.Windows.Controls.UIElementCollection>Objekte hinzu. Ein Codebeispiel finden Sie unter Gewusst [wie: Dynamisches Hinzufügen eines Elements](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).  
  
 Wenn Sie in [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]Listenelemente in einem <xref:System.Windows.Controls.ListBox> oder Steuerelementen oder anderen Benutzeroberflächen Elementen in einem <xref:System.Windows.Controls.DockPanel>platzieren, verwenden Sie die Eigenschaften <xref:System.Windows.Controls.ItemsControl.Items%2A> und <xref:System.Windows.Controls.Panel.Children%2A> entweder explizit oder implizit, wie im folgenden Beispiel gezeigt.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Wenn Sie diesen XAML-Code als XML unter einem Dokumentobjektmodell verarbeiten würden und die auskommentierten Tags als implizit eingeschlossen hätten (was zulässig gewesen wäre), hätte die entstandene XML-DOM-Struktur Elemente für `<ListBox.Items>` und für die anderen impliziten Elemente eingeschlossen. XAML verarbeitet jedoch nicht auf diese Weise, und wenn Sie das Markup lesen und in Objekte schreiben, enthält das daraus entstehende Objektdiagramm nicht wirklich `ListBox.Items`. Es verfügt jedoch über eine <xref:System.Windows.Controls.ListBox>-Eigenschaft mit dem Namen `Items`, die einen <xref:System.Windows.Controls.ItemCollection>enthält, und dass <xref:System.Windows.Controls.ItemCollection> initialisiert, aber leer ist, wenn die <xref:System.Windows.Controls.ListBox> XAML verarbeitet wird. Dann wird jedes untergeordnete Objekt Element, das als Inhalt für den <xref:System.Windows.Controls.ListBox> vorhanden ist, der <xref:System.Windows.Controls.ItemCollection> von Parser-aufrufen `ItemCollection.Add`hinzugefügt. Dieses Beispiel über die Verarbeitung von XAML in einer Objektstruktur ist bisher scheinbar ein Beispiel, bei dem die erstellte Objektstruktur im Grunde die logische Struktur ist.  
  
 Die logische Struktur ist jedoch nicht das gesamte Objekt Diagramm, das für die Benutzeroberfläche Ihrer Anwendung zur Laufzeit vorhanden ist, auch wenn die impliziten XAML-Syntax Elemente berücksichtigt werden. Der Hauptgrund hierfür sind visuelle Elemente und Vorlagen. Sehen Sie sich beispielsweise den <xref:System.Windows.Controls.Button>an. Die logische Struktur meldet das <xref:System.Windows.Controls.Button> Objekt und seine Zeichenfolge `Content`. Es gibt jedoch noch mehr zu dieser Schaltfläche in der Laufzeit-Objektstruktur. Insbesondere wird die Schaltfläche auf dem Bildschirm auf die gleiche Weise angezeigt, weil eine bestimmte <xref:System.Windows.Controls.Button> Steuerelement Vorlage angewendet wurde. Die visuellen Elemente, die aus einer angewendeten Vorlage stammen (z. b. das Vorlagen definierte <xref:System.Windows.Controls.Border> dunkelgrau um die visuelle Schaltfläche), werden nicht in der logischen Struktur angezeigt, auch wenn Sie die logische Struktur zur Laufzeit betrachten (z. b. das Behandeln eines Eingabe Ereignisses aus dem sichtbare Benutzeroberfläche und anschließendes Lesen der logischen Struktur). Sie müssten stattdessen die visuelle Struktur untersuchen, um die visuellen Vorlagen zu suchen.  
  
 Weitere Informationen dazu, wie die [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]-Syntax das erstellte Objektdiagramm sowie die implizite Syntax in XAML zuordnet, finden Sie unter [Ausführliche Erläuterung der XAML-Syntax](xaml-syntax-in-detail.md) oder [Übersicht über XAML (WPF)](xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a>Der Zweck der logischen Struktur  
 Die logische Struktur ist vorhanden, damit Inhaltsmodelle ihre potenziellen untergeordneten Objekte leicht durchlaufen können und damit Inhaltsmodelle erweiterbar sind. Darüber hinaus bietet die logische Struktur ein Framework für bestimmte Benachrichtigungen, z.B. wenn alle Objekte in der logischen Struktur geladen werden. Im Grunde ist die logische Struktur eine Annäherung an ein Laufzeit-Objektdiagramm auf der Frameworkebene, das visuelle Elemente ausschließt, aber für viele Abfragevorgänge für Ihre eigene Laufzeit-Anwendungskomposition ausreichend ist.  
  
 Außerdem werden sowohl statische als auch dynamische Ressourcen Verweise aufgelöst, indem die logische Struktur nach oben durchsucht wird, um <xref:System.Windows.FrameworkElement.Resources%2A> Auflistungen auf dem ersten anfordernden Objekt Auflistungen durchzuführen. Anschließend wird die logische Struktur fortgesetzt, und jede <xref:System.Windows.FrameworkElement> (oder <xref:System.Windows.FrameworkContentElement>) wird geprüft. ein weiterer `Resources` Wert, der eine <xref:System.Windows.ResourceDictionary>enthält, die möglicherweise den Schlüssel enthält. Die logische Struktur wird für die Ressourcensuche verwendet, wenn sowohl die logische Struktur als auch die visuelle Struktur vorhanden sind. Weitere Informationen zu Ressourcenwörterbüchern und der Suche finden Sie unter [XAML-Ressourcen](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a>Zusammensetzung der logischen Struktur  
 Die logische Struktur wird auf der WPF-Frameworkebene definiert. Dies bedeutet, dass das WPF-Basiselement, das für logische Struktur Vorgänge am relevantesten ist, entweder <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement>ist. Wie Sie jedoch sehen können, wenn Sie die <xref:System.Windows.LogicalTreeHelper>-API tatsächlich verwenden, enthält die logische Struktur manchmal Knoten, die weder <xref:System.Windows.FrameworkElement> noch <xref:System.Windows.FrameworkContentElement>sind. Die logische Struktur meldet z. b. den <xref:System.Windows.Controls.TextBlock.Text%2A> Wert eines <xref:System.Windows.Controls.TextBlock>, bei dem es sich um eine Zeichenfolge handelt.  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a>Überschreiben der logischen Struktur  
 Autoren von erweiterten Steuerelementen können die logische Struktur überschreiben, indem Sie mehrere APIs überschreiben, die definieren, wie ein allgemeines Objekt oder Inhalts Modell Objekte innerhalb der logischen Struktur hinzufügt oder entfernt. Ein Beispiel zum Überschreiben der logischen Struktur finden Sie unter [Überschreiben der logischen Struktur](how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a>Vererbung von Eigenschaftswerten  
 Die Vererbung von Eigenschaftswerten funktioniert mithilfe einer Hybridstruktur. Die eigentlichen Metadaten, die die <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> Eigenschaft enthalten, die die Vererbung von Eigenschaften ermöglicht, ist die <xref:System.Windows.FrameworkPropertyMetadata> Klasse auf WPF-Frameworkebene Daher müssen sowohl das übergeordnete Element, das den ursprünglichen Wert enthält, als auch das untergeordnete Objekt, das diesen Wert erbt, <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement>sein, und beide müssen Teil einer logischen Struktur sein. Allerdings kann für vorhandene WPF-Eigenschaften, die die Vererbung von Eigenschaften unterstützen, die Vererbung von Eigenschaftswerten durch ein beteiligtes Objekt aufrechterhalten werden, das nicht in der logischen Struktur ist. Dies ist vor allem relevant, wenn Vorlagenelemente alle geerbten Eigenschaftswerte verwenden, die entweder auf die Instanz festgelegt wurden, die als Vorlage verwendet wird, oder auf noch höheren Ebenen der Seitenebenen-Zusammensetzung und aus diesem Grund höher in der logischen Struktur sind. Damit die Vererbung von Eigenschaftswerten über eine solche Grenze hinweg konsistent funktioniert, muss die erbende Eigenschaft als angefügte Eigenschaft registriert werden, und Sie sollten dieses Muster befolgen, wenn Sie beabsichtigen, eine benutzerdefinierte Abhängigkeitseigenschaft mit Eigenschaftenvererbungsverhalten festzulegen. Die genaue Struktur, die für die Vererbung von Eigenschaften verwendet wurde, kann nicht vollständig von einer Hilfsprogrammklassen-Dienstmethode vorhergesehen werden, dies gilt selbst während der Laufzeit. Weitere Informationen finden Sie unter [ Vererbung von Eigenschaftswerten](property-value-inheritance.md).  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a>Die visuelle Struktur  
 Neben dem Konzept der logischen Struktur, gibt es auch das Konzept der visuellen Struktur in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Die visuelle Struktur beschreibt die Struktur von visuellen Objekten, wie durch die <xref:System.Windows.Media.Visual> Basisklasse dargestellt. Wenn Sie eine Vorlage für ein Steuerelement erstellen, werden Sie die visuelle Struktur festlegen oder neu festlegen, die für dieses Steuerelement angewendet wird. Die visuelle Struktur ist auch für Entwickler interessant, die die Kontrolle über Zeichnungen auf niedrigerer Ebene aus Leistungs- und Optimierungsgründen möchten. Eine Belichtung der visuellen Struktur als Teil der konventionellen [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Programmierschnittstellen ist, dass das Ereignis für ein Routingereignis größtenteils entlang der visuellen Struktur steuert, nicht aber entlang der logischen Struktur. Diese Besonderheit des Routingereignisverhaltens ist möglicherweise nicht sofort erkennbar, es sei denn, Sie sind ein Autor des Steuerelements. Routingereignisse über die visuelle Struktur ermöglichen Steuerelemente, die die Komposition auf der visuellen Ebene implementieren, um Ereignisse zu bearbeiten oder Ereignissetter zu erstellen.  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a>Strukturen, Inhaltselemente und Inhaltshosts  
 Inhaltselemente (Klassen, die von <xref:System.Windows.ContentElement>abgeleitet sind) sind nicht Teil der visuellen Struktur. Sie erben nicht von <xref:System.Windows.Media.Visual> und verfügen nicht über eine visuelle Darstellung. Um überhaupt in einer Benutzeroberfläche angezeigt zu werden, muss ein <xref:System.Windows.ContentElement> in einem Inhalts Host gehostet werden, der sowohl ein <xref:System.Windows.Media.Visual> als auch ein logischer Struktur Teilnehmer ist. In der Regel ist ein solches Objekt eine <xref:System.Windows.FrameworkElement>. Sie können konzipieren, dass der Inhaltshost wie ein „Browser“ für den Inhalt ist und wählt, wie der Inhalt innerhalb des Bildschirmbereichs, den der Host steuert, anzuzeigen ist. Wenn der Inhalt gehostet wird, kann der Inhalt zu einem Teilnehmer bestimmter Prozessstrukturen gemacht werden, die normalerweise der visuellen Struktur zugeordnet sind. In der Regel enthält die <xref:System.Windows.FrameworkElement> Host Klasse Implementierungs Code, der alle gehosteten <xref:System.Windows.ContentElement> der Ereignis Route über die untergeordneten Knoten der logischen Inhaltsstruktur hinzufügt, auch wenn der gehostete Inhalt nicht Teil der echten visuellen Struktur ist. Dies ist erforderlich, damit ein <xref:System.Windows.ContentElement> ein Routing Ereignis, das an ein beliebiges Element weiterleitet, an sich selbst weiterleiten kann.  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a>Traversierung der Struktur  
 Die <xref:System.Windows.LogicalTreeHelper>-Klasse stellt die Methoden <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>und <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> für die Durchquerung logischer Strukturen bereit. In den meisten Fällen sollte Sie nicht die logische Struktur von vorhandenen Steuerelementen durchlaufen müssen, da diese Steuerelemente fast immer ihre logisch untergeordneten Elemente als dedizierte Auflistungseigenschaft verfügbar machen, die Auflistungszugriff, wie z.B. `Add`, einen Indexer und so weiter, unterstützt. Der Struktur Durchlauf ist hauptsächlich ein Szenario, das von Steuerelement Autoren verwendet wird, die sich nicht von beabsichtigten Steuerungs Mustern ableiten lassen, wie z. b. <xref:System.Windows.Controls.ItemsControl> oder <xref:System.Windows.Controls.Panel>, in denen Sammlungs Eigenschaften bereits definiert sind und die eine eigene Sammlungs Eigenschaft bereitstellen möchten. Förder.  
  
 Die visuelle Struktur unterstützt auch eine Hilfsklasse für den <xref:System.Windows.Media.VisualTreeHelper>der visuellen Struktur. Die visuelle Struktur ist nicht so einfach wie Steuerelement spezifische Eigenschaften verfügbar. Daher ist die <xref:System.Windows.Media.VisualTreeHelper> Klasse die empfohlene Methode, um die visuelle Struktur zu durchlaufen, wenn dies für das Programmier Szenario erforderlich ist. Weitere Informationen finden Sie unter [Übersicht über das WPF-Grafikrendering](../graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
> Manchmal ist es notwendig, die visuelle Struktur einer angewendeten Vorlage zu untersuchen. Gehen Sie bei dieser Technik vorsichtig vor. Auch wenn Sie eine visuelle Struktur für ein Steuerelement durchlaufen, in dem Sie die Vorlage definieren, können Consumer Ihres Steuer Elements die Vorlage jederzeit ändern, indem Sie die <xref:System.Windows.Controls.Control.Template%2A>-Eigenschaft für Instanzen festlegen, und sogar der Endbenutzer kann die angewendete Vorlage durch Ändern des Systems beeinflussen. Titel.  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a>Routen für Routingereignisse als „Struktur“  
 Wie bereits erwähnt, durchläuft die Route aller angegebenen Routingereignisse entlang eines einzelnen und vordefinierten Pfads einer Struktur, die eine Mischung aus den Darstellungen visueller und logischer Strukturen ist. Die Ereignisroute kann innerhalb der Struktur nach oben oder nach unten passieren, je nachdem, ob es ein Tunnel- oder Bubbling-Routingereignis ist. Das Konzept der Ereignisroute hat keine direkt unterstützende Hilfsprogrammklasse, die verwendet werden kann, um die Ereignisroute unabhängig vom Auslösen eines Ereignisses, das tatsächlich weiterleitet, zu „durchlaufen“. Es gibt eine Klasse, die die Route darstellt, <xref:System.Windows.EventRoute>, aber die Methoden dieser Klasse sind im Allgemeinen nur für die interne Verwendung vorgesehen.  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a>Ressourcenwörterbücher und Strukturen  
 Wörterbuchressourcensuche für alle `Resources`, die auf einer Seite festgelegt sind, durchlaufen im Grunde die logische Struktur. Objekte, die nicht in der logischen Struktur sind, können auf verschlüsselte Ressourcen verweisen, aber die Ressourcensuchsequenz beginnt an dem Punkt, an dem das Objekt mit der logischen Struktur verbunden ist. In WPF können nur logische Struktur Knoten über eine `Resources`-Eigenschaft verfügen, die einen <xref:System.Windows.ResourceDictionary>enthält. aus diesem Grund besteht kein Vorteil beim Durchlaufen der visuellen Struktur, die nach Schlüssel gebundenen Ressourcen aus einer <xref:System.Windows.ResourceDictionary>sucht.  
  
 Die Ressourcensuche kann jedoch auch über die unmittelbare logische Struktur hinaus erweitert werden. Bei Anwendungsmarkups kann die Ressourcensuche auf Anwendungsebene von Ressourcenwörterbüchern weitergeführt werden, und anschließend bei der Designunterstützung und den Systemwerten fortgesetzt werden, die als statische Eigenschaften oder Schlüssel referenziert werden. Designs selbst können auch auf Systemwerte außerhalb der logischen Struktur des Designs verweisen, wenn die Ressourcenverweise dynamisch sind. Weitere Informationen zu Ressourcenwörterbüchern und der Suchlogik, finden Sie unter [XAML-Ressourcen](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
## <a name="see-also"></a>Siehe auch

- [Übersicht über die Eingabe](input-overview.md)
- [Übersicht über das WPF-Grafikrendering](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [Übersicht über Routingereignisse](routed-events-overview.md)
- [Initialisierung für Objektelemente außerhalb einer Objektstruktur](initialization-for-object-elements-not-in-an-object-tree.md)
- [WPF-Architektur](wpf-architecture.md)
