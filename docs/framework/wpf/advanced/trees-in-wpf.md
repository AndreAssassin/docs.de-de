---
title: Strukturen in WPF
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: f9b507c874dfe0ab3feca19e7fcf79df5af93e10
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/08/2019
ms.locfileid: "59197684"
---
# <a name="trees-in-wpf"></a>Strukturen in WPF
In vielen Technologien werden Elemente und Komponenten in einer Baumstruktur organisiert, in denen Entwickler die Objektknoten direkt in der Struktur bearbeiten, um das Rendering oder das Verhalten einer Anwendung zu beeinflussen. [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] verwendet auch mehrere baumstrukturmetaphern, um Beziehungen zwischen Programmelementen zu definieren. Da die WPF-Entwickler meist eine Anwendung im Code erstellen können oder Teile der Anwendung in XAML festlegen, obwohl sie konzeptionell über die Baumstrukturobjektmetapher denken, rufen sie trotzdem eine bestimmte API auf oder verwenden bestimmte Markups, um dies zu tun, anstatt einige allgemeine API-Strukturobjektmanipulationen vorzunehmen, wie Sie sie möglicherweise im XML-DOM verwenden. WPF zeigt zwei hilfsprogrammklassen, die eine strukturmetapheransicht bereitstellen <xref:System.Windows.LogicalTreeHelper> und <xref:System.Windows.Media.VisualTreeHelper>. Die Begriffe „visuelle Struktur“ und „logische Struktur“ werden auch in der WPF-Dokumentation verwendet, da diese Strukturen für das Verstehen des Verhaltens bestimmter WPF-Schlüsselfunktionen hilfreich sind. In diesem Thema definiert, was die visuelle Struktur und die logische Struktur darstellen, wird erläutert, wie sich diese Strukturen auf ein allgemeines Objektstrukturkonzept beziehen und führt <xref:System.Windows.LogicalTreeHelper> und <xref:System.Windows.Media.VisualTreeHelper>s.  

<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a>Strukturen in WPF  
 Die umfassendste Struktur in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ist die Objektstruktur. Wenn Sie eine Anwendungsseite in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] festlegen und anschließend [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] laden, wird die Baumstruktur basierend auf den Schachtelungsbeziehungen der Elemente im Markup erstellt. Wenn Sie eine Anwendung oder einen Teil der Anwendung im Code festlegen, wird die Baumstruktur basierend darauf erstellt, wie Sie Eigenschaftswerte für Eigenschaften zuweisen, die das Inhaltsmodell für ein bestimmtes Objekt implementieren. In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] gibt es zwei Möglichkeiten, wie die vollständige Objektstruktur konzipiert wird und an die öffentliche API gemeldet werden kann: Als logische Struktur und als visuelle Struktur. Die Unterschiede zwischen logischer Struktur und visueller Struktur sind nicht immer unbedingt wichtig, aber sie können gelegentlich Probleme mit bestimmten [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Subsystemen verursachen und Auswählen im Markup oder im Code beeinträchtigen.  
  
 Obwohl Sie nicht immer die logische Struktur oder die visuelle Struktur direkt bearbeiten, ist das Verstehen der Konzepte, wie die Strukturen interagieren, nützlich, um WPF als eine Technologie zu verstehen. Sich WPF als eine Baumstrukturmetapher vorzustellen, ist auch wichtig, um zu verstehen, wie Eigenschaftsvererbung und Ereignisrouting in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] funktionieren.  
  
> [!NOTE]
>  Da die Objektstruktur eher ein Konzept als eine tatsächliche API ist, ist es eine weitere Möglichkeit, sich das Konzept als Objektdiagramm vorzustellen. In der Praxis gibt es Beziehungen zwischen Objekten während der Laufzeit, die die Baumstrukturmetapher aufschlüsseln können. Trotzdem ist die Baumstrukturmetapher, insbesondere bei XAML-definierten Benutzeroberflächen, ausreichend relevant, sodass die meisten WPF-Dokumentationen den Begriff „Objektstruktur“ verwenden werden, wenn auf dieses allgemeine Konzept verwiesen wird.  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a>Die logische Struktur  
 In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fügen Sie Inhalte zu Benutzeroberflächenelementen hinzu, indem Sie Eigenschaften der Objekte festlegen, die diese Elemente unterstützen. Z. B. Elemente hinzugefügt eine <xref:System.Windows.Controls.ListBox> Steuerelement durch Bearbeiten der <xref:System.Windows.Controls.ItemsControl.Items%2A> Eigenschaft. Auf diese Weise fügen Sie Elemente in der <xref:System.Windows.Controls.ItemCollection> d. h. die <xref:System.Windows.Controls.ItemsControl.Items%2A> -Eigenschaftswert. Auf ähnliche Weise zum Hinzufügen von Objekten auf einer <xref:System.Windows.Controls.DockPanel>, Sie bearbeiten die <xref:System.Windows.Controls.Panel.Children%2A> -Eigenschaftswert. Hier ist Sie Objekte zum Hinzufügen der <xref:System.Windows.Controls.UIElementCollection>. Ein Codebeispiel finden Sie unter [Vorgehensweise: Dynamisches Hinzufügen eines Elements](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).  
  
 In [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], wenn Sie die Listenelemente in Platzieren einer <xref:System.Windows.Controls.ListBox> oder Steuerelemente oder andere UI-Elemente in einer <xref:System.Windows.Controls.DockPanel>, Sie auch verwenden, die <xref:System.Windows.Controls.ItemsControl.Items%2A> und <xref:System.Windows.Controls.Panel.Children%2A> Eigenschaften entweder explizit oder implizit, wie im folgenden Beispiel.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Wenn Sie diesen XAML-Code als XML unter einem Dokumentobjektmodell verarbeiten würden und die auskommentierten Tags als implizit eingeschlossen hätten (was zulässig gewesen wäre), hätte die entstandene XML-DOM-Struktur Elemente für `<ListBox.Items>` und für die anderen impliziten Elemente eingeschlossen. XAML verarbeitet jedoch nicht auf diese Weise, und wenn Sie das Markup lesen und in Objekte schreiben, enthält das daraus entstehende Objektdiagramm nicht wirklich `ListBox.Items`. Es verfügt jedoch über eine <xref:System.Windows.Controls.ListBox> Eigenschaft mit dem Namen `Items` , enthält eine <xref:System.Windows.Controls.ItemCollection>, und dass <xref:System.Windows.Controls.ItemCollection> wird initialisiert, aber leer sein, wenn die <xref:System.Windows.Controls.ListBox> XAML verarbeitet wird. Klicken Sie dann jedes untergeordnete Objektelement, das als Inhalt vorhanden ist. die <xref:System.Windows.Controls.ListBox> hinzugefügt wird die <xref:System.Windows.Controls.ItemCollection> Parser Aufrufen von `ItemCollection.Add`. Dieses Beispiel über die Verarbeitung von XAML in einer Objektstruktur ist bisher scheinbar ein Beispiel, bei dem die erstellte Objektstruktur im Grunde die logische Struktur ist.  
  
 Die logische Struktur ist jedoch nicht das gesamte Objektdiagramm, das für die Anwendungsbenutzeroberfläche zur Laufzeit vorhanden ist, dies gilt selbst wenn die impliziten XAML-Syntaxelemente nicht berücksichtigt werden. Der Hauptgrund dafür sind die visuellen Objekte und Vorlagen. Betrachten Sie beispielsweise die <xref:System.Windows.Controls.Button>. Die logische Struktur meldet die <xref:System.Windows.Controls.Button> Objekt sowie die Zeichenfolge `Content`. Es gibt jedoch noch mehr zu dieser Schaltfläche in der Laufzeit-Objektstruktur. Insbesondere die Schaltfläche nur angezeigt, auf dem Bildschirm die Möglichkeit, weil eine bestimmte <xref:System.Windows.Controls.Button> Steuerelementvorlage angewendet wurde. Die visuellen Elemente, die aus einer angewendeten Vorlage stammen (z. B. der Vorlage definierten <xref:System.Windows.Controls.Border> dunkelgraue auf der visuellen Schaltfläche) werden nicht in der logischen Struktur gemeldet, auch wenn Sie auf der logischen Struktur während der Laufzeit suchen (z.B. zur Behandlung bei einem Eingabeereignis in der sichtbare Benutzeroberfläche und Lesen Sie dann auf der logischen Struktur). Sie müssten stattdessen die visuelle Struktur untersuchen, um die visuellen Vorlagen zu suchen.  
  
 Weitere Informationen dazu, wie die [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]-Syntax das erstellte Objektdiagramm sowie die implizite Syntax in XAML zuordnet, finden Sie unter [Ausführliche Erläuterung der XAML-Syntax](xaml-syntax-in-detail.md) oder [Übersicht über XAML (WPF)](xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a>Der Zweck der logischen Struktur  
 Die logische Struktur ist vorhanden, damit Inhaltsmodelle ihre potenziellen untergeordneten Objekte leicht durchlaufen können und damit Inhaltsmodelle erweiterbar sind. Darüber hinaus bietet die logische Struktur ein Framework für bestimmte Benachrichtigungen, z.B. wenn alle Objekte in der logischen Struktur geladen werden. Im Grunde ist die logische Struktur eine Annäherung an ein Laufzeit-Objektdiagramm auf der Frameworkebene, das visuelle Elemente ausschließt, aber für viele Abfragevorgänge für Ihre eigene Laufzeit-Anwendungskomposition ausreichend ist.  
  
 Darüber hinaus werden sowohl statische und dynamische Ressourcenverweise durch Suchen nach oben durch die logische Struktur für aufgelöst <xref:System.Windows.FrameworkElement.Resources%2A> schemaauflistungen auf dem anfänglich Anforderungsobjekt weiterhin der logischen Struktur nach oben und jeden <xref:System.Windows.FrameworkElement> (oder <xref:System.Windows.FrameworkContentElement>) für eine andere `Resources` -Wert enthält einen <xref:System.Windows.ResourceDictionary>, möglicherweise mit diesem Schlüssel. Die logische Struktur wird für die Ressourcensuche verwendet, wenn sowohl die logische Struktur als auch die visuelle Struktur vorhanden sind. Weitere Informationen zu Ressourcenwörterbüchern und der Suche finden Sie unter [XAML-Ressourcen](xaml-resources.md).  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a>Zusammensetzung der logischen Struktur  
 Die logische Struktur wird auf der WPF-Frameworkebene, was bedeutet, dass das WPF-Basiselement, die relevantesten für Vorgänge der logischen Struktur ist entweder definiert <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement>. Sie können jedoch sehen, wenn Sie tatsächlich verwenden die <xref:System.Windows.LogicalTreeHelper> -API enthält die logische Struktur manchmal Knoten, die nicht entweder <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement>. Die logische Struktur meldet die <xref:System.Windows.Controls.TextBlock.Text%2A> Wert eine <xref:System.Windows.Controls.TextBlock>, dies ist eine Zeichenfolge.  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a>Überschreiben der logischen Struktur  
 Erfahrene Steuerelementautoren können die logische Struktur überschreiben, indem Sie mehrere [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] überschreiben, die festlegen, wie ein allgemeines Objekt- oder Inhaltsmodell Objekte innerhalb der logischen Struktur hinzufügt oder entfernt. Ein Beispiel zum Überschreiben der logischen Struktur finden Sie unter [Überschreiben der logischen Struktur](how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a>Vererbung von Eigenschaftswerten  
 Die Vererbung von Eigenschaftswerten funktioniert mithilfe einer Hybridstruktur. Die eigentlichen Metadaten, die enthält die <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> Eigenschaft, die Vererbung von Eigenschaften ermöglichen, ist der WPF-Frameworkebene <xref:System.Windows.FrameworkPropertyMetadata> Klasse. Aus diesem Grund sowohl das übergeordnete Element, das den ursprünglichen Wert enthält, und das untergeordnete Objekt, das diesen Wert erbt müssen <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement>, außerdem müssen sie beide Teil einer logischen Struktur sein. Allerdings kann für vorhandene WPF-Eigenschaften, die die Vererbung von Eigenschaften unterstützen, die Vererbung von Eigenschaftswerten durch ein beteiligtes Objekt aufrechterhalten werden, das nicht in der logischen Struktur ist. Dies ist vor allem relevant, wenn Vorlagenelemente alle geerbten Eigenschaftswerte verwenden, die entweder auf die Instanz festgelegt wurden, die als Vorlage verwendet wird, oder auf noch höheren Ebenen der Seitenebenen-Zusammensetzung und aus diesem Grund höher in der logischen Struktur sind. Damit die Vererbung von Eigenschaftswerten über eine solche Grenze hinweg konsistent funktioniert, muss die erbende Eigenschaft als angefügte Eigenschaft registriert werden, und Sie sollten dieses Muster befolgen, wenn Sie beabsichtigen, eine benutzerdefinierte Abhängigkeitseigenschaft mit Eigenschaftenvererbungsverhalten festzulegen. Die genaue Struktur, die für die Vererbung von Eigenschaften verwendet wurde, kann nicht vollständig von einer Hilfsprogrammklassen-Dienstmethode vorhergesehen werden, dies gilt selbst während der Laufzeit. Weitere Informationen finden Sie unter [ Vererbung von Eigenschaftswerten](property-value-inheritance.md).  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a>Die visuelle Struktur  
 Neben dem Konzept der logischen Struktur, gibt es auch das Konzept der visuellen Struktur in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Die visuelle Struktur beschreibt die Struktur von visuellen Objekten, dargestellt durch die <xref:System.Windows.Media.Visual> Basisklasse. Wenn Sie eine Vorlage für ein Steuerelement erstellen, werden Sie die visuelle Struktur festlegen oder neu festlegen, die für dieses Steuerelement angewendet wird. Die visuelle Struktur ist auch für Entwickler interessant, die die Kontrolle über Zeichnungen auf niedrigerer Ebene aus Leistungs- und Optimierungsgründen möchten. Eine Belichtung der visuellen Struktur als Teil der konventionellen [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Programmierschnittstellen ist, dass das Ereignis für ein Routingereignis größtenteils entlang der visuellen Struktur steuert, nicht aber entlang der logischen Struktur. Diese Besonderheit des Routingereignisverhaltens ist möglicherweise nicht sofort erkennbar, es sei denn, Sie sind ein Autor des Steuerelements. Routingereignisse über die visuelle Struktur ermöglichen Steuerelemente, die die Komposition auf der visuellen Ebene implementieren, um Ereignisse zu bearbeiten oder Ereignissetter zu erstellen.  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a>Strukturen, Inhaltselemente und Inhaltshosts  
 Inhaltselemente (Klassen, die abgeleitet <xref:System.Windows.ContentElement>) sind nicht Teil der visuellen Struktur; sie erben nicht von <xref:System.Windows.Media.Visual> und haben keine visuelle Darstellung. Um in einer Benutzeroberfläche überhaupt angezeigt zu werden. eine <xref:System.Windows.ContentElement> muss gehostet werden, in einem Inhaltshost, die sowohl eine <xref:System.Windows.Media.Visual> und ein Teilnehmer der logischen Struktur. Solch ein Objekt in der Regel ist eine <xref:System.Windows.FrameworkElement>. Sie können konzipieren, dass der Inhaltshost wie ein „Browser“ für den Inhalt ist und wählt, wie der Inhalt innerhalb des Bildschirmbereichs, den der Host steuert, anzuzeigen ist. Wenn der Inhalt gehostet wird, kann der Inhalt zu einem Teilnehmer bestimmter Prozessstrukturen gemacht werden, die normalerweise der visuellen Struktur zugeordnet sind. Im Allgemeinen die <xref:System.Windows.FrameworkElement> Hostklasse enthält die Implementierung von Code, der ein gehostetes hinzufügt <xref:System.Windows.ContentElement> für die Ereignisroute über Unterknoten der logischen Inhaltsstruktur, obwohl der gehostete Inhalt ist nicht Teil der echten visuellen Struktur. Dies ist erforderlich, damit eine <xref:System.Windows.ContentElement> können Quelle ein Ereignis, das auf jedes Element außer sich selbst weitergeleitet.  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a>Traversierung der Struktur  
 Die <xref:System.Windows.LogicalTreeHelper> -Klasse stellt die <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>, und <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> Methoden zum Durchlaufen der logischen Struktur. In den meisten Fällen sollte Sie nicht die logische Struktur von vorhandenen Steuerelementen durchlaufen müssen, da diese Steuerelemente fast immer ihre logisch untergeordneten Elemente als dedizierte Auflistungseigenschaft verfügbar machen, die Auflistungszugriff, wie z.B. `Add`, einen Indexer und so weiter, unterstützt. Traversierung der Struktur ist in erster Linie ein Szenario, die von Autoren von Steuerelementen verwendet wird, die nicht von geplanten Steuerelementmustern wie z. B. ableiten <xref:System.Windows.Controls.ItemsControl> oder <xref:System.Windows.Controls.Panel> , in denen Auflistungseigenschaften bereits festgelegt sind, und beabsichtigen, ihre eigenen Sammlung bereitstellen Unterstützung von Eigenschaften.  
  
 Die visuelle Struktur unterstützt auch eine Hilfsklasse für die Traversierung der visuellen Struktur, <xref:System.Windows.Media.VisualTreeHelper>. Die visuelle Struktur ist nicht verfügbar gemacht als bequem über steuerelementspezifischen Eigenschaften, sodass die <xref:System.Windows.Media.VisualTreeHelper> Klasse ist die empfohlene Methode die visuelle Struktur zu durchlaufen, wenn dies für Ihr programmierungszenario erforderlich ist. Weitere Informationen finden Sie unter [Übersicht über das WPF-Grafikenrendering](../graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
>  Manchmal ist es notwendig, die visuelle Struktur einer angewendeten Vorlage zu untersuchen. Gehen Sie bei dieser Technik vorsichtig vor. Auch wenn Sie eine visuelle Struktur für ein Steuerelement durchlaufen, in dem Sie die Vorlage definieren, Consumer Ihres Steuerelements können jederzeit ändern die Vorlage durch Festlegen der <xref:System.Windows.Controls.Control.Template%2A> -Eigenschaft für Instanzen und sogar der Endbenutzer kann die angewendete Vorlage beeinflussen, Ändern der Systemdesign.  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a>Routen für Routingereignisse als „Struktur“  
 Wie bereits erwähnt, durchläuft die Route aller angegebenen Routingereignisse entlang eines einzelnen und vordefinierten Pfads einer Struktur, die eine Mischung aus den Darstellungen visueller und logischer Strukturen ist. Die Ereignisroute kann innerhalb der Struktur nach oben oder nach unten passieren, je nachdem, ob es ein Tunnel- oder Bubbling-Routingereignis ist. Das Konzept der Ereignisroute hat keine direkt unterstützende Hilfsprogrammklasse, die verwendet werden kann, um die Ereignisroute unabhängig vom Auslösen eines Ereignisses, das tatsächlich weiterleitet, zu „durchlaufen“. Es gibt eine Klasse, die die Route darstellt <xref:System.Windows.EventRoute>, aber die Methoden dieser Klasse sind normalerweise nur zur internen Verwendung.  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a>Ressourcenwörterbücher und Strukturen  
 Wörterbuchressourcensuche für alle `Resources`, die auf einer Seite festgelegt sind, durchlaufen im Grunde die logische Struktur. Objekte, die nicht in der logischen Struktur sind, können auf verschlüsselte Ressourcen verweisen, aber die Ressourcensuchsequenz beginnt an dem Punkt, an dem das Objekt mit der logischen Struktur verbunden ist. In WPF haben nur logische Strukturknoten ein `Resources` -Eigenschaft, enthält eine <xref:System.Windows.ResourceDictionary>, besteht daher keinen Vorteil der Traversierung der visuellen Struktur, die Suche nach verschlüsselten Ressourcen aus einer <xref:System.Windows.ResourceDictionary>.  
  
 Die Ressourcensuche kann jedoch auch über die unmittelbare logische Struktur hinaus erweitert werden. Bei Anwendungsmarkups kann die Ressourcensuche auf Anwendungsebene von Ressourcenwörterbüchern weitergeführt werden, und anschließend bei der Designunterstützung und den Systemwerten fortgesetzt werden, die als statische Eigenschaften oder Schlüssel referenziert werden. Designs selbst können auch auf Systemwerte außerhalb der logischen Struktur des Designs verweisen, wenn die Ressourcenverweise dynamisch sind. Weitere Informationen zu Ressourcenwörterbüchern und der Suchlogik, finden Sie unter [XAML-Ressourcen](xaml-resources.md).  
  
## <a name="see-also"></a>Siehe auch

- [Übersicht über die Eingabe](input-overview.md)
- [Übersicht über das WPF-Grafikrendering](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [Übersicht über Routingereignisse](routed-events-overview.md)
- [Initialisierung für Objektelemente außerhalb einer Objektstruktur](initialization-for-object-elements-not-in-an-object-tree.md)
- [WPF-Architektur](wpf-architecture.md)
