---
title: WPF-XAML-Namescopes
ms.date: 03/30/2017
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
ms.openlocfilehash: a46942188fd417b46ba4feb44d436800e1362098
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 04/18/2019
ms.locfileid: "59225793"
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="a30c1-102">WPF-XAML-Namescopes</span><span class="sxs-lookup"><span data-stu-id="a30c1-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="a30c1-103">XAML-Namescopes sind ein Konzept, das Objekte bezeichnet, die in XAML definiert sind.</span><span class="sxs-lookup"><span data-stu-id="a30c1-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="a30c1-104">Die Namen in einem XAML-Namescope können verwendet werden, um Beziehungen zwischen den XAML-definierten Namen der Objekte und ihren Entsprechungen in einer Objektstruktur herzustellen.</span><span class="sxs-lookup"><span data-stu-id="a30c1-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="a30c1-105">In der Regel werden XAML-Namescopes in verwaltetem [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Code beim Laden der einzelnen XAML Seitenstämme für XAML-Anwendungen erstellt.</span><span class="sxs-lookup"><span data-stu-id="a30c1-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="a30c1-106">XAML-Namescopes als Programmierobjekte sind definiert, durch die <xref:System.Windows.Markup.INameScope> Schnittstelle und werden auch von der praktischen Klasse implementiert <xref:System.Windows.NameScope>.</span><span class="sxs-lookup"><span data-stu-id="a30c1-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  

<a name="Namescopes_in_Loaded_XAML_Applications"></a>   
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="a30c1-107">Namescopes in geladenen XAML-Anwendungen</span><span class="sxs-lookup"><span data-stu-id="a30c1-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="a30c1-108">Im weiter gefassten Kontext der Programmierung oder der Informatik beinhalten Programmierkonzepte oft einen eindeutigen Bezeichner oder Namen, der für den Objektzugriff verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="a30c1-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="a30c1-109">Für Systeme, die Bezeichner oder Namen verwenden, definiert der Namescope die Grenzen, innerhalb derer ein Prozess oder eine Technik sucht, wenn ein Objekt mit diesem Namen angefordert wird, oder die Grenzen, innerhalb derer die Eindeutigkeit von identifizierenden Namen erzwungen wird.</span><span class="sxs-lookup"><span data-stu-id="a30c1-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="a30c1-110">Diese allgemeinen Prinzipien gelten für XAML-Namescopes.</span><span class="sxs-lookup"><span data-stu-id="a30c1-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="a30c1-111">In WPF werden XAML-Namescopes für das Stammelement einer XAML-Seite erstellt, wenn die Seite geladen wird.</span><span class="sxs-lookup"><span data-stu-id="a30c1-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="a30c1-112">Jeder in der XAML-Seite angegebene Name wird, vom Stammelement ausgehend, einem entsprechenden XAML-Namescope hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="a30c1-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="a30c1-113">In WPF XAML, Elemente, die allgemeine Stammelemente sind (z. B. <xref:System.Windows.Controls.Page>, und <xref:System.Windows.Window>) immer einen XAML-Namescope zu steuern.</span><span class="sxs-lookup"><span data-stu-id="a30c1-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="a30c1-114">Wenn ein Element wie z. B. <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement> ist das Stammelement der Seite im Markup einer [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] Prozessor Fügt eine <xref:System.Windows.Controls.Page> implizit root, damit die <xref:System.Windows.Controls.Page> bieten einen XAML-Namescope arbeiten.</span><span class="sxs-lookup"><span data-stu-id="a30c1-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a30c1-115">WPF-Buildvorgänge erstellen für eine XAML-Produktion selbst dann einen XAML-Namescope, wenn für kein Element im [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]-Markup `Name`- oder `x:Name`-Attribute definiert sind.</span><span class="sxs-lookup"><span data-stu-id="a30c1-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="a30c1-116">Wenn Sie versuchen, denselben Namen in einem beliebigen XAML-Namescope zweimal zu verwenden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="a30c1-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="a30c1-117">Für WPF-XAML, das CodeBehind verwendet und Teil einer kompilierten Anwendung ist, wird die Ausnahme während der Erstellung durch WPF-Buildaktionen ausgelöst, wenn die generierende Klasse für die Seite während der Kompilierung des ausgehenden Markups erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="a30c1-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="a30c1-118">Für XAML, dessen Markup nicht durch Buildaktionen kompiliert wird, können XAML-Namescope-bezogene Ausnahmen während des Ladens des XAML ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="a30c1-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="a30c1-119">XAML-Designer können XAML-Namescope-Probleme auch zur Entwurfszeit vorausschauend behandeln.</span><span class="sxs-lookup"><span data-stu-id="a30c1-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="a30c1-120">Hinzufügen von Objekten zu Laufzeit-Objektstrukturen</span><span class="sxs-lookup"><span data-stu-id="a30c1-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="a30c1-121">Der Zeitpunkt, an dem das XAML analysiert wird, stellt den Zeitpunkt dar, an dem ein WPF-XAML-Namescope erstellt und definiert wird.</span><span class="sxs-lookup"><span data-stu-id="a30c1-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="a30c1-122">Wenn Sie ein Objekt zu einer Objektstruktur hinzufügen, nachdem der die Struktur erzeugende XAML-Code analysiert wurde, wird ein `Name`- oder `x:Name`-Wert für das neue Objekt nicht automatisch die Informationen in einem XAML-Namescope aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="a30c1-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="a30c1-123">Um einen Namen für ein Objekt in einer WPF XAML-Namescope hinzuzufügen, nachdem XAML geladen wurde, müssen Sie die entsprechende Implementierung von Aufrufen <xref:System.Windows.Markup.INameScope.RegisterName%2A> für das Objekt, das den XAML-Namescope definiert, die normalerweise ist der Stamm der XAML-Seite.</span><span class="sxs-lookup"><span data-stu-id="a30c1-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="a30c1-124">Wenn der Name nicht registriert ist, das hinzugefügte Objekt kann nicht verwiesen werden anhand des Namens durch Methoden wie z. B. <xref:System.Windows.FrameworkElement.FindName%2A>, und Sie können diesen Namen für die Animationsziel-nicht verwenden.</span><span class="sxs-lookup"><span data-stu-id="a30c1-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="a30c1-125">Das häufigste Szenario für Anwendungsentwickler ist, den Sie verwenden <xref:System.Windows.FrameworkElement.RegisterName%2A> Namen im XAML-Namescope auf dem aktuellen Stammelement der Seite zu registrieren.</span><span class="sxs-lookup"><span data-stu-id="a30c1-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="a30c1-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> ist Teil des Storyboards ein wichtiger Aspekt dieses Zielobjekten für Animationen.</span><span class="sxs-lookup"><span data-stu-id="a30c1-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="a30c1-127">Weitere Informationen finden Sie unter [Übersicht über Storyboards](../graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="a30c1-127">For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="a30c1-128">Wenn Sie aufrufen <xref:System.Windows.FrameworkElement.RegisterName%2A> auf ein anderes Objekt als das Objekt, das die XAML-Namescope definiert, der Name ist immer noch registriert auf der XAML-Namescope, der das aufrufende Objekt enthalten ist wie bei einem Aufruf <xref:System.Windows.FrameworkElement.RegisterName%2A> auf der XAML-Namescope definieren-Objekts.</span><span class="sxs-lookup"><span data-stu-id="a30c1-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="a30c1-129">XAML Namescopes im Code</span><span class="sxs-lookup"><span data-stu-id="a30c1-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="a30c1-130">Sie können XAML-Namescopes im Code erstellen und anschließend verwenden.</span><span class="sxs-lookup"><span data-stu-id="a30c1-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="a30c1-131">Die an der XAML-Namescope beteiligten APIs und Konzepte sind auch bei reiner Codeverwendung dieselben, da der XAML-Prozessor von [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] diese APIs und Konzepte beim Verarbeiten des XAML selbst verwendet.</span><span class="sxs-lookup"><span data-stu-id="a30c1-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="a30c1-132">Die Aufgaben dieser Konzepte und -APIs sind hauptsächlich, Objekte anhand des Namens innerhalb einer Objektstruktur zu finden, die in der Regel teilweise oder vollständig in XAML definiert ist.</span><span class="sxs-lookup"><span data-stu-id="a30c1-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="a30c1-133">Für Anwendungen, die programmgesteuert erstellt werden, und nicht geladenen XAML, muss das Objekt, das einen XAML-Namescope definiert implementieren <xref:System.Windows.Markup.INameScope>, oder eine <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement> abgeleitete Klasse sein, um die Unterstützung der Erstellung eines XAML-Namescopes auf seine -Instanzen.</span><span class="sxs-lookup"><span data-stu-id="a30c1-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="a30c1-134">Ebenso gilt, das bei jedem Element, das nicht von einem XAML-Prozessor geladen und verarbeitet wird, der XAML-Namescope für das Objekt standardmäßig nicht erstellt oder initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="a30c1-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="a30c1-135">Sie müssen explizit für jedes Objekt einen neuen XAML-Namescope erstellen, für das Sie anschließend Namen registrieren möchten.</span><span class="sxs-lookup"><span data-stu-id="a30c1-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="a30c1-136">Um einen XAML-Namescope zu erstellen, rufen Sie die statische <xref:System.Windows.NameScope.SetNameScope%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="a30c1-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="a30c1-137">Geben Sie das Objekt, das sie als besitzt die `dependencyObject` Parameter und ein neues <xref:System.Windows.NameScope.%23ctor%2A> Konstruktoraufruf als die `value` Parameter.</span><span class="sxs-lookup"><span data-stu-id="a30c1-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="a30c1-138">Wenn Sie das Objekt als bereitgestellt `dependencyObject` für <xref:System.Windows.NameScope.SetNameScope%2A> keine <xref:System.Windows.Markup.INameScope> Implementierung <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement>, wird beim Aufruf <xref:System.Windows.FrameworkElement.RegisterName%2A> für keines der untergeordneten Elemente hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="a30c1-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="a30c1-139">Wenn Sie nicht explizit zu den neuen XAML-Namescope erstellen, klicken Sie dann Aufrufe von <xref:System.Windows.FrameworkElement.RegisterName%2A> wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="a30c1-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="a30c1-140">Ein Beispiel der Verwendung von XAML-Namescope-APIs in Code finden Sie unter [Definieren eines Namensbereichs](../graphics-multimedia/how-to-define-a-name-scope.md).</span><span class="sxs-lookup"><span data-stu-id="a30c1-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>   
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="a30c1-141">XAML-Namescopes in Stilen und Vorlagen</span><span class="sxs-lookup"><span data-stu-id="a30c1-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="a30c1-142">Stile und Vorlagen in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] bieten die Möglichkeit, Inhalte auf einfache Weise wieder zu verwenden und sie erneut anzuwenden.</span><span class="sxs-lookup"><span data-stu-id="a30c1-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="a30c1-143">Allerdings können Stile und Vorlagen auch Elemente mit XAML-Namen, die auf der Vorlagenebene definiert sind, enthalten.</span><span class="sxs-lookup"><span data-stu-id="a30c1-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="a30c1-144">Dieselbe Vorlage wird möglicherweise mehrmals auf einer Seite verwendet.</span><span class="sxs-lookup"><span data-stu-id="a30c1-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="a30c1-145">Aus diesem Grund definieren Stile und Vorlagen ihre eigenen XAML-Namescopes, unabhängig davon, an welcher Position in einer Objektstruktur der Stil oder die Vorlage angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="a30c1-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="a30c1-146">Betrachten Sie das folgende Beispiel:</span><span class="sxs-lookup"><span data-stu-id="a30c1-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="a30c1-147">Hier wird dieselbe Vorlage auf zwei verschiedene Schaltflächen angewendet.</span><span class="sxs-lookup"><span data-stu-id="a30c1-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="a30c1-148">Hätten Vorlagen keine diskreten XAML-Namensbereiche, würde der in der Vorlage verwendete `TheBorder`-Name einen Namenskonflikt im XAML-Namescope verursachen.</span><span class="sxs-lookup"><span data-stu-id="a30c1-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="a30c1-149">Jede Vorlageninstanz hat ihren eigenen XAML-Namescope, weshalb in diesem Beispiel der Namescope jeder Instanz der Vorlage genau einen Namen enthält.</span><span class="sxs-lookup"><span data-stu-id="a30c1-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="a30c1-150">Auch Stile definieren ihre eigenen XAML-Namensbereich. Dies dient vor allem dazu, dass Teilen von Storyboards bestimmte Namen zugewiesen werden können.</span><span class="sxs-lookup"><span data-stu-id="a30c1-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="a30c1-151">Diese Namen ermöglichen steuerelementspezifische Verhalten, die auf Elemente dieses Namens selbst dann angewendet werden, wenn die Vorlage als Teil einer Anpassung von Steuerelementen neu definiert wurde.</span><span class="sxs-lookup"><span data-stu-id="a30c1-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="a30c1-152">Aufgrund der separaten XAML-Namescopes ist die Suche nach benannten Elementen in einer Vorlage schwieriger, als die Suche nach einem ohne Vorlage benannten Element in einer Seite.</span><span class="sxs-lookup"><span data-stu-id="a30c1-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="a30c1-153">Müssen Sie zuerst die angewendete Vorlage durch Abrufen von bestimmen die <xref:System.Windows.Controls.Control.Template%2A> -Eigenschaftswert des Steuerelements, in dem die Vorlage angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="a30c1-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="a30c1-154">Anschließend rufen Sie die Vorlagenversion von <xref:System.Windows.FrameworkTemplate.FindName%2A>, übergeben das Steuerelement, auf die Vorlage als zweiter Parameter angewendet wurde.</span><span class="sxs-lookup"><span data-stu-id="a30c1-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="a30c1-155">Wenn Sie Autor eines Steuerelements sind, und generieren Sie eine Konvention, in denen ein bestimmtes benanntes Element in einer angewendeten Vorlage ist das Ziel für ein Verhalten, das vom Steuerelement selbst definiert ist, können Sie die <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> Methode aus dem Code des Steuerelements-Implementierung.</span><span class="sxs-lookup"><span data-stu-id="a30c1-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="a30c1-156">Die <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> Methode geschützt werden, sodass nur der Autor des Steuerelements Zugriff darauf hat.</span><span class="sxs-lookup"><span data-stu-id="a30c1-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="a30c1-157">Wenn es sich bei dem aus Sie arbeiten in einer Vorlage und erforderlich, um den XAML-Namescope zu erhalten, in dem die Vorlage angewendet wird, erhalten Sie den Wert der <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, und rufen dann <xref:System.Windows.FrameworkElement.FindName%2A> vorhanden.</span><span class="sxs-lookup"><span data-stu-id="a30c1-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="a30c1-158">Ein Beispiel für das Arbeiten innerhalb der Vorlage wäre, wenn Sie einen Ereignis-Handler dort implementieren möchten, wo das Ereignis von einem Element in einer angewendeten Vorlage ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="a30c1-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>   
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="a30c1-159">XAML-Namescopes und namensbezogene APIs</span><span class="sxs-lookup"><span data-stu-id="a30c1-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="a30c1-160"><xref:System.Windows.FrameworkElement> verfügt über <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> und <xref:System.Windows.FrameworkElement.UnregisterName%2A> Methoden.</span><span class="sxs-lookup"><span data-stu-id="a30c1-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="a30c1-161">Wenn das Objekt, für das Sie diese Methoden aufrufen, einen XAML-Namescope besitzt, rufen die Methoden die Methoden des entsprechenden XAML-Namescopes auf.</span><span class="sxs-lookup"><span data-stu-id="a30c1-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="a30c1-162">Andernfalls wird das übergeordnete Element daraufhin überprüft, ob es einen XAML-Namescope besitzt. Dieser Vorgang wird rekursiv fortgesetzt, bis ein XAML-Namescope gefunden wird (wobei Erfolg garantiert ist, da aufgrund des Verhaltens des XAML-Prozessors das Stammelement immer einen XAML-Namescope hat).</span><span class="sxs-lookup"><span data-stu-id="a30c1-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="a30c1-163"><xref:System.Windows.FrameworkContentElement> hat analoge Verhaltensweisen, mit der Ausnahme, die keine <xref:System.Windows.FrameworkContentElement> wird jemals einen XAML-Namescope besitzen.</span><span class="sxs-lookup"><span data-stu-id="a30c1-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="a30c1-164">Die Methoden existieren auf <xref:System.Windows.FrameworkContentElement> , damit die Aufrufe letztendlich zu weitergeleitet werden, können ein <xref:System.Windows.FrameworkElement> übergeordneten Elements.</span><span class="sxs-lookup"><span data-stu-id="a30c1-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="a30c1-165"><xref:System.Windows.NameScope.SetNameScope%2A> wird verwendet, um ein vorhandenes Objekt einen neuen XAML-Namescope zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="a30c1-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="a30c1-166">Rufen Sie <xref:System.Windows.NameScope.SetNameScope%2A> mehr als einmal zum Zurücksetzen oder deaktivieren Sie die XAML-Namescope, ist jedoch keine häufige Verwendung.</span><span class="sxs-lookup"><span data-stu-id="a30c1-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="a30c1-167">Darüber hinaus <xref:System.Windows.NameScope.GetNameScope%2A> wird nicht in der Regel aus Code verwendet.</span><span class="sxs-lookup"><span data-stu-id="a30c1-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="a30c1-168">Implementierungen von XAML-Namescopes</span><span class="sxs-lookup"><span data-stu-id="a30c1-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="a30c1-169">Die folgenden Klassen implementieren <xref:System.Windows.Markup.INameScope> direkt:</span><span class="sxs-lookup"><span data-stu-id="a30c1-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
-   <xref:System.Windows.NameScope>  
  
-   <xref:System.Windows.Style>  
  
-   <xref:System.Windows.ResourceDictionary>  
  
-   <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="a30c1-170"><xref:System.Windows.ResourceDictionary> XAML-Namen oder -Namescopes wird nicht verwendet werden. Stattdessen verwendet es Schlüssel, da es die Implementierung eines Wörterbuch handelt.</span><span class="sxs-lookup"><span data-stu-id="a30c1-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="a30c1-171">Nur deshalb, <xref:System.Windows.ResourceDictionary> implementiert <xref:System.Windows.Markup.INameScope> ist, damit es Ausnahmen für Benutzercode auslösen kann, die verdeutlichen den Unterschied zwischen einem wahren XAML-Namescope, und wie ein <xref:System.Windows.ResourceDictionary> verarbeitet Tasten, und um sicherzustellen, dass die XAML-Namescopes auf nicht angewendet werden ein <xref:System.Windows.ResourceDictionary> durch übergeordnete Elemente.</span><span class="sxs-lookup"><span data-stu-id="a30c1-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="a30c1-172"><xref:System.Windows.FrameworkTemplate> und <xref:System.Windows.Style> implementieren <xref:System.Windows.Markup.INameScope> durch explizite Schnittstellendefinitionen.</span><span class="sxs-lookup"><span data-stu-id="a30c1-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="a30c1-173">Die expliziten Implementierungen ermöglichen diese XAML-Namescopes konventionell zu Verhalten, wenn darauf zugegriffen werden die <xref:System.Windows.Markup.INameScope> -Schnittstelle, die ist, wie XAML-Namescopes kommuniziert werden durch [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] interne Prozesse.</span><span class="sxs-lookup"><span data-stu-id="a30c1-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="a30c1-174">Die expliziten Schnittstellendefinitionen sind jedoch nicht Teil der konventionellen API-Oberfläche <xref:System.Windows.FrameworkTemplate> und <xref:System.Windows.Style>, da Sie nur selten zum Aufrufen benötigen der <xref:System.Windows.Markup.INameScope> Methoden <xref:System.Windows.FrameworkTemplate> und <xref:System.Windows.Style> direkt aus, und stattdessen andere API verwenden wie z. B. <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span><span class="sxs-lookup"><span data-stu-id="a30c1-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="a30c1-175">Die folgenden Klassen definieren ihren eigenen XAML-Namescope, mit der <xref:System.Windows.NameScope?displayProperty=nameWithType> Hilfsklasse und Herstellen einer Verbindung mit der XAML-Namescope-Implementierung, über die <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> angefügte Eigenschaft:</span><span class="sxs-lookup"><span data-stu-id="a30c1-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
-   <xref:System.Windows.FrameworkElement>  
  
-   <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="a30c1-176">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="a30c1-176">See also</span></span>

- [<span data-ttu-id="a30c1-177">XAML-Namespaces und Namespacezuordnung für WPF-XAML</span><span class="sxs-lookup"><span data-stu-id="a30c1-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)
- [<span data-ttu-id="a30c1-178">x:Name-Anweisung</span><span class="sxs-lookup"><span data-stu-id="a30c1-178">x:Name Directive</span></span>](../../xaml-services/x-name-directive.md)
