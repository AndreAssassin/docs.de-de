---
title: Gemeinsame Verwendung von Nachrichtenschleifen zwischen Win32 und WPF
titleSuffix: ''
ms.date: 03/30/2017
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
ms.openlocfilehash: e1b96284d69645876d3e383beb03a2cc540d8b7b
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/24/2020
ms.locfileid: "76731708"
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="3caa5-102">Gemeinsame Verwendung von Nachrichtenschleifen zwischen Win32 und WPF</span><span class="sxs-lookup"><span data-stu-id="3caa5-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="3caa5-103">In diesem Thema wird beschrieben, wie eine Nachrichten Schleife für die Interoperation mit [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]implementiert wird, entweder mithilfe vorhandener Nachrichten Schleifen in <xref:System.Windows.Threading.Dispatcher> oder durch Erstellen einer separaten Nachrichten Schleife auf der Win32-Seite des Interoperation-Codes.</span><span class="sxs-lookup"><span data-stu-id="3caa5-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the Win32 side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="3caa5-104">ComponentDispatcher und die Nachrichten Schleife</span><span class="sxs-lookup"><span data-stu-id="3caa5-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="3caa5-105">Ein normales Szenario für die Unterstützung von Interoperation und Tastatur Ereignissen besteht darin, <xref:System.Windows.Interop.IKeyboardInputSink>oder eine Unterklasse von Klassen zu implementieren, die bereits <xref:System.Windows.Interop.IKeyboardInputSink>implementiert haben, z. b. <xref:System.Windows.Interop.HwndSource> oder <xref:System.Windows.Interop.HwndHost>.</span><span class="sxs-lookup"><span data-stu-id="3caa5-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="3caa5-106">Die Unterstützung von Tastatur senken adressiert jedoch nicht alle möglichen Nachrichten Schleifen Anforderungen, die Sie beim Senden und empfangen von Nachrichten über die Grenzen der Interoperabilität haben können.</span><span class="sxs-lookup"><span data-stu-id="3caa5-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="3caa5-107">Um die Formalisierung einer Anwendungs Nachrichten Schleifen-Architektur zu unterstützen, stellt [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] die <xref:System.Windows.Interop.ComponentDispatcher>-Klasse bereit, die ein einfaches Protokoll für eine Nachrichten Schleife definiert.</span><span class="sxs-lookup"><span data-stu-id="3caa5-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="3caa5-108"><xref:System.Windows.Interop.ComponentDispatcher> ist eine statische Klasse, die mehrere Member verfügbar macht.</span><span class="sxs-lookup"><span data-stu-id="3caa5-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="3caa5-109">Der Gültigkeitsbereich jeder Methode ist implizit an den aufrufenden Thread gebunden.</span><span class="sxs-lookup"><span data-stu-id="3caa5-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="3caa5-110">Eine Nachrichten Schleife muss einige dieser APIs zu kritischen Zeiten (wie im nächsten Abschnitt definiert) aufruft.</span><span class="sxs-lookup"><span data-stu-id="3caa5-110">A message loop must call some of those APIs at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="3caa5-111"><xref:System.Windows.Interop.ComponentDispatcher> stellt Ereignisse bereit, die von anderen Komponenten (z. b. der Tastatur Senke) überwacht werden können.</span><span class="sxs-lookup"><span data-stu-id="3caa5-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="3caa5-112">Die <xref:System.Windows.Threading.Dispatcher>-Klasse ruft alle geeigneten <xref:System.Windows.Interop.ComponentDispatcher> Methoden in einer entsprechenden Reihenfolge auf.</span><span class="sxs-lookup"><span data-stu-id="3caa5-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="3caa5-113">Wenn Sie Ihre eigene Nachrichten Schleife implementieren, ist der Code für das Aufrufen von <xref:System.Windows.Interop.ComponentDispatcher> Methoden auf ähnliche Weise verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="3caa5-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="3caa5-114">Wenn Sie <xref:System.Windows.Interop.ComponentDispatcher> Methoden in einem Thread aufrufen, werden nur Ereignishandler aufgerufen, die in diesem Thread registriert wurden.</span><span class="sxs-lookup"><span data-stu-id="3caa5-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="3caa5-115">Schreiben von Nachrichten Schleifen</span><span class="sxs-lookup"><span data-stu-id="3caa5-115">Writing Message Loops</span></span>  
 <span data-ttu-id="3caa5-116">Im folgenden finden Sie eine Prüfliste für <xref:System.Windows.Interop.ComponentDispatcher> Elemente, die Sie verwenden werden, wenn Sie eine eigene Nachrichten Schleife schreiben:</span><span class="sxs-lookup"><span data-stu-id="3caa5-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
- <span data-ttu-id="3caa5-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: die Nachrichten Schleife sollte diese so angeben, dass der Thread modal ist.</span><span class="sxs-lookup"><span data-stu-id="3caa5-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
- <span data-ttu-id="3caa5-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>: in der Nachrichten Schleife sollte diese aufgerufen werden, um anzugeben, dass der Thread auf einen nicht modalen Wert zurückgesetzt wurde.</span><span class="sxs-lookup"><span data-stu-id="3caa5-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
- <span data-ttu-id="3caa5-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: die Nachrichten Schleife sollte diese Methode angeben, um anzugeben, dass <xref:System.Windows.Interop.ComponentDispatcher> das <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> Ereignis aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="3caa5-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="3caa5-120"><xref:System.Windows.Interop.ComponentDispatcher> wird <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> nicht, wenn <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> `true`ist, aber Nachrichten Schleifen können auch <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> aufgerufen werden, auch wenn <xref:System.Windows.Interop.ComponentDispatcher> im modalen Zustand nicht darauf reagieren kann.</span><span class="sxs-lookup"><span data-stu-id="3caa5-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
- <span data-ttu-id="3caa5-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: die Nachrichten Schleife sollte diese zum angeben, dass eine neue Meldung verfügbar ist, aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="3caa5-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="3caa5-122">Der Rückgabewert gibt an, ob ein Listener für ein <xref:System.Windows.Interop.ComponentDispatcher> Ereignis die Nachricht verarbeitet hat.</span><span class="sxs-lookup"><span data-stu-id="3caa5-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="3caa5-123">Wenn <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> `true` (behandelt) zurückgibt, sollte der Verteiler mit der Nachricht nichts weiter tun.</span><span class="sxs-lookup"><span data-stu-id="3caa5-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="3caa5-124">Wenn der Rückgabewert `false`ist, wird erwartet, dass der Verteiler die Win32-Funktion `TranslateMessage`aufruft und dann `DispatchMessage`aufruft.</span><span class="sxs-lookup"><span data-stu-id="3caa5-124">If the return value is `false`, the dispatcher is expected to call the Win32 function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="3caa5-125">Verwenden von ComponentDispatcher und vorhandener Nachrichten Behandlung</span><span class="sxs-lookup"><span data-stu-id="3caa5-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="3caa5-126">Im folgenden finden Sie eine Prüfliste für <xref:System.Windows.Interop.ComponentDispatcher> Elemente, die Sie verwenden werden, wenn Sie sich auf die inhärente [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Message-Schleife verlassen</span><span class="sxs-lookup"><span data-stu-id="3caa5-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
- <span data-ttu-id="3caa5-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: Gibt zurück, ob die Anwendung modal ist (z. b. eine modale Nachrichten Schleife wurde per pushübertragung).</span><span class="sxs-lookup"><span data-stu-id="3caa5-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="3caa5-128"><xref:System.Windows.Interop.ComponentDispatcher> können diesen Status nachverfolgen, weil die-Klasse die Anzahl von <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> und <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> aufrufen aus der Nachrichten Schleife beibehält.</span><span class="sxs-lookup"><span data-stu-id="3caa5-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
- <span data-ttu-id="3caa5-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> und <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> Ereignisse befolgen die Standardregeln für Delegatenaufrufe.</span><span class="sxs-lookup"><span data-stu-id="3caa5-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="3caa5-130">Delegaten werden in einer nicht angegebenen Reihenfolge aufgerufen, und alle Delegaten werden auch dann aufgerufen, wenn der erste die Nachricht als behandelt kennzeichnet.</span><span class="sxs-lookup"><span data-stu-id="3caa5-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
- <span data-ttu-id="3caa5-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: gibt eine angemessene und effiziente Zeit für die Leerlauf Verarbeitung an (es sind keine weiteren ausstehenden Nachrichten für den Thread vorhanden).</span><span class="sxs-lookup"><span data-stu-id="3caa5-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="3caa5-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> wird nicht ausgelöst, wenn der Thread modal ist.</span><span class="sxs-lookup"><span data-stu-id="3caa5-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
- <span data-ttu-id="3caa5-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: wird für alle Nachrichten ausgelöst, die von der Meldungs Pumpe verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="3caa5-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
- <span data-ttu-id="3caa5-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: wird für alle Nachrichten ausgelöst, die während <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>nicht behandelt wurden.</span><span class="sxs-lookup"><span data-stu-id="3caa5-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="3caa5-135">Eine Nachricht wird als behandelt betrachtet, wenn nach dem <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> Ereignis oder <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> Ereignis der `handled` Parameter, der als Verweis in den Ereignisdaten übergeben wurde, `true`ist.</span><span class="sxs-lookup"><span data-stu-id="3caa5-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="3caa5-136">Ereignishandler sollten die Meldung ignorieren, wenn `handled` `true`ist, da dies bedeutet, dass der andere Handler die Nachricht zuerst verarbeitet hat.</span><span class="sxs-lookup"><span data-stu-id="3caa5-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="3caa5-137">Ereignishandler für beide Ereignisse können die Nachricht ändern.</span><span class="sxs-lookup"><span data-stu-id="3caa5-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="3caa5-138">Der Verteiler sollte die geänderte Nachricht und nicht die ursprüngliche unveränderte Nachricht verteilen.</span><span class="sxs-lookup"><span data-stu-id="3caa5-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="3caa5-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> wird an alle Listener übermittelt, aber die Architektur Absicht besteht darin, dass nur das Fenster der obersten Ebene, in dem das HWND enthalten ist, in dem die Nachrichten als Antwort auf die Nachricht Code aufrufen sollen.</span><span class="sxs-lookup"><span data-stu-id="3caa5-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="3caa5-140">Behandeln von ComponentDispatcher-Ereignissen durch HwndSource</span><span class="sxs-lookup"><span data-stu-id="3caa5-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="3caa5-141">Wenn die <xref:System.Windows.Interop.HwndSource> ein Fenster der obersten Ebene (kein übergeordnetes HWND) ist, wird Sie bei <xref:System.Windows.Interop.ComponentDispatcher>registriert.</span><span class="sxs-lookup"><span data-stu-id="3caa5-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="3caa5-142">Wenn <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> ausgelöst wird und die Nachricht für die <xref:System.Windows.Interop.HwndSource> oder untergeordneten Fenster bestimmt ist, ruft <xref:System.Windows.Interop.HwndSource> deren <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A><xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> Tastatur Senk Sequenz auf.</span><span class="sxs-lookup"><span data-stu-id="3caa5-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="3caa5-143">Wenn es sich bei der <xref:System.Windows.Interop.HwndSource> nicht um ein Fenster der obersten Ebene handelt (hat ein übergeordnetes HWND), erfolgt keine Behandlung.</span><span class="sxs-lookup"><span data-stu-id="3caa5-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="3caa5-144">Es wird davon ausgegangen, dass nur das Fenster der obersten Ebene die Verarbeitung durchführen soll, und es wird erwartet, dass ein Fenster der obersten Ebene mit Unterstützung für die Tastatur senken als Teil eines intervorgangs Szenarios ist.</span><span class="sxs-lookup"><span data-stu-id="3caa5-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="3caa5-145">Wenn <xref:System.Windows.Interop.HwndHost.WndProc%2A> auf einem <xref:System.Windows.Interop.HwndSource> aufgerufen wird, ohne dass eine entsprechende Tastatur Sink-Methode zuerst aufgerufen wird, empfängt Ihre Anwendung die Tastatur Ereignisse auf höherer Ebene, z. b. <xref:System.Windows.UIElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="3caa5-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="3caa5-146">Es werden jedoch keine Methoden der Tastatur senken aufgerufen, die wünschenswert für das gewünschte Tastatureingabe Modell, wie z. b. die Zugriffsschlüssel Unterstützung, umgangen werden.</span><span class="sxs-lookup"><span data-stu-id="3caa5-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="3caa5-147">Dies kann der Fall sein, weil die Nachrichten Schleife den relevanten Thread nicht ordnungsgemäß für die <xref:System.Windows.Interop.ComponentDispatcher>benachrichtigt hat oder weil das übergeordnete HWND nicht die richtigen Antworten auf die Tastatur Senke aufgerufen hat.</span><span class="sxs-lookup"><span data-stu-id="3caa5-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="3caa5-148">Eine Nachricht, die an die Tastatur Senke gesendet wird, wird möglicherweise nicht an das HWND gesendet, wenn Sie mit der <xref:System.Windows.Interop.HwndSource.AddHook%2A>-Methode Hooks für diese Nachricht hinzugefügt haben.</span><span class="sxs-lookup"><span data-stu-id="3caa5-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="3caa5-149">Die Nachricht wurde möglicherweise direkt auf der nachrichtenpump Ebene verarbeitet und nicht an die `DispatchMessage` Funktion übermittelt.</span><span class="sxs-lookup"><span data-stu-id="3caa5-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3caa5-150">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="3caa5-150">See also</span></span>

- <xref:System.Windows.Interop.ComponentDispatcher>
- <xref:System.Windows.Interop.IKeyboardInputSink>
- [<span data-ttu-id="3caa5-151">Interaktion zwischen WPF und Win32</span><span class="sxs-lookup"><span data-stu-id="3caa5-151">WPF and Win32 Interoperation</span></span>](wpf-and-win32-interoperation.md)
- [<span data-ttu-id="3caa5-152">Threadmodell</span><span class="sxs-lookup"><span data-stu-id="3caa5-152">Threading Model</span></span>](threading-model.md)
- [<span data-ttu-id="3caa5-153">Übersicht über die Eingabe</span><span class="sxs-lookup"><span data-stu-id="3caa5-153">Input Overview</span></span>](input-overview.md)
