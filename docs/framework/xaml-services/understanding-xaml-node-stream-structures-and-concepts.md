---
title: Grundlagen zu XAML-Knotenstreamstrukturen und -konzepten
ms.date: 03/30/2017
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
ms.openlocfilehash: a04cc8c9dd3e36e4866e773861fddce3c10d0e20
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/28/2019
ms.locfileid: "64755154"
---
# <a name="understanding-xaml-node-stream-structures-and-concepts"></a><span data-ttu-id="4bc44-102">Grundlagen zu XAML-Knotenstreamstrukturen und -konzepten</span><span class="sxs-lookup"><span data-stu-id="4bc44-102">Understanding XAML Node Stream Structures and Concepts</span></span>

<span data-ttu-id="4bc44-103">Die in .NET Framework-XAML-Diensten implementierten XAML-Reader und XAML-Writer basieren auf dem Entwurfskonzept eines XAML-Knotenstreams.</span><span class="sxs-lookup"><span data-stu-id="4bc44-103">XAML readers and XAML writers as implemented in .NET Framework XAML Services are based on the design concept of a XAML node stream.</span></span> <span data-ttu-id="4bc44-104">Der XAML-Knotenstream ist eine Konzeptualisierung eines Satzes von XAML-Knoten.</span><span class="sxs-lookup"><span data-stu-id="4bc44-104">The XAML node stream is a conceptualization of a set of XAML nodes.</span></span> <span data-ttu-id="4bc44-105">In dieser Konzeptualisierung arbeitet ein XAML-Prozessor die Struktur der Knotenbeziehungen in der XAML einzeln ab.</span><span class="sxs-lookup"><span data-stu-id="4bc44-105">In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time.</span></span> <span data-ttu-id="4bc44-106">Dabei ist immer nur ein aktueller Datensatz oder eine aktuelle Position in einem geöffneten XAML-Knotenstream vorhanden, und viele Aspekte der APIs melden nur die von dieser Position verfügbaren Informationen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-106">At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position.</span></span> <span data-ttu-id="4bc44-107">Der aktuelle Knoten in einem XAML-Knotenstream kann als Objekt, Member oder Wert beschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-107">The current node in a XAML node stream can be described as being an object, a member, or a value.</span></span> <span data-ttu-id="4bc44-108">Indem Sie XAML als einen XAML-Knotenstream behandeln, können XAML-Reader mit XAML-Writern kommunizieren und ein Programm aktivieren, um die Inhalte eines XAML-Knotenstreams während eines Ladepfad- oder Speicherpfadvorgangs, an dem XAML beteiligt ist, anzuzeigen, mit diesen zu interagieren oder sie zu verändern.</span><span class="sxs-lookup"><span data-stu-id="4bc44-108">By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML.</span></span> <span data-ttu-id="4bc44-109">Der API-Entwurf von XAML-Readern und -Writern und das Konzept des XAML-Knotenstreams ähneln früheren verwandten Reader- und Writerentwürfen und -konzepten, z. B. dem [!INCLUDE[TLA#tla_xmldom](../../../includes/tlasharptla-xmldom-md.md)] und den <xref:System.Xml.XmlReader> - und <xref:System.Xml.XmlWriter> -Klassen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-109">XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the [!INCLUDE[TLA#tla_xmldom](../../../includes/tlasharptla-xmldom-md.md)] and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="4bc44-110">In diesem Thema werden XAML-Knotenstreamkonzepte erläutert, und es wird beschrieben, wie Sie Routinen schreiben können, die mit XAML-Darstellungen auf XAML-Knotenebene interagieren.</span><span class="sxs-lookup"><span data-stu-id="4bc44-110">This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.</span></span>

<a name="loading_into_a_xaml_reader"></a>

## <a name="loading-xaml-into-a-xaml-reader"></a><span data-ttu-id="4bc44-111">Laden von XAML in einen XAML-Reader</span><span class="sxs-lookup"><span data-stu-id="4bc44-111">Loading XAML into a XAML Reader</span></span>

<span data-ttu-id="4bc44-112">Die <xref:System.Xaml.XamlReader> -Basisklasse deklariert kein bestimmtes Verfahren zum Laden der anfänglichen XAML in einen XAML-Reader.</span><span class="sxs-lookup"><span data-stu-id="4bc44-112">The base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader.</span></span> <span data-ttu-id="4bc44-113">Stattdessen deklariert und implementiert eine abgeleitete Klasse die Ladetechnik, einschließlich der allgemeinen Eigenschaften und Einschränkungen der Eingabequelle für XAML.</span><span class="sxs-lookup"><span data-stu-id="4bc44-113">Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML.</span></span> <span data-ttu-id="4bc44-114">Ein <xref:System.Xaml.XamlObjectReader> liest z. B. ein Objektdiagramm beginnend mit der Eingabequelle eines einzelnen Objekts, das den Stamm oder die Basis darstellt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-114">For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base.</span></span> <span data-ttu-id="4bc44-115">Anschließend erzeugt der <xref:System.Xaml.XamlObjectReader> einen XAML-Knotenstream aus dem Objektdiagramm.</span><span class="sxs-lookup"><span data-stu-id="4bc44-115">The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph.</span></span>

<span data-ttu-id="4bc44-116">Die bekannteste von .NET Framework-XAML-Diensten definierte <xref:System.Xaml.XamlReader> -Unterklasse ist <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="4bc44-116">The most prominent .NET Framework XAML Services–defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="4bc44-117">Der<xref:System.Xaml.XamlXmlReader> lädt die anfängliche XAML, indem eine Textdatei direkt über einen Stream oder Dateipfad oder indirekt über eine zugehörige Readerklasse wie <xref:System.IO.TextReader>geladen wird.</span><span class="sxs-lookup"><span data-stu-id="4bc44-117"><xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="4bc44-118">Der <xref:System.Xaml.XamlReader> enthält somit die gesamte XAML-Eingabequelle, nachdem diese geladen wurde.</span><span class="sxs-lookup"><span data-stu-id="4bc44-118">The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded.</span></span> <span data-ttu-id="4bc44-119">Die <xref:System.Xaml.XamlReader> -Basis-API ist jedoch so aufgebaut, dass der Reader mit einem einzelnen Knoten der XAML interagiert.</span><span class="sxs-lookup"><span data-stu-id="4bc44-119">However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML.</span></span> <span data-ttu-id="4bc44-120">Beim erstmaligen Laden ist der erste gefundene einzelne Knoten der Stamm der XAML und das zugehörige Startobjekt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-120">When first loaded, the first single node you encounter is the root of the XAML, and its start object.</span></span>

### <a name="the-xaml-node-stream-concept"></a><span data-ttu-id="4bc44-121">XAML-Knotenstreamkonzept</span><span class="sxs-lookup"><span data-stu-id="4bc44-121">The XAML Node Stream Concept</span></span>

<span data-ttu-id="4bc44-122">Wenn Sie generell besser mit einem DOM-, strukturmetapher- oder abfragebasierten Ansatz für den Zugriff auf XML-basierte Technologien vertraut sind, ist es hilfreich, sich einen XAML-Knotenstream wie im Folgenden beschrieben vorzustellen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-122">If you are generally more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows.</span></span> <span data-ttu-id="4bc44-123">Stellen Sie sich vor, dass die geladene XAML ein DOM oder eine Struktur ist, in dem bzw. der jeder mögliche Knoten vollständig erweitert und anschließend linear dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="4bc44-123">Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly.</span></span> <span data-ttu-id="4bc44-124">Wenn Sie die Knoten durchlaufen, begegnen Ihnen möglicherweise Ebenen, die bei einem DOM relevant wären, vom XAML-Knotenstream aber nicht explizit verfolgt werden, weil diese Ebenenkonzepte für einen Knotenstream nicht relevant sind.</span><span class="sxs-lookup"><span data-stu-id="4bc44-124">As you advance through the nodes, you might be traversing "in" or "out" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream.</span></span> <span data-ttu-id="4bc44-125">Der Knotenstream hat eine "aktuelle" Position. Sofern Sie andere Teile des Streams jedoch nicht selbst als Verweise gespeichert haben, sind alle Aspekte des Knotenstreams mit Ausnahme der aktuellen Knotenposition nicht sichtbar.</span><span class="sxs-lookup"><span data-stu-id="4bc44-125">The node stream has a "current" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.</span></span>

<span data-ttu-id="4bc44-126">Das XAML-Knotenstreamkonzept bietet den wichtigen Vorteil, dass Sie sicher sein können, dass die gesamte XAML-Darstellung verarbeitet wurde, wenn Sie den ganzen Knotenstream durchlaufen. Sie müssen sich keine Gedanken machen, dass bei einer Abfrage, einem DOM-Vorgang oder einem anderen nicht linearen Ansatz der Informationsverarbeitung ein Teil der vollständigen XAML-Darstellung übersehen wurde.</span><span class="sxs-lookup"><span data-stu-id="4bc44-126">The XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation.</span></span> <span data-ttu-id="4bc44-127">Aus diesem Grund ist die Darstellung eines XAML-Knotenstreams sowohl für die Verbindung von XAML-Readern und XAML-Writern als auch die Bereitstellung eines Systems, in dem Sie Ihren eigenen, zwischen den Lese- und Schreibphasen eines XAML-Verarbeitungsvorgangs eingesetzten Prozess einfügen können, ideal geeignet.</span><span class="sxs-lookup"><span data-stu-id="4bc44-127">For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation.</span></span> <span data-ttu-id="4bc44-128">In vielen Fällen wird die Reihenfolge von Knoten im XAML-Knotenstream gegenüber der möglichen Reihenfolge im Quelltext, in der Binärdatei oder im Objektdiagramm bewusst von XAML-Readern optimiert oder neu geordnet.</span><span class="sxs-lookup"><span data-stu-id="4bc44-128">In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph.</span></span> <span data-ttu-id="4bc44-129">Durch dieses Verhalten wird eine XAML-Verarbeitungsarchitektur erzwungen, in der XAML-Writer nie im Knotenstream zurückgehen müssen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-129">This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go "back" in the node stream.</span></span> <span data-ttu-id="4bc44-130">Im Idealfall sollten alle XAML-Schreibvorgänge in der Lage sein, basierend auf dem Schemakontext und der aktuellen Position des Knotenstreams zu arbeiten.</span><span class="sxs-lookup"><span data-stu-id="4bc44-130">Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.</span></span>

<a name="a_basic_reading_node_loop"></a>

## <a name="a-basic-reading-node-loop"></a><span data-ttu-id="4bc44-131">Grundlegende Leseknotenschleife</span><span class="sxs-lookup"><span data-stu-id="4bc44-131">A Basic Reading Node Loop</span></span>

<span data-ttu-id="4bc44-132">Eine grundlegende Leseknotenschleife zum Untersuchen eines XAML-Knotenstreams besteht aus den folgenden Konzepten.</span><span class="sxs-lookup"><span data-stu-id="4bc44-132">A basic reading node loop for examining a XAML node stream consists of the following concepts.</span></span> <span data-ttu-id="4bc44-133">Bei den in diesem Thema erläuterten Knotenschleifen wird davon ausgegangen, dass Sie eine textbasierte, lesbare XAML-Datei mit <xref:System.Xaml.XamlXmlReader>lesen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-133">For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="4bc44-134">Die Links in diesem Abschnitt verweisen auf die von <xref:System.Xaml.XamlXmlReader>implementierte XAML-Knotenschleifen-API.</span><span class="sxs-lookup"><span data-stu-id="4bc44-134">The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>.</span></span>

- <span data-ttu-id="4bc44-135">Stellen Sie sicher, dass Sie sich nicht am Ende des XAML-Knotenstreams befinden (überprüfen Sie <xref:System.Xaml.XamlXmlReader.IsEof%2A>, oder verwenden Sie den <xref:System.Xaml.XamlXmlReader.Read%2A> -Rückgabewert).</span><span class="sxs-lookup"><span data-stu-id="4bc44-135">Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value).</span></span> <span data-ttu-id="4bc44-136">Wenn Sie sich am Ende des Streams befinden, gibt es keinen aktuellen Knoten, und Sie sollten den Stream beenden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-136">If you are at the end of the stream, there is no current node and you should exit.</span></span>

- <span data-ttu-id="4bc44-137">Überprüfen Sie, welchen Knotentyp der XAML-Knotenstream gerade bereitstellt, indem Sie <xref:System.Xaml.XamlXmlReader.NodeType%2A>aufrufen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-137">Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span>

- <span data-ttu-id="4bc44-138">Wenn Sie über einen zugehörigen, direkt verbundenen XAML-Objektwriter verfügen, rufen Sie an dieser Stelle im Allgemeinen <xref:System.Xaml.XamlWriter.WriteNode%2A> auf.</span><span class="sxs-lookup"><span data-stu-id="4bc44-138">If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point.</span></span>

- <span data-ttu-id="4bc44-139">Verwenden Sie abhängig davon, welcher <xref:System.Xaml.XamlNodeType> als aktueller Knoten oder aktueller Datensatz gemeldet wird, einen der folgenden Aufrufe, um Informationen zum Knoteninhalt zu erhalten:</span><span class="sxs-lookup"><span data-stu-id="4bc44-139">Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:</span></span>

  - <span data-ttu-id="4bc44-140">Lautet der <xref:System.Xaml.XamlXmlReader.NodeType%2A> <xref:System.Xaml.XamlNodeType.StartMember> oder <xref:System.Xaml.XamlNodeType.EndMember>, rufen Sie <xref:System.Xaml.XamlXmlReader.Member%2A> auf, um <xref:System.Xaml.XamlMember> -Informationen zu einem Member zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="4bc44-140">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member.</span></span> <span data-ttu-id="4bc44-141">Da der Member eine <xref:System.Xaml.XamlDirective>sein könnte, ist er nicht zwingend ein konventioneller Member mit definiertem Typ des vorherigen Objekts.</span><span class="sxs-lookup"><span data-stu-id="4bc44-141">Note that the member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object.</span></span> <span data-ttu-id="4bc44-142">Ein auf ein Objekt angewendeter `x:Name` wird z. B. als XAML-Member angezeigt, bei dem <xref:System.Xaml.XamlMember.IsDirective%2A> "true" und der <xref:System.Xaml.XamlMember.Name%2A> des Members `Name`ist und andere Eigenschaften angeben, dass diese Direktive im XAML-Namespace der XAML-Sprache enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="4bc44-142">For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace.</span></span>

  - <span data-ttu-id="4bc44-143">Lautet der <xref:System.Xaml.XamlXmlReader.NodeType%2A> <xref:System.Xaml.XamlNodeType.StartObject> oder <xref:System.Xaml.XamlNodeType.EndObject>, rufen Sie <xref:System.Xaml.XamlXmlReader.Type%2A> auf, um <xref:System.Xaml.XamlType> -Informationen zu einem Objekt zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="4bc44-143">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object.</span></span>

  - <span data-ttu-id="4bc44-144">Lautet der <xref:System.Xaml.XamlXmlReader.NodeType%2A> <xref:System.Xaml.XamlNodeType.Value>, rufen Sie <xref:System.Xaml.XamlXmlReader.Value%2A>auf.</span><span class="sxs-lookup"><span data-stu-id="4bc44-144">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>.</span></span> <span data-ttu-id="4bc44-145">Ein Knoten ist nur ein Wert, wenn er der einfachste Ausdruck eines Werts für einen Member oder der Initialisierungstext für ein Objekt ist (dabei ist jedoch das weiter unten in diesem Thema beschriebene Typkonvertierungsverhalten zu beachten).</span><span class="sxs-lookup"><span data-stu-id="4bc44-145">A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).</span></span>

  - <span data-ttu-id="4bc44-146">Lautet der <xref:System.Xaml.XamlXmlReader.NodeType%2A> <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, rufen Sie <xref:System.Xaml.XamlXmlReader.Namespace%2A> auf, um Namespaceinformationen für einen Namespaceknoten zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="4bc44-146">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node.</span></span>

- <span data-ttu-id="4bc44-147">Rufen Sie <xref:System.Xaml.XamlXmlReader.Read%2A> auf, um den XAML-Reader auf den nächsten Knoten im XAML-Knotenstream zu setzen, und wiederholen Sie die Schritte.</span><span class="sxs-lookup"><span data-stu-id="4bc44-147">Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.</span></span>

<span data-ttu-id="4bc44-148">Der von XAML-Readern der .NET Framework-XAML-Dienste bereitgestellte XAML-Knotenstream stellt immer einen vollständigen, tiefen Durchlauf aller möglichen Knoten bereit.</span><span class="sxs-lookup"><span data-stu-id="4bc44-148">The XAML node stream provided by .NET Framework XAML Services XAML readers always provides a full, deep traversal of all possible nodes.</span></span> <span data-ttu-id="4bc44-149">Typische Flusssteuerungstechniken für eine XAML-Knotenschleife umfassen die Definition eines Texts in `while (reader.Read())`und das Aktivieren von <xref:System.Xaml.XamlXmlReader.NodeType%2A> an jedem Knotenpunkt in der Knotenschleife.</span><span class="sxs-lookup"><span data-stu-id="4bc44-149">Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop.</span></span>

<span data-ttu-id="4bc44-150">Wenn sich der Knotenstream am Dateiende befindet, ist der aktuelle Knoten null.</span><span class="sxs-lookup"><span data-stu-id="4bc44-150">If the node stream is at end of file, the current node is null.</span></span>

<span data-ttu-id="4bc44-151">Das folgende Beispiel zeigt die einfachste Schleife mit einem Reader und Writer.</span><span class="sxs-lookup"><span data-stu-id="4bc44-151">The simplest loop that uses a reader and writer resembles the following example.</span></span>

```csharp
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));
//where xamlStringToLoad is a string of well formed XAML
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);
while (xxr.Read()) {
  xow.WriteNode(xxr);
}
```

<span data-ttu-id="4bc44-152">In diesem grundlegenden Beispiel für eine Ladepfad-XAML-Knotenschleife werden XAML-Reader und XAML-Writer verbunden. Dies entspricht der Verwendung von <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4bc44-152">This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4bc44-153">Aber diese grundlegende Struktur wird anschließend dem Lese- oder Schreibeszenario entsprechend erweitert.</span><span class="sxs-lookup"><span data-stu-id="4bc44-153">But this basic structure is then expanded to apply to your reading or writing scenario.</span></span> <span data-ttu-id="4bc44-154">Im Folgenden sind einige mögliche Szenarien angegeben:</span><span class="sxs-lookup"><span data-stu-id="4bc44-154">Some possible scenarios are as follows:</span></span>

- <span data-ttu-id="4bc44-155"><xref:System.Xaml.XamlXmlReader.NodeType%2A>aktivieren.</span><span class="sxs-lookup"><span data-stu-id="4bc44-155">Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span> <span data-ttu-id="4bc44-156">Unterschiedliche Aktionen abhängig vom gelesenen Knotentyp ausführen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-156">Perform different actions depending on which node type is being read.</span></span>

- <span data-ttu-id="4bc44-157"><xref:System.Xaml.XamlWriter.WriteNode%2A> nicht in jedem Fall aufrufen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-157">Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases.</span></span> <span data-ttu-id="4bc44-158"><xref:System.Xaml.XamlWriter.WriteNode%2A> nur in einigen <xref:System.Xaml.XamlXmlReader.NodeType%2A> -Fällen aufrufen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-158">Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases.</span></span>

- <span data-ttu-id="4bc44-159">Innerhalb der Logik für einen bestimmten Knotentyp die Einzelheiten dieses Knotens analysieren und entsprechend reagieren.</span><span class="sxs-lookup"><span data-stu-id="4bc44-159">Within the logic for a particular node type, analyze the specifics of that node and act on them.</span></span> <span data-ttu-id="4bc44-160">Zum Beispiel könnten nur Objekte geschrieben werden, die von einem bestimmten XAML-Namespace stammen, und anschließend alle Objekte ausgelassen oder zurückgestellt werden, die nicht von diesem XAML-Namespace stammen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-160">For example, you could write only objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace.</span></span> <span data-ttu-id="4bc44-161">Es könnten auch beliebige XAML-Direktiven, die das XAML-System nicht als Teil der Memberverarbeitung unterstützt, ausgelassen oder andernfalls erneut verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-161">Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.</span></span>

- <span data-ttu-id="4bc44-162">Ein benutzerdefiniertes <xref:System.Xaml.XamlObjectWriter> -Element definieren, von dem `Write*` -Methoden überschrieben werden und möglicherweise eine Typzuordnung ausgeführt wird, die den XAML-Schemakontext umgeht.</span><span class="sxs-lookup"><span data-stu-id="4bc44-162">Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context.</span></span>

- <span data-ttu-id="4bc44-163">Den <xref:System.Xaml.XamlXmlReader> mit einem nicht standardmäßigen XAML-Schemakontext erstellen, sodass benutzerdefinierte Unterschiede im XAML-Verhalten sowohl vom Reader als auch vom Writer verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-163">Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.</span></span>

### <a name="accessing-xaml-beyond-the-node-loop-concept"></a><span data-ttu-id="4bc44-164">Zugreifen auf XAML außerhalb des Knotenschleifenkonzepts</span><span class="sxs-lookup"><span data-stu-id="4bc44-164">Accessing XAML Beyond the Node Loop Concept</span></span>

<span data-ttu-id="4bc44-165">Es gibt andere Möglichkeiten als eine XAML-Knotenschleife, um mit einer XAML-Darstellung zu arbeiten.</span><span class="sxs-lookup"><span data-stu-id="4bc44-165">There are potentially other ways to work with a XAML representation other than as a XAML node loop.</span></span> <span data-ttu-id="4bc44-166">Es könnte z. B. ein XAML-Reader vorhanden sein, der einen indizierten Knoten lesen kann oder insbesondere direkt über `x:Name`, über `x:Uid`oder über andere Bezeichner auf Knoten zugreift.</span><span class="sxs-lookup"><span data-stu-id="4bc44-166">For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers.</span></span> <span data-ttu-id="4bc44-167">.NET Framework-XAML-Dienste bieten keine vollständige Implementierung, sondern stellen ein vorgeschlagenes Muster über Dienste und Unterstützungstypen bereit.</span><span class="sxs-lookup"><span data-stu-id="4bc44-167">.NET Framework XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types.</span></span> <span data-ttu-id="4bc44-168">Weitere Informationen finden Sie unter <xref:System.Xaml.IXamlIndexingReader> und <xref:System.Xaml.XamlNodeList>.</span><span class="sxs-lookup"><span data-stu-id="4bc44-168">For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>.</span></span>

> [!TIP]
> <span data-ttu-id="4bc44-169">Microsoft bietet auch eine Out-of-Band-Version an, die als Microsoft XAML Toolkit bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="4bc44-169">Microsoft also produces an out-of-band release known as the Microsoft XAML Toolkit.</span></span> <span data-ttu-id="4bc44-170">Diese Out-of-Band-Version befindet sich noch in den Vorabveröffentlichungsphasen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-170">This out-of-band release is still in its pre-release stages.</span></span> <span data-ttu-id="4bc44-171">Wenn Sie jedoch bereit sind, mit Vorabveröffentlichungskomponenten zu arbeiten, finden Sie im Microsoft XAML Toolkit mehrere interessante Ressourcen für XAML-Tools und die statische Analyse von XAML.</span><span class="sxs-lookup"><span data-stu-id="4bc44-171">However, if you are willing to work with pre-release components, the Microsoft XAML Toolkit provides some interesting resources for XAML tooling and static analysis of XAML.</span></span> <span data-ttu-id="4bc44-172">Das Microsoft XAML Toolkit bietet eine XAML-DOM-API, Unterstützung für die FxCop-Analyse und einen XAML-Schemakontext für Silverlight.</span><span class="sxs-lookup"><span data-stu-id="4bc44-172">The Microsoft XAML Toolkit includes a XAML DOM API, support for FxCop analysis, and a XAML schema context for Silverlight.</span></span> <span data-ttu-id="4bc44-173">Weitere Informationen finden Sie unter [Microsoft XAML Toolkit](https://code.msdn.microsoft.com/XAML).</span><span class="sxs-lookup"><span data-stu-id="4bc44-173">For more information, see [Microsoft XAML Toolkit](https://code.msdn.microsoft.com/XAML).</span></span>

<a name="working_with_the_current_node"></a>

## <a name="working-with-the-current-node"></a><span data-ttu-id="4bc44-174">Arbeiten mit dem aktuellen Code</span><span class="sxs-lookup"><span data-stu-id="4bc44-174">Working with the Current Node</span></span>

<span data-ttu-id="4bc44-175">Bei den meisten Szenarien mit einer XAML-Knotenschleife werden die Knoten nicht nur gelesen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-175">Most scenarios that use a XAML node loop do not only read the nodes.</span></span> <span data-ttu-id="4bc44-176">In den meisten Szenarien werden aktuelle Knoten verarbeitet, und jeder Knoten wird einzeln an eine Implementierung von <xref:System.Xaml.XamlWriter>übergeben.</span><span class="sxs-lookup"><span data-stu-id="4bc44-176">Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>.</span></span>

<span data-ttu-id="4bc44-177">Im typischen Ladepfadszenario erzeugt ein <xref:System.Xaml.XamlXmlReader> einen XAML-Knotenstream. Die XAML-Knoten werden entsprechend der Logik und dem XAML-Schemakontext verarbeitet und an einen <xref:System.Xaml.XamlObjectWriter>übergeben.</span><span class="sxs-lookup"><span data-stu-id="4bc44-177">In the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="4bc44-178">Anschließend integrieren Sie das resultierende Objektdiagramm in die Anwendung oder das Framework.</span><span class="sxs-lookup"><span data-stu-id="4bc44-178">You then integrate the resulting object graph into your application or framework.</span></span>

<span data-ttu-id="4bc44-179">In einem typischen Speicherpfadszenario liest ein <xref:System.Xaml.XamlObjectReader> das Objektdiagramm, einzelne XAML-Knoten werden verarbeitet, und ein <xref:System.Xaml.XamlXmlWriter> gibt das serialisierte Ergebnis als XAML-Textdatei aus.</span><span class="sxs-lookup"><span data-stu-id="4bc44-179">In a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file.</span></span> <span data-ttu-id="4bc44-180">Der wichtigste Aspekt dabei ist, dass bei beiden Pfaden und Szenarien jeweils mit genau einem XAML-Knoten gearbeitet wird und die XAML-Knoten für die standardisierte Behandlung verfügbar sind, die im XAML-Typsystem und den .NET Framework-XAML-Dienste-APIs definiert ist.</span><span class="sxs-lookup"><span data-stu-id="4bc44-180">The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET Framework XAML Services APIs.</span></span>

### <a name="frames-and-scope"></a><span data-ttu-id="4bc44-181">Frames und Bereich</span><span class="sxs-lookup"><span data-stu-id="4bc44-181">Frames and Scope</span></span>

<span data-ttu-id="4bc44-182">Eine XAML-Knotenschleife durchläuft einen XAML-Knotenstream linear.</span><span class="sxs-lookup"><span data-stu-id="4bc44-182">A XAML node loop walks through a XAML node stream in a linear way.</span></span> <span data-ttu-id="4bc44-183">Der Knotenstream durchläuft Objekte, Member, die andere Objekte enthalten, usw.</span><span class="sxs-lookup"><span data-stu-id="4bc44-183">The node stream traverses into objects, into members that contain other objects, and so on.</span></span> <span data-ttu-id="4bc44-184">Oft ist es hilfreich, den Bereich innerhalb des XAML-Knotenstreams durch Implementieren eines Frame- und Stapelkonzepts nachzuverfolgen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-184">It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept.</span></span> <span data-ttu-id="4bc44-185">Dies gilt besonders, wenn Sie den Knotenstream aktiv anpassen, währen Sie sich darin befinden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-185">This is particularly true if you are actively adjusting the node stream while you are in it.</span></span> <span data-ttu-id="4bc44-186">Die Frame- und Stapelunterstützung, die Sie als Teil der Knotenschleifenlogik implementieren, könnte die Bereiche `StartObject` (oder `GetObject`) und `EndObject` zählen, während Sie eine XAML-Knotenstruktur – bei Betrachtung aus der DOM-Perspektive – nach unten durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-186">The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.</span></span>

<a name="traversing_and_entering_object_nodes"></a>

## <a name="traversing-and-entering-object-nodes"></a><span data-ttu-id="4bc44-187">Durchlaufen und Eingeben von Objektknoten</span><span class="sxs-lookup"><span data-stu-id="4bc44-187">Traversing and Entering Object Nodes</span></span>

<span data-ttu-id="4bc44-188">Der erste von einem XAML-Reader geöffnete Knoten in einem Knotenstream ist der Startobjektknoten des Stammobjekts.</span><span class="sxs-lookup"><span data-stu-id="4bc44-188">The first node in a node stream when it is opened by a XAML reader is the start-object node of the root object.</span></span> <span data-ttu-id="4bc44-189">Definitionsgemäß ist dieses Objekt immer ein einzelner Objektknoten ohne Peers.</span><span class="sxs-lookup"><span data-stu-id="4bc44-189">By definition, this object is always a single object node and has no peers.</span></span> <span data-ttu-id="4bc44-190">In einem realen XAML-Beispiel wird das Stammobjekt so definiert, dass es über eine oder mehrere Eigenschaften verfügt, die mehrere Objekte enthalten, und diese Eigenschaften verfügen über Memberknoten.</span><span class="sxs-lookup"><span data-stu-id="4bc44-190">In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes.</span></span> <span data-ttu-id="4bc44-191">Die Memberknoten verfügen dann über mindestens einen Objektknoten oder könnten stattdessen auch in einem Wertknoten beendet werden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-191">The member nodes then have one or more object nodes, or might also terminate in a value node instead.</span></span> <span data-ttu-id="4bc44-192">Das Stammobjekt definiert normalerweise XAML-Namensbereiche, die syntaktisch als Attribute im XAML-Textmarkup zugewiesen werden, aber einem `Namescope` -Knotentyp in der XAML-Knotenstreamdarstellung entsprechen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-192">The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation.</span></span>

<span data-ttu-id="4bc44-193">Sehen Sie sich das folgende XAML-Beispiel an (dies ist beliebige XAML, die von in .NET Framework vorhandenen Typen nicht unterstützt wird).</span><span class="sxs-lookup"><span data-stu-id="4bc44-193">Consider the following XAML example (this is arbitrary XAML, not backed by existing types in the .NET Framework).</span></span> <span data-ttu-id="4bc44-194">Angenommen, in diesem Objektmodell gilt Folgendes: `FavorCollection` ist `List<T>` von `Favor`, `Balloon` und `NoiseMaker` können `Favor`zugewiesen werden, die `Balloon.Color` -Eigenschaft wird von einem `Color` -Objekt unterstützt (ähnlich der WPF-Definition von Farben als bekannte Farbnamen), und `Color` unterstützt einen Typkonverter für die Attributsyntax.</span><span class="sxs-lookup"><span data-stu-id="4bc44-194">Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax.</span></span>

|<span data-ttu-id="4bc44-195">XAML-Markup</span><span class="sxs-lookup"><span data-stu-id="4bc44-195">XAML markup</span></span>|<span data-ttu-id="4bc44-196">Sich ergebender XAML-Knotenstream</span><span class="sxs-lookup"><span data-stu-id="4bc44-196">Resulting XAML node stream</span></span>|
|-----------------|--------------------------------|
|`<Party`|<span data-ttu-id="4bc44-197">`Namespace` -Knoten für `Party`</span><span class="sxs-lookup"><span data-stu-id="4bc44-197">`Namespace` node for `Party`</span></span>|
|`xmlns="PartyXamlNamespace">`|<span data-ttu-id="4bc44-198">`StartObject` -Knoten für `Party`</span><span class="sxs-lookup"><span data-stu-id="4bc44-198">`StartObject` node for `Party`</span></span>|
|`<Party.Favors>`|<span data-ttu-id="4bc44-199">`StartMember` -Knoten für `Party.Favors`</span><span class="sxs-lookup"><span data-stu-id="4bc44-199">`StartMember` node for `Party.Favors`</span></span>|
||<span data-ttu-id="4bc44-200">`StartObject` -Knoten für implizite `FavorCollection`</span><span class="sxs-lookup"><span data-stu-id="4bc44-200">`StartObject` node for implicit `FavorCollection`</span></span>|
||<span data-ttu-id="4bc44-201">`StartMember` -Knoten für implizite `FavorCollection` -Elementeigenschaft</span><span class="sxs-lookup"><span data-stu-id="4bc44-201">`StartMember` node for implicit `FavorCollection` items property.</span></span>|
|`<Balloon`|<span data-ttu-id="4bc44-202">`StartObject` -Knoten für `Balloon`</span><span class="sxs-lookup"><span data-stu-id="4bc44-202">`StartObject` node for `Balloon`</span></span>|
|`Color="Red"`|<span data-ttu-id="4bc44-203">`StartMember` -Knoten für `Color`</span><span class="sxs-lookup"><span data-stu-id="4bc44-203">`StartMember` node for `Color`</span></span><br /><br /> <span data-ttu-id="4bc44-204">`Value` -Knoten für Attributwertzeichenfolge `"Red"`</span><span class="sxs-lookup"><span data-stu-id="4bc44-204">`Value` node for the attribute value string `"Red"`</span></span><br /><br /> <span data-ttu-id="4bc44-205">`EndMember` für `Color`</span><span class="sxs-lookup"><span data-stu-id="4bc44-205">`EndMember` for `Color`</span></span>|
|`HasHelium="True"`|<span data-ttu-id="4bc44-206">`StartMember` -Knoten für `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="4bc44-206">`StartMember` node for `HasHelium`</span></span><br /><br /> <span data-ttu-id="4bc44-207">`Value` -Knoten für Attributwertzeichenfolge `"True"`</span><span class="sxs-lookup"><span data-stu-id="4bc44-207">`Value` node for the attribute value string `"True"`</span></span><br /><br /> <span data-ttu-id="4bc44-208">`EndMember` für `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="4bc44-208">`EndMember` for `HasHelium`</span></span>|
|`>`|<span data-ttu-id="4bc44-209">`EndObject` für `Balloon`</span><span class="sxs-lookup"><span data-stu-id="4bc44-209">`EndObject` for `Balloon`</span></span>|
|`<NoiseMaker>Loudest</NoiseMaker>`|<span data-ttu-id="4bc44-210">`StartObject` -Knoten für `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="4bc44-210">`StartObject` node for `NoiseMaker`</span></span><br /><br /> <span data-ttu-id="4bc44-211">`StartMember` -Knoten für `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="4bc44-211">`StartMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="4bc44-212">`Value` -Knoten für Initialisierungswertzeichenfolge `"Loudest"`</span><span class="sxs-lookup"><span data-stu-id="4bc44-212">`Value` node for the initialization value string `"Loudest"`</span></span><br /><br /> <span data-ttu-id="4bc44-213">`EndMember` -Knoten für `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="4bc44-213">`EndMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="4bc44-214">`EndObject` für `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="4bc44-214">`EndObject` for `NoiseMaker`</span></span>|
||<span data-ttu-id="4bc44-215">`EndMember` -Knoten für implizite `FavorCollection` -Elementeigenschaft</span><span class="sxs-lookup"><span data-stu-id="4bc44-215">`EndMember` node for implicit `FavorCollection` items property.</span></span>|
||<span data-ttu-id="4bc44-216">`EndObject` -Knoten für implizite `FavorCollection`</span><span class="sxs-lookup"><span data-stu-id="4bc44-216">`EndObject` node for implicit `FavorCollection`</span></span>|
|`</Party.Favors>`|<span data-ttu-id="4bc44-217">`EndMember` für `Favors`</span><span class="sxs-lookup"><span data-stu-id="4bc44-217">`EndMember` for `Favors`</span></span>|
|`</Party>`|<span data-ttu-id="4bc44-218">`EndObject` für `Party`</span><span class="sxs-lookup"><span data-stu-id="4bc44-218">`EndObject` for `Party`</span></span>|

<span data-ttu-id="4bc44-219">Im XAML-Knotenstream wird das folgende Verhalten verwendet:</span><span class="sxs-lookup"><span data-stu-id="4bc44-219">In the XAML node stream, you can rely on the following behavior:</span></span>

- <span data-ttu-id="4bc44-220">Wenn ein `Namespace` -Knoten vorhanden ist, wird er dem Stream unmittelbar vor dem `StartObject` hinzugefügt, von dem der XAML-Namespace mit `xmlns`deklariert wurde.</span><span class="sxs-lookup"><span data-stu-id="4bc44-220">If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`.</span></span> <span data-ttu-id="4bc44-221">Werfen Sie erneut einen Blick auf die vorherige Tabelle mit der XAML und dem Beispielknotenstream.</span><span class="sxs-lookup"><span data-stu-id="4bc44-221">Look at the previous table with the XAML and example node stream again.</span></span> <span data-ttu-id="4bc44-222">Beachten Sie, dass die `StartObject` - und `Namespace` -Knoten im Vergleich zu ihren Deklarationspositionen im Textmarkup versetzt zu sein scheinen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-222">Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup.</span></span> <span data-ttu-id="4bc44-223">Dies entspricht dem Verhalten, bei dem die Namespaceknoten immer vor dem Knoten angezeigt werden, für den sie im Knotenstream gelten.</span><span class="sxs-lookup"><span data-stu-id="4bc44-223">This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream.</span></span> <span data-ttu-id="4bc44-224">Dieser Entwurf begründet sich dadurch, dass die Namespaceinformationen für Objektwriter unerlässlich sind und bekannt sein müssen, bevor der Objektwriter versucht, die Typzuordnung auszuführen oder das Objekt anderweitig zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="4bc44-224">The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object.</span></span> <span data-ttu-id="4bc44-225">Indem die XAML-Namespaceinformationen im Stream vor ihrem Anwendungsbereich platziert werden, ist es leichter, den Knotenstream immer in der dargestellten Reihenfolge zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="4bc44-225">Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.</span></span>

- <span data-ttu-id="4bc44-226">Wie bereits dargelegt, wird in den meisten realen Markupfällen zuerst mindestens ein `Namespace` -Knoten gelesen, wenn Knoten vom Start und nicht vom `StartObject` des Stamms durchlaufen werden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-226">Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root.</span></span>

- <span data-ttu-id="4bc44-227">Einem `StartObject` -Knoten kann `StartMember`, `Value`oder direkt `EndObject`folgen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-227">A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`.</span></span> <span data-ttu-id="4bc44-228">Ihm folgt nie sofort ein weiteres `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="4bc44-228">It is never followed immediately by another `StartObject`.</span></span>

- <span data-ttu-id="4bc44-229">Einem `StartMember` -Element kann `StartObject`, `Value`oder direkt `EndMember`folgen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-229">A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`.</span></span> <span data-ttu-id="4bc44-230">Bei Membern, bei denen der Wert aus einem vorhandenen Wert des übergeordneten Objekts und nicht aus einem `GetObject`stammt, das einen neuen Wert instanziieren würde, kann ihm `StartObject` folgen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-230">It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value.</span></span> <span data-ttu-id="4bc44-231">Ihm kann auch ein `Namespace` -Knoten folgen, der für ein späteres `StartObject`gilt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-231">It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span> <span data-ttu-id="4bc44-232">Ihm folgt nie sofort ein weiteres `StartMember`.</span><span class="sxs-lookup"><span data-stu-id="4bc44-232">It is never followed immediately by another `StartMember`.</span></span>

- <span data-ttu-id="4bc44-233">Ein `Value` -Knoten stellt den Wert selbst dar. Es gibt kein "EndValue"-Element.</span><span class="sxs-lookup"><span data-stu-id="4bc44-233">A `Value` node represents the value itself; there is no "EndValue".</span></span> <span data-ttu-id="4bc44-234">Ihm kann nur ein `EndMember`folgen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-234">It can be followed only by an `EndMember`.</span></span>

  - <span data-ttu-id="4bc44-235">Der XAML-Initialisierungstext des Objekts, wie er von der Konstruktion verwendet werden könnte, führt nicht zu einer Object-Value-Struktur.</span><span class="sxs-lookup"><span data-stu-id="4bc44-235">XAML initialization text of the object as might be used by construction does not result in an Object-Value structure.</span></span> <span data-ttu-id="4bc44-236">Stattdessen wird ein dedizierter Memberknoten für einen Member mit dem Namen `_Initialization` erstellt</span><span class="sxs-lookup"><span data-stu-id="4bc44-236">Instead, a dedicated member node for a member named `_Initialization` is created.</span></span> <span data-ttu-id="4bc44-237">und dieser Memberknoten enthält die Initialisierungswertzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="4bc44-237">and that member node contains the initialization value string.</span></span> <span data-ttu-id="4bc44-238">Falls vorhanden, ist `_Initialization` immer der erste `StartMember`.</span><span class="sxs-lookup"><span data-stu-id="4bc44-238">If it exists, `_Initialization` is always the first `StartMember`.</span></span> <span data-ttu-id="4bc44-239">`_Initialization` wird in einigen XAML-Dienst-Darstellungen möglicherweise mit dem XAML-Namensbereich der XAML-Sprache qualifiziert, um klarzustellen, dass `_Initialization` keine definierte Eigenschaft in Unterstützungstypen ist.</span><span class="sxs-lookup"><span data-stu-id="4bc44-239">`_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types.</span></span>

  - <span data-ttu-id="4bc44-240">Eine Member-Wert-Kombination stellt eine Attributeinstellung des Werts dar.</span><span class="sxs-lookup"><span data-stu-id="4bc44-240">A Member-Value combination represents an attribute setting of the value.</span></span> <span data-ttu-id="4bc44-241">An der Verarbeitung dieses Werts kann ein Wertkonverter beteiligt sein, und der Wert ist eine einfache Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="4bc44-241">There might eventually be a value converter involved in processing this value, and the value is a plain string.</span></span> <span data-ttu-id="4bc44-242">Das wird jedoch erst ausgewertet, wenn ein XAML-Objektwriter diesen Knotenstream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="4bc44-242">However, that is not evaluated until a XAML object writer processes this node stream.</span></span> <span data-ttu-id="4bc44-243">Der XAML-Objektwriter besitzt den notwendigen XAML-Schemakontext, die Typsystemzuordnung und andere Unterstützung, die für Wertkonvertierungen benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="4bc44-243">The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.</span></span>

- <span data-ttu-id="4bc44-244">Einem `EndMember` -Knoten kann ein `StartMember` -Knoten für einen nachfolgenden Member oder ein `EndObject` -Knoten für den Memberbesitzer folgen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-244">An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner.</span></span>

- <span data-ttu-id="4bc44-245">Einem `EndObject` -Knoten kann ein `EndMember` -Knoten folgen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-245">An `EndObject` node can be followed by an `EndMember` node.</span></span> <span data-ttu-id="4bc44-246">In Fällen, in denen Objekte Peers in den Elementen einer Auflistung sind, kann ihm auch ein `StartObject` -Knoten folgen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-246">It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items.</span></span> <span data-ttu-id="4bc44-247">Ihm kann auch ein `Namespace` -Knoten folgen, der für ein späteres `StartObject`gilt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-247">Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span>

  - <span data-ttu-id="4bc44-248">In dem besonderen Fall, dass ein gesamter Knotenstream geschlossen wird, folgt dem `EndObject` -Element des Stamms kein weiteres Element. Der Reader befindet sich jetzt am Dateiende, und <xref:System.Xaml.XamlReader.Read%2A> gibt `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="4bc44-248">For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`.</span></span>

<a name="value_converters_and_the_xaml_node_stream"></a>

## <a name="value-converters-and-the-xaml-node-stream"></a><span data-ttu-id="4bc44-249">Wertkonverter und der XAML-Knotenstream</span><span class="sxs-lookup"><span data-stu-id="4bc44-249">Value Converters and the XAML Node Stream</span></span>

<span data-ttu-id="4bc44-250">Ein Wertkonverter ist ein allgemeiner Begriff für eine Markuperweiterung, einen Typkonverter (einschließlich Wertserialisierungsprogrammen) oder eine andere dedizierte Klasse, die über das XAML-Typsystem als Wertkonverter gemeldet wird.</span><span class="sxs-lookup"><span data-stu-id="4bc44-250">A value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system.</span></span> <span data-ttu-id="4bc44-251">Im XAML-Knotenstream werden eine Typkonverterverwendung und eine Markuperweiterungsverwendung sehr unterschiedlich dargestellt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-251">In the XAML node stream, a type converter usage and a markup extension usage have very different representations.</span></span>

### <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="4bc44-252">Typkonverter im XAML-Knotenstream</span><span class="sxs-lookup"><span data-stu-id="4bc44-252">Type Converters in the XAML Node Stream</span></span>

<span data-ttu-id="4bc44-253">Ein festgelegtes Attribut, das schließlich zu einer Typkonverterverwendung führt, wird im XAML-Knotenstream als Wert eines Members gemeldet.</span><span class="sxs-lookup"><span data-stu-id="4bc44-253">An attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member.</span></span> <span data-ttu-id="4bc44-254">Der XAML-Knotenstream versucht nicht, ein Typkonverterinstanzobjekt zu erzeugen und den Wert an dieses Objekt zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="4bc44-254">The XAML node stream does not attempt to produce a type converter instance object and pass the value to it.</span></span> <span data-ttu-id="4bc44-255">Zur Verwendung einer Konvertierungsimplementierung des Typkonverters muss der XAML-Schemakontext aufgerufen und zur Typzuordnung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-255">Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping.</span></span> <span data-ttu-id="4bc44-256">Selbst die Bestimmung, welche Typkonverterklasse zum Verarbeiten des Werts verwendet werden soll, erfordert indirekt den XAML-Schemakontext.</span><span class="sxs-lookup"><span data-stu-id="4bc44-256">Even determining which type converter class should be used to process the value requires the XAML schema context indirectly.</span></span> <span data-ttu-id="4bc44-257">Wenn Sie den XAML-Standardschemakontext verwenden, sind diese Informationen im XAML-Typsystem verfügbar.</span><span class="sxs-lookup"><span data-stu-id="4bc44-257">When you use the default XAML schema context, that information is available from the XAML type system.</span></span> <span data-ttu-id="4bc44-258">Falls Sie die Informationen zur Typkonverterklasse auf der XAML-Knotenstreamebene vor der Verbindung mit einem XAML-Writer benötigen, können Sie sie aus den <xref:System.Xaml.XamlMember> -Informationen des festgelegten Members abrufen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-258">If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set.</span></span> <span data-ttu-id="4bc44-259">Andernfalls sollte die Typkonvertereingabe im XAML-Knotenstream als einfacher Wert beibehalten werden, bis die übrigen Vorgänge, die das Typzuordnungssystem und den XAML-Schemakontext erfordern (z. B. die Objekterstellung durch einen XAML-Objektwriter), ausgeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-259">But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.</span></span>

<span data-ttu-id="4bc44-260">Werfen Sie z. B. einen Blick auf die folgende Klassendefinitionsgliederung und die entsprechende XAML-Verwendung:</span><span class="sxs-lookup"><span data-stu-id="4bc44-260">For example, consider the following class definition outline and XAML usage for it:</span></span>

```csharp
public class BoardSizeConverter : TypeConverter {
  //converts from string to an int[2] by splitting on an "x" char
}
public class GameBoard {
  [TypeConverter(typeof(BoardSizeConverter))]
  public int[] BoardSize; //2x2 array, initialization not shown
}
```

```xaml
<GameBoard BoardSize="8x8"/>
```

<span data-ttu-id="4bc44-261">Eine Textdarstellung des XAML-Knotenstreams für diese Verwendung könnte folgendermaßen aussehen:</span><span class="sxs-lookup"><span data-stu-id="4bc44-261">A text representation of the XAML node stream for this usage could be expressed as the following:</span></span>

<span data-ttu-id="4bc44-262">Ein`StartObject` -Element mit <xref:System.Xaml.XamlType> , das `GameBoard`darstellt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-262">`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`</span></span>

<span data-ttu-id="4bc44-263">Ein`StartMember` -Element mit <xref:System.Xaml.XamlMember> , das `BoardSize`darstellt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-263">`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`</span></span>

<span data-ttu-id="4bc44-264">`Value` -Knoten mit Textzeichenfolge "`8x8`".</span><span class="sxs-lookup"><span data-stu-id="4bc44-264">`Value` node, with text string "`8x8`"</span></span>

<span data-ttu-id="4bc44-265">`EndMember` stimmt mit `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="4bc44-265">`EndMember` matches `BoardSize`</span></span>

<span data-ttu-id="4bc44-266">`EndObject` stimmt mit `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="4bc44-266">`EndObject` matches `GameBoard`</span></span>

<span data-ttu-id="4bc44-267">Beachten Sie, dass es keine Typkonverterinstanz in diesem Knotenstream gibt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-267">Notice that there is no type converter instance in this node stream.</span></span> <span data-ttu-id="4bc44-268">Sie können Typkonverterinformationen jedoch abrufen, indem Sie <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> für den <xref:System.Xaml.XamlMember> für `BoardSize`aufrufen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-268">But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`.</span></span> <span data-ttu-id="4bc44-269">Wenn ein gültiger XAML-Schemakontext vorhanden ist, können Sie die Konvertermethoden auch aufrufen, indem Sie eine Instanz von <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>abrufen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-269">If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span></span>

### <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="4bc44-270">Markuperweiterungen im XAML-Knotenstream</span><span class="sxs-lookup"><span data-stu-id="4bc44-270">Markup Extensions in the XAML Node Stream</span></span>

<span data-ttu-id="4bc44-271">Eine Markuperweiterungsverwendung wird im XAML-Knotenstream als Objektknoten innerhalb eines Members gemeldet, wobei das Objekt eine Markuperweiterungsinstanz darstellt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-271">A markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance.</span></span> <span data-ttu-id="4bc44-272">Folglich wird eine Markuperweiterungsverwendung in der Knotenstreamdarstellung genauer dargestellt als eine Typkonverterverwendung, und sie enthält mehr Informationen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-272">Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information.</span></span> <span data-ttu-id="4bc44-273"><xref:System.Xaml.XamlMember> -Informationen enthalten keine Informationen zur Markuperweiterung, da die Verwendung situationsbedingt ist und sich in jedem möglichen Markupfall ändert. Sie sind ebenso wie Typkonverter für Typen oder Member nicht dediziert oder implizit.</span><span class="sxs-lookup"><span data-stu-id="4bc44-273"><xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.</span></span>

<span data-ttu-id="4bc44-274">Markuperweiterungen werden in der Knotenstreamdarstellung auch dann als Objektknoten dargestellt, wenn die Markuperweiterungsverwendung im XAML-Textmarkup in Attributform erfolgte, was häufig der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="4bc44-274">The node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case).</span></span> <span data-ttu-id="4bc44-275">Markuperweiterungsverwendungen, bei denen ein explizites Objektelementformular verwendet wurde, werden auf dieselbe Weise behandelt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-275">Markup extension usages that used an explicit object element form are treated the same way.</span></span>

<span data-ttu-id="4bc44-276">Innerhalb eines Objektknotens für die Markuperweiterung sind möglicherweise Member dieser Markuperweiterung vorhanden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-276">Within a markup extension object node, there may be members of that markup extension.</span></span> <span data-ttu-id="4bc44-277">Die XAML-Knotenstreamdarstellung behält die Verwendung dieser Markuperweiterung bei, ganz gleich, ob es sich um eine Positionsparameterverwendung oder eine Verwendung mit expliziten benannten Parametern handelt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-277">The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.</span></span>

<span data-ttu-id="4bc44-278">Bei einer Positionsparameterverwendung enthält der XAML-Knotenstream eine durch die XAML-Sprache definierte Eigenschaft `_PositionalParameters` , von der die Verwendung aufgezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="4bc44-278">For a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage.</span></span> <span data-ttu-id="4bc44-279">Diese Eigenschaft ist ein generisches <xref:System.Collections.Generic.List%601> -Element mit <xref:System.Object> -Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="4bc44-279">This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint.</span></span> <span data-ttu-id="4bc44-280">Die Einschränkung ist ein Objekt und keine Zeichenfolge, da eine Positionsparameterverwendung u. U. geschachtelte Markuperweiterungsverwendungen enthalten könnte.</span><span class="sxs-lookup"><span data-stu-id="4bc44-280">The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it.</span></span> <span data-ttu-id="4bc44-281">Sie können die Liste durchlaufen und die Indexer für einzelne Listenwerte verwenden, um auf die Positionsparameter der Verwendung zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-281">To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.</span></span>

<span data-ttu-id="4bc44-282">Bei einer benannten Parameterverwendung wird jeder benannte Parameter als Memberknoten des Namens im Knotenstream dargestellt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-282">For a named parameter usage, each named parameter is represented as a member node of that name in the node stream.</span></span> <span data-ttu-id="4bc44-283">Die Memberwerte sind nicht unbedingt Zeichenfolgen, da eine geschachtelte Markuperweiterungsverwendung vorhanden sein könnte.</span><span class="sxs-lookup"><span data-stu-id="4bc44-283">The member values are not necessarily strings, because there could be a nested markup extension usage.</span></span>

<span data-ttu-id="4bc44-284">Das`ProvideValue` -Element wird noch nicht von der Markuperweiterung aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-284">`ProvideValue` from the markup extension is not yet invoked.</span></span> <span data-ttu-id="4bc44-285">Es wird jedoch aufgerufen, wenn Sie einen XAML-Reader und einen XAML-Writer verbinden, sodass beim Untersuchen im Knotenstream `WriteEndObject` für den Markuperweiterungsknoten aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="4bc44-285">However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream.</span></span> <span data-ttu-id="4bc44-286">Aus diesem Grund muss im Allgemeinen derselbe XAML-Schemakontext verfügbar sein wie für die Bildung des Objektdiagramms auf dem Ladepfad.</span><span class="sxs-lookup"><span data-stu-id="4bc44-286">For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path.</span></span> <span data-ttu-id="4bc44-287">Andernfalls kann `ProvideValue` in jeder Markuperweiterung Ausnahmen auslösen, da keine erwarteten Dienste verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="4bc44-287">Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available.</span></span>

<a name="xaml_and_xml_languagedefined_members_in_the_xaml_node_stream"></a>

## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a><span data-ttu-id="4bc44-288">Durch XAML- und XML-Sprache definierte Member im XAML-Knotenstream</span><span class="sxs-lookup"><span data-stu-id="4bc44-288">XAML and XML Language-Defined Members in the XAML Node Stream</span></span>

<span data-ttu-id="4bc44-289">Bestimmte Member werden aufgrund von Interpretationen und Konventionen eines XAML-Readers in einem XAML-Knotenstream implementiert und nicht durch eine explizite <xref:System.Xaml.XamlMember> -Suche oder -Konstruktion.</span><span class="sxs-lookup"><span data-stu-id="4bc44-289">Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction.</span></span> <span data-ttu-id="4bc44-290">Häufig sind diese Member XAML-Direktiven.</span><span class="sxs-lookup"><span data-stu-id="4bc44-290">Often, these members are XAML directives.</span></span> <span data-ttu-id="4bc44-291">In einigen Fällen wird die Direktive durch das Lesen der XAML im XAML-Knotenstream eingefügt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-291">In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream.</span></span> <span data-ttu-id="4bc44-292">Das heißt, geben Sie der ursprünglichen XAML-Text das Member-Anweisung nicht explizit angeben, aber der XAML-Reader, fügt der Anweisung um eine strukturelle XAML Konvention und Melden von Informationen im XAML-Knotenstream zu erfüllen, bevor Sie diese Informationen verloren geht.</span><span class="sxs-lookup"><span data-stu-id="4bc44-292">In other words, the original input XAML text did not explicitly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.</span></span>

<span data-ttu-id="4bc44-293">In der folgenden Liste sind alle Fälle aufgeführt, in denen ein XAML-Reader voraussichtlich einen XAML-Memberknoten für eine Direktive einfügt, und es wird beschrieben, wie dieser Memberknoten in den .NET Framework-XAML-Dienstimplementierungen identifiziert wird.</span><span class="sxs-lookup"><span data-stu-id="4bc44-293">The following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in the .NET Framework XAML Services implementations.</span></span>

- <span data-ttu-id="4bc44-294">**Initialisierungstext für einen Objektknoten:** Der Name dieses Memberknotens ist `_Initialization`, er stellt eine XAML-Direktive dar und ist im XAML-Namespace XAML-Sprache definiert.</span><span class="sxs-lookup"><span data-stu-id="4bc44-294">**Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="4bc44-295">Eine entsprechende statische Entität kann aus <xref:System.Xaml.XamlLanguage.Initialization%2A>abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-295">You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span></span>

- <span data-ttu-id="4bc44-296">**Positionsparameter für eine Markuperweiterung:** Der Name dieses Memberknotens ist `_PositionalParameters`, und er ist im XAML-Namespace XAML-Sprache definiert.</span><span class="sxs-lookup"><span data-stu-id="4bc44-296">**Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="4bc44-297">Er enthält immer eine generische Liste von Objekten, bei denen es sich um Positionsparameter handelt, die durch Trennung bei dem im Eingabe-XAML angegebenen `,` -Trennzeichen vorab getrennt werden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-297">It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML.</span></span> <span data-ttu-id="4bc44-298">Eine statische Entität für die Positionsparameterdirektive kann aus <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-298">You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span></span>

- <span data-ttu-id="4bc44-299">**Unbekannter Inhalt:** Der Name dieses Memberknotens ist `_UnknownContent`.</span><span class="sxs-lookup"><span data-stu-id="4bc44-299">**Unknown content:** The name of this member node is `_UnknownContent`.</span></span> <span data-ttu-id="4bc44-300">Streng genommen handelt es sich um ein <xref:System.Xaml.XamlDirective>-Element und ist im XAML-Namespace der XAML-Sprache definiert.</span><span class="sxs-lookup"><span data-stu-id="4bc44-300">Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="4bc44-301">Diese Direktive wird als Sentinel für Fälle verwendet, in denen ein XAML-Objektelement im Quell-XAML Inhalt aufweist, aber keine Inhaltseigenschaft im aktuell verfügbaren XAML-Schemakontext ermittelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="4bc44-301">This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context.</span></span> <span data-ttu-id="4bc44-302">Sie können diesen Fall in einem XAML-Knotenstream erkennen, indem Sie ihn auf Member mit dem Namen `_UnknownContent`prüfen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-302">You can detect this case in a XAML node stream by checking for members named `_UnknownContent`.</span></span> <span data-ttu-id="4bc44-303">Falls keine andere Aktion in einem Ladepfad-XAML-Knotenstream ausgeführt wird, wird der standardmäßige <xref:System.Xaml.XamlObjectWriter> bei versuchtem `WriteEndObject` ausgelöst, wenn der `_UnknownContent` -Member für ein Objekt gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="4bc44-303">If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object.</span></span> <span data-ttu-id="4bc44-304">Der standardmäßige <xref:System.Xaml.XamlXmlWriter> wird nicht ausgelöst, und der Member wird als implizit behandelt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-304">The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit.</span></span> <span data-ttu-id="4bc44-305">Sie können eine statische Entität für `_UnknownContent` von <xref:System.Xaml.XamlLanguage.UnknownContent%2A>abrufen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-305">You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span></span>

- <span data-ttu-id="4bc44-306">**Auflistungseigenschaft einer Auflistung:** Obwohl die CLR-Unterstützungstyp einer Auflistungsklasse, die für XAML, in der Regel verwendet wird eine dedizierte benannte Eigenschaft, die die Elemente der Auflistung enthält hat, ist diese Eigenschaft einem XAML-Typsystem vor der unterstützungstypauflösung nicht bekannt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-306">**Collection property of a collection:** Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution.</span></span> <span data-ttu-id="4bc44-307">Stattdessen fügt der XAML-Knotenstream einen `Items` -Platzhalter als Member des XAML-Auflistungstyps ein.</span><span class="sxs-lookup"><span data-stu-id="4bc44-307">Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type.</span></span> <span data-ttu-id="4bc44-308">In der .NET Framework-XAML-Dienstimplementierung lautet der Name dieser Direktive/dieses Members im Knotenstream `_Items`.</span><span class="sxs-lookup"><span data-stu-id="4bc44-308">In the .NET Framework XAML Services implementation the name of this directive / member in the node stream is `_Items`.</span></span> <span data-ttu-id="4bc44-309">Eine Konstante für diese Direktive kann aus <xref:System.Xaml.XamlLanguage.Items%2A>abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-309">A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>.</span></span>

    <span data-ttu-id="4bc44-310">Beachten Sie, dass ein XAML-Knotenstream eine Items-Eigenschaft mit Elementen enthalten kann, die auf nicht analysierbar sein auf der Grundlage der unterstützungstypauflösung und XAML-Schemakontext.</span><span class="sxs-lookup"><span data-stu-id="4bc44-310">Note that a XAML node stream might contain an Items property with items that turn out to not be parsable based on the backing type resolution and XAML schema context.</span></span> <span data-ttu-id="4bc44-311">Ein auf ein Objekt angewendeter</span><span class="sxs-lookup"><span data-stu-id="4bc44-311">For example,</span></span>

- <span data-ttu-id="4bc44-312">**In XML definierte Member:** Die in XML definierten `xml:base`, `xml:lang` und `xml:space` Elemente werden als XAML-Direktiven, die mit dem Namen gemeldet `base`, `lang`, und `space` in den Implementierungen von .NET Framework-XAML-Dienste.</span><span class="sxs-lookup"><span data-stu-id="4bc44-312">**XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in the .NET Framework XAML Services implementations.</span></span> <span data-ttu-id="4bc44-313">Der Namespace hierfür ist der XML-Namespace `http://www.w3.org/XML/1998/namespace`.</span><span class="sxs-lookup"><span data-stu-id="4bc44-313">The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`.</span></span> <span data-ttu-id="4bc44-314">Konstanten für jedes dieser Elemente können von <xref:System.Xaml.XamlLanguage>abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-314">Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>.</span></span>

## <a name="node-order"></a><span data-ttu-id="4bc44-315">Knotenreihenfolge</span><span class="sxs-lookup"><span data-stu-id="4bc44-315">Node Order</span></span>

<span data-ttu-id="4bc44-316">In einigen Fällen ändert der <xref:System.Xaml.XamlXmlReader> die Reihenfolge von XAML-Knoten im XAML-Knotenstream gegenüber der Reihenfolge, in der die Knoten bei der Anzeige im Markup oder der Verarbeitung als XML angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-316">In some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML.</span></span> <span data-ttu-id="4bc44-317">Dies geschieht, damit die Knoten so sortiert werden, dass ein <xref:System.Xaml.XamlObjectWriter> den Knotenstream nur vorwärts verarbeiten kann.</span><span class="sxs-lookup"><span data-stu-id="4bc44-317">This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner.</span></span>  <span data-ttu-id="4bc44-318">In den .NET Framework-XAML-Diensten ordnet der XAML-Reader Knoten neu, anstatt diese Aufgabe dem XAML-Writer zu überlassen. Dies dient zur Leistungsoptimierung für XAML-Objektwriterconsumer des Knotenstreams.</span><span class="sxs-lookup"><span data-stu-id="4bc44-318">In .NET Framework XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.</span></span>

<span data-ttu-id="4bc44-319">Bestimmte Direktiven sind speziell zum Bereitstellen weiterer Informationen für die Erstellung eines Objekts aus einem Objektelement vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-319">Certain directives are intended specifically to provide more information for the creation of an object from an object element.</span></span> <span data-ttu-id="4bc44-320">Diese Direktiven sind: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`und `Arguments`.</span><span class="sxs-lookup"><span data-stu-id="4bc44-320">These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span></span> <span data-ttu-id="4bc44-321">Die XAML-Reader der .NET Framework-XAML-Dienste versuchen, diese Direktiven als erste Member im Knotenstream nach dem `StartObject`eines Objekts zu platzieren. Die Gründe dafür werden im nächsten Abschnitt erläutert.</span><span class="sxs-lookup"><span data-stu-id="4bc44-321">The .NET Framework XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section.</span></span>

### <a name="xamlobjectwriter-behavior-and-node-order"></a><span data-ttu-id="4bc44-322">XamlObjectWriter-Verhalten und Knotenreihenfolge</span><span class="sxs-lookup"><span data-stu-id="4bc44-322">XamlObjectWriter Behavior and Node Order</span></span>

<span data-ttu-id="4bc44-323">Das`StartObject` für einen <xref:System.Xaml.XamlObjectWriter> ist nicht notwendigerweise ein Signal für den XAML-Objektwriter, die Objektinstanz sofort zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-323">`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance.</span></span> <span data-ttu-id="4bc44-324">XAML umfasst mehrere Sprachfunktionen, bei denen ein Objekt mit zusätzlichen Eingaben initialisiert werden kann und das Erzeugen des anfänglichen Objekts nicht ausschließlich vom Aufrufen eines Standardkonstruktors abhängig ist, bevor Eigenschaften festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="4bc44-324">XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a default constructor to produce the initial object, and only then setting properties.</span></span> <span data-ttu-id="4bc44-325">Zu diesen Funktionen zählen: <xref:System.Windows.Markup.XamlDeferLoadAttribute>, Initialisierungstext, [x:TypeArguments](x-typearguments-directive.md), Positionsparameter einer Markuperweiterung, Factorymethoden und zugehörige [x:Arguments](x-arguments-directive.md) -Knoten (XAML 2009).</span><span class="sxs-lookup"><span data-stu-id="4bc44-325">These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](x-typearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](x-arguments-directive.md) nodes (XAML 2009).</span></span> <span data-ttu-id="4bc44-326">In jedem dieser Fälle wird die tatsächliche Objekterstellung verzögert, und da der Knotenstream neu sortiert wird, kann der XAML-Objektwriter ein Verhalten verwenden, bei dem die Instanz tatsächlich jedes Mal erstellt wird, wenn ein Startmember gefunden wird, bei dem es sich nicht um eine Konstruktionsdirektive für diesen Objekttyp handelt.</span><span class="sxs-lookup"><span data-stu-id="4bc44-326">Each of these cases delay the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.</span></span>

### <a name="getobject"></a><span data-ttu-id="4bc44-327">GetObject</span><span class="sxs-lookup"><span data-stu-id="4bc44-327">GetObject</span></span>

<span data-ttu-id="4bc44-328">`GetObject` stellt einen XAML-Knoten dar, in dem ein XAML-Objektwriter den Wert der enthaltenden Eigenschaft des Objekts abrufen soll, anstatt ein neues Objekt zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="4bc44-328">`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property.</span></span> <span data-ttu-id="4bc44-329">Ein typischer Fall, in dem ein `GetObject` -Knoten in einem XAML-Knotenstream vorkommt, ist ein Auflistungs- oder Wörterbuchobjekt, bei dem die enthaltende Eigenschaft im Objektmodell des Unterstützungstyps bewusst schreibgeschützt ist.</span><span class="sxs-lookup"><span data-stu-id="4bc44-329">A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model.</span></span> <span data-ttu-id="4bc44-330">In diesem Szenario wird die Auflistung oder das Wörterbuch häufig durch die Initialisierungslogik eines übergeordneten Typs erstellt und initialisiert (normalerweise leer).</span><span class="sxs-lookup"><span data-stu-id="4bc44-330">In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.</span></span>

## <a name="see-also"></a><span data-ttu-id="4bc44-331">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="4bc44-331">See also</span></span>

- <xref:System.Xaml.XamlObjectReader>
- <span data-ttu-id="4bc44-332">[XAML Services](index.md) (XAML-Dienste)</span><span class="sxs-lookup"><span data-stu-id="4bc44-332">[XAML Services](index.md)</span></span>
- [<span data-ttu-id="4bc44-333">XAML-Namespaces</span><span class="sxs-lookup"><span data-stu-id="4bc44-333">XAML Namespaces</span></span>](xaml-namespaces-for-net-framework-xaml-services.md)
