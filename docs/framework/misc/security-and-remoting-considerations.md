---
title: Überlegungen zu Sicherheit und Remoting
ms.date: 03/30/2017
helpviewer_keywords:
- code security, remoting
- remoting, security
- security [.NET Framework], remoting
- secure coding, remoting
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
ms.openlocfilehash: 7a56c9894da88382f40dcd475e89776a83a59322
ms.sourcegitcommit: 9c54866bcbdc49dbb981dd55be9bbd0443837aa2
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 02/14/2020
ms.locfileid: "77215783"
---
# <a name="security-and-remoting-considerations"></a><span data-ttu-id="acf3a-102">Überlegungen zu Sicherheit und Remoting</span><span class="sxs-lookup"><span data-stu-id="acf3a-102">Security and Remoting Considerations</span></span>
<span data-ttu-id="acf3a-103">Remoting ermöglicht Ihnen das Einrichten transparenter Aufrufe zwischen Anwendungsdomänen, Prozessen oder Computern.</span><span class="sxs-lookup"><span data-stu-id="acf3a-103">Remoting allows you to set up transparent calling between application domains, processes, or computers.</span></span> <span data-ttu-id="acf3a-104">Der Sicherheitsstack für den Codezugriff kann jedoch Prozess- oder Computergrenzen nicht überschreiten (dies gilt zwischen Anwendungsdomänen des gleichen Prozesses).</span><span class="sxs-lookup"><span data-stu-id="acf3a-104">However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).</span></span>  
  
 <span data-ttu-id="acf3a-105">Jede remotefähige Klasse (abgeleitet von einer <xref:System.MarshalByRefObject>-Klasse) muss die Verantwortung für die Sicherheit übernehmen.</span><span class="sxs-lookup"><span data-stu-id="acf3a-105">Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security.</span></span> <span data-ttu-id="acf3a-106">Der Code sollte entweder nur in geschlossenen Umgebungen verwendet werden, in denen der aufrufende Code implizit vertrauenswürdig ist, oder Remoteaufrufe sollten so entworfen werden, dass kein geschützter Code für externe Eingaben in ggf. böswilliger Absicht verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="acf3a-106">Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.</span></span>  
  
 <span data-ttu-id="acf3a-107">Im Allgemeinen sollten Sie nie Methoden, Eigenschaften oder Ereignisse verfügbar machen, die durch deklarative [LinkDemand](link-demands.md) und <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> Sicherheitsüberprüfungen geschützt werden.</span><span class="sxs-lookup"><span data-stu-id="acf3a-107">Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks.</span></span> <span data-ttu-id="acf3a-108">Mit Remoting werden diese Überprüfungen nicht erzwungen.</span><span class="sxs-lookup"><span data-stu-id="acf3a-108">With remoting, these checks are not enforced.</span></span> <span data-ttu-id="acf3a-109">Andere Sicherheitsüberprüfungen (z. b. <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md)usw.) funktionieren zwischen Anwendungs Domänen innerhalb eines Prozesses, funktionieren jedoch nicht in prozessübergreifenden oder Computer übergreifenden Szenarien.</span><span class="sxs-lookup"><span data-stu-id="acf3a-109">Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.</span></span>  
  
## <a name="protected-objects"></a><span data-ttu-id="acf3a-110">Geschützte Objekte</span><span class="sxs-lookup"><span data-stu-id="acf3a-110">Protected objects</span></span>  
 <span data-ttu-id="acf3a-111">Einige Objekte enthalten Ihren Sicherheitszustand in sich.</span><span class="sxs-lookup"><span data-stu-id="acf3a-111">Some objects hold security state in themselves.</span></span> <span data-ttu-id="acf3a-112">Diese Objekte sollten nicht an nicht vertrauenswürdigen Code übergeben werden, der dann eine über seine eigenen Berechtigungen hinausgehende Sicherheitsautorisierung erhalten würde.</span><span class="sxs-lookup"><span data-stu-id="acf3a-112">These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.</span></span>  
  
 <span data-ttu-id="acf3a-113">Ein Beispiel ist das Erstellen eines <xref:System.IO.FileStream>-Objekts.</span><span class="sxs-lookup"><span data-stu-id="acf3a-113">One example is creating a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="acf3a-114">Die <xref:System.Security.Permissions.FileIOPermission> wird zum Zeitpunkt der Erstellung angefordert, und bei Erfolg wird das Dateiobjekt zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="acf3a-114">The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned.</span></span> <span data-ttu-id="acf3a-115">Wenn dieser Objektverweis jedoch an Code ohne Dateiberechtigungen übergeben wird, ist das Objekt in der Lage, diese Datei zu lesen und in sie zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="acf3a-115">However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.</span></span>  
  
 <span data-ttu-id="acf3a-116">Die einfachste Verteidigung für ein solches Objekt besteht darin, **die gleiche "** " "" "" "" "".</span><span class="sxs-lookup"><span data-stu-id="acf3a-116">The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element.</span></span>  
  
## <a name="application-domain-crossing-issues"></a><span data-ttu-id="acf3a-117">Probleme beim anwendungsdomänenübergreifenden Zugriff</span><span class="sxs-lookup"><span data-stu-id="acf3a-117">Application domain crossing issues</span></span>  
 <span data-ttu-id="acf3a-118">Zum Isolieren von Code in verwalteten Hostingumgebungen ist es üblich, mehrere untergeordnete Anwendungsdomänen mit einer expliziten Richtlinie zu generieren, um die Berechtigungsstufen verschiedener Assemblys zu verringern.</span><span class="sxs-lookup"><span data-stu-id="acf3a-118">To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies.</span></span> <span data-ttu-id="acf3a-119">In der Standardanwendungsdomäne bleibt die Richtlinie für diese Assemblys jedoch unverändert.</span><span class="sxs-lookup"><span data-stu-id="acf3a-119">However, the policy for those assemblies remains unchanged in the default application domain.</span></span> <span data-ttu-id="acf3a-120">Wenn eine der untergeordneten Anwendungsdomänen die Standardanwendungsdomäne zum Laden einer Assembly zwingen kann, gehen die Auswirkungen der Codeisolierung verloren, und Typen in der erzwungen geladenen Assembly können Code auf einer höheren Vertrauensebene ausführen.</span><span class="sxs-lookup"><span data-stu-id="acf3a-120">If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.</span></span>  
  
 <span data-ttu-id="acf3a-121">Eine Anwendungsdomäne kann eine andere Anwendungsdomäne zum Laden einer Assembly und Ausführen von darin enthaltenem Code durch Aufrufen eines Proxys für ein Objekt zwingen, das in der anderen Anwendungsdomäne gehostet wird.</span><span class="sxs-lookup"><span data-stu-id="acf3a-121">An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain.</span></span> <span data-ttu-id="acf3a-122">Zum Abrufen eines anwendungsübergreifenden Domänenproxys muss die Anwendungsdomäne, die das Objekt hostet, diesen über einen Methodenaufrufparameter oder Rückgabewert verteilen.</span><span class="sxs-lookup"><span data-stu-id="acf3a-122">To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value.</span></span> <span data-ttu-id="acf3a-123">Wenn die Anwendungsdomäne soeben erstellt wurde, verfügt der Ersteller für das <xref:System.AppDomain>-Objekt standardmäßig über einen Proxy.</span><span class="sxs-lookup"><span data-stu-id="acf3a-123">Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default.</span></span> <span data-ttu-id="acf3a-124">Damit vermieden wird, dass die Codeisolierung verletzt wird, sollte eine Anwendungsdomäne mit einer höheren Vertrauensebene daher keine Verweise auf durch Verweis gemarshallte Objekte (Instanzen von Klassen, die von <xref:System.MarshalByRefObject> abgeleitet sind) in der eigenen Domäne an Anwendungsdomänen mit niedrigeren Vertrauensebenen verteilen.</span><span class="sxs-lookup"><span data-stu-id="acf3a-124">Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust.</span></span>  
  
 <span data-ttu-id="acf3a-125">In der Regel erstellt die Standardanwendungsdomäne die untergeordneten Anwendungsdomänen mit jeweils einem Steuerelementobjekt.</span><span class="sxs-lookup"><span data-stu-id="acf3a-125">Usually, the default application domain creates the child application domains with a control object in each one.</span></span> <span data-ttu-id="acf3a-126">Das Steuerelementobjekt verwaltet die neue Anwendungsdomäne und nimmt gelegentlich Anweisungen von der Standardanwendungsdomäne entgegen, kann aber nicht direkt Kontakt mit der Domäne aufnehmen.</span><span class="sxs-lookup"><span data-stu-id="acf3a-126">The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly.</span></span> <span data-ttu-id="acf3a-127">Gelegentlich ruft die Standardanwendungsdomäne Ihren Proxy für das Steuerelementobjekt auf.</span><span class="sxs-lookup"><span data-stu-id="acf3a-127">Occasionally, the default application domain calls its proxy to the control object.</span></span> <span data-ttu-id="acf3a-128">Es können jedoch Fälle auftreten, in denen es erforderlich ist, dass das Steuerelementobjekt einen Rückruf an die Standardanwendungsdomäne ausgibt.</span><span class="sxs-lookup"><span data-stu-id="acf3a-128">However, there might be cases in which it is necessary for the control object to call back to the default application domain.</span></span> <span data-ttu-id="acf3a-129">In diesen Fällen übergibt die Standardanwendungsdomäne ein durch Verweis gemarshalltes Rückrufobjekt an den Konstruktor des Steuerelementobjekts.</span><span class="sxs-lookup"><span data-stu-id="acf3a-129">In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object.</span></span> <span data-ttu-id="acf3a-130">Es liegt in der Verantwortung des Steuerelementobjekts, diesen Proxy zu schützen.</span><span class="sxs-lookup"><span data-stu-id="acf3a-130">It is the responsibility of the control object to protect this proxy.</span></span> <span data-ttu-id="acf3a-131">Würde das Steuerelementobjekt den Proxy in einem öffentlichen statischen Feld einer öffentlichen Klasse positionieren oder den Proxy auf andere Weise öffentlich bereitstellen, würde dies einen gefährlichen Mechanismus für anderen Code eröffnen, einen Rückruf in die Standardanwendungsdomäne auszugeben.</span><span class="sxs-lookup"><span data-stu-id="acf3a-131">If the control object were to place the proxy on a public static field of a public class, or otherwise publicly expose the proxy, this would open up a dangerous mechanism for other code to call back into the default application domain.</span></span> <span data-ttu-id="acf3a-132">Aus diesem Grund sind Steuerelementobjekte immer implizit vertrauenswürdig, damit der Proxy privat bleibt.</span><span class="sxs-lookup"><span data-stu-id="acf3a-132">For this reason, control objects are always implicitly trusted to keep the proxy private.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="acf3a-133">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="acf3a-133">See also</span></span>

- [<span data-ttu-id="acf3a-134">Richtlinien für das Schreiben von sicherem Code</span><span class="sxs-lookup"><span data-stu-id="acf3a-134">Secure Coding Guidelines</span></span>](../../standard/security/secure-coding-guidelines.md)
