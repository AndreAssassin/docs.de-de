---
title: WIF-Sitzungsverwaltung
ms.date: 03/30/2017
ms.assetid: 98bce126-18a9-401b-b20d-67ee462a5f8a
author: BrucePerlerMS
ms.openlocfilehash: 980d0c6dca9b0b5fadf2d4a841e4c95a9acaff52
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/23/2019
ms.locfileid: "61780080"
---
# <a name="wif-session-management"></a>WIF-Sitzungsverwaltung
Wenn ein Client erstmals versucht auf eine geschützte Ressource zuzugreifen, die von einer vertrauenden Seite gehostet wird, muss sich der Client zunächst gegenüber einem Sicherheitstokendienst (STS) authentifizieren, der von der vertrauenden Seite als vertrauenswürdig eingestuft wird. Der STS stellt dem Client dann ein Sicherheitstoken aus. Der Client präsentiert dieses Token der vertrauenden Seite, die dem Client dann Zugriff auf die geschützte Ressource gewährt. Sie möchten jedoch nicht, dass der Client sich für jede Anfrage erneut gegenüber dem STS authentifizieren muss, vor allem, da er sich möglicherweise nicht auf demselben Computer oder in derselben Domäne wie die vertrauende Seite befindet. Stattdessen fordert die Windows Identity Foundation (WIF) den Client und die vertrauende Seite zur Erstellung einer Sitzung auf, in der der Client ein Sitzungssicherheitstoken verwendet, um sich gegenüber der vertrauenden Seite für alle Anforderungen nach der ersten Anforderung zu authentifizieren. Die vertrauende Seite kann dieses Sitzungssicherheitstoken, das in einem Cookie gespeichert wird, zur Rekonstruktion des <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType> des Clients verwenden.  
  
 Der STS definiert, welche Authentifizierung der Client bereitstellen muss. Der Client kann jedoch möglicherweise über mehrere Anmeldeinformationen verfügen, mit denen er sich gegenüber des STS authentifizieren kann. Beispielsweise können ein Token von Windows Live, ein Benutzername und Kennwort, ein Zertifikat und ein Smartkey auftreten. In diesem Fall gewährt der STS dem Client mehrere Identitäten. Jede Identität entspricht einer der Anmeldeinformationen, die vom Client präsentiert wurden. Die vertrauende Seite kann eine oder mehrere dieser Identitäten verwenden, wenn sie entscheidet, welche Zugriffsebene sie dem Client gewährt.  
  
 Die <xref:System.IdentityModel.Tokens.SessionSecurityToken?displayProperty=nameWithType> wird verwendet, um <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType> des Clients zu rekonstruieren, worin alle Clientidentitäten in <xref:System.Security.Claims.ClaimsPrincipal.Identities%2A> enthalten sind. Alle <xref:System.Security.Claims.ClaimsIdentity?displayProperty=nameWithType> der Auflistung enthalten die Bootstrap-Token, die dieser Identität zugeordnet sind.  
  
 Wenn ein neues Sitzungstoken mit der Sitzungs-ID des ursprünglichen Sitzungstokens ausgestellt wird, aktualisiert <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler?displayProperty=nameWithType> das Sitzungstoken im Tokencache nicht. Sie sollten immer ein Sitzungstoken mit einer eindeutigen Sitzungs-ID instanziieren.  
  
> [!NOTE]
>  Die Methode „Session.SecurityTokenHandler.ReadToken“ löst eine <xref:System.Xml.XmlException>-Ausnahme aus, wenn sie eine ungültige Eingabe erhält, z.B. wenn das Cookie, das das Sitzungstoken enthält, beschädigt ist. Es wird empfohlen, diese Ausnahme abzufangen und anwendungsspezifisches Verhalten bereitzustellen.  
  
 Wenn eine geschützte Webseite große Menge von Ressourcen (z.B. kleine Grafiken) enthält, die auch in der geschützten Domäne enthalten sind, muss sich der Client gegenüber der vertrauenden Seite erneut authentifizieren, um jede dieser Ressourcen herunterzuladen. Wenn Sie ein Sitzungsauthentifizierungstoken verwenden, müssen Sie sich nicht für jede Anforderung gegenüber dem STS authentifizieren, aber es werden dennoch viele Cookies gesendet werden. Sie sollten die Webseite möglicherweise so einrichten, dass wichtige Daten und Ressourcen in der geschützten Domäne gespeichert werden, während kleinere Elemente in einer ungeschützten Domäne gespeichert und mit der Web-Hauptseite verknüpft sind. Legen Sie den Cookiepfad so fest, dass er nur auf die geschützte Domäne verweist.  
  
 Für den Betrieb im Verweismodus empfiehlt Microsoft die Bereitstellung eines Handlers für das <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated>-Ereignis in der Datei **global.asax.cs** sowie das Festlegen der **IsReferenceMode**-Eigenschaft im Token, das an die <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A>-Eigenschaft übergeben wurde. Diese Updates stellen sicher, dass das Sitzungstoken für jede Anforderung im Verweismodus arbeitet und gegenüber dem Festlegen der <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A>-Eigenschaft für das Sitzungsauthentifizierungsmodul bevorzugt wird.  
  
## <a name="extensibility"></a>Erweiterungen  
 Sie können den Verwaltungsmechanismus der Sitzung erweitern. Ein Grund dafür wäre die Leistungsverbesserung. Beispielsweise könnten Sie einen benutzerdefinierten Cookiehandler erstellen, der das Sitzungssicherheitstoken zwischen dem cookie- und speicherinternen Zustand transformiert oder optimiert. Zu diesem Zweck können Sie die <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=nameWithType>-Eigenschaft von <xref:System.IdentityModel.Services.SessionAuthenticationModule?displayProperty=nameWithType> mit einem benutzerdefinierten Cookiehandler konfigurieren, der von <xref:System.IdentityModel.Services.CookieHandler?displayProperty=nameWithType> abgeleitet wird. <xref:System.IdentityModel.Services.ChunkedCookieHandler?displayProperty=nameWithType> ist der Standardhandler für das Cookie, weil die Cookies die zulässige Größe für das Hypertext Transfer Protocol (HTTP) überschreiten. Wenn Sie stattdessen einen benutzerdefinierten Cookiehandler verwenden, müssen Sie die Segmentierung implementieren.  
  
 Weitere Informationen finden Sie unter [ClaimsAwareWebFarm](https://go.microsoft.com/fwlink/?LinkID=248408) Beispiel. Dieses Beispiel veranschaulicht ein Sitzungscache, das in einer Farm verwendet werden kann (im Gegensatz zu einem Tokenreplycache), sodass Sie Sitzungen als Verweis verwenden können und keine großen Cookies austauschen müssen. Das Beispiel zeigt ebenfalls eine einfachere Sicherung von Cookies in einer Farm. Der Sitzungscache basiert auf WCF. Im Hinblick auf die Sitzungssicherung zeigt das Beispiel eine neue Funktion in WIF 4.5 einer Cookie-Transformation, die auf MachineKey basiert, die aktiviert werden kann, indem Sie einfach den entsprechenden Ausschnitt in der Datei „Web.config“ einfügen. Das Beispiel selbst ist nicht „ausgelagert“, aber es zeigt, was Sie tun müssen, um die Anwendung darauf vorzubereiten.
