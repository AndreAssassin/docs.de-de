### YamlMime:Tutorial
title: '<span data-ttu-id="014f9-101">Einführung in C# 7.0: interaktives C#-Tutorial</span><span class="sxs-lookup"><span data-stu-id="014f9-101">Explore C# 7.0 - C# interactive tutorial</span></span>'
metadata:
  title: 'Einführung in C# 7.0: Lernen Sie die neuen Funktionen von C# 7.0 in einem interaktiven Tutorial in Ihrem Browser kennen.'
  description: In diesem Tutorial verwenden Sie Ihren Browser, um C# 7.0 interaktiv kennenzulernen. Sie lernen die neuen Idiome von C# 7.0 kennen, mit denen Sie präziseren und besser lesbaren Code schreiben können.
  audience: Developer
  level: intermediate
  ms.date: 03/20/2019
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 1b1de22769c86f75684f41635287a73558d1d15a
  ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
  ms.translationtype: HT
  ms.contentlocale: de-DE
  ms.lasthandoff: 04/28/2019
  ms.locfileid: "64750381"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="014f9-105">In diesem interaktiven Tutorial lernen Sie die Funktionen von C# 7.0 kennen, indem Sie mit Ihrem Browser C#-Code schreiben und die Ergebnisse der Kompilierung und Ausführung Ihres Codes sehen.</span><span class="sxs-lookup"><span data-stu-id="014f9-105">This tutorial lets you explore C# 7.0 features interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="014f9-106">Einige Lektionen sind eine Abwandlung früherer C#-Methoden mit den neueren, präziseren Funktionen von C# 7.0.</span><span class="sxs-lookup"><span data-stu-id="014f9-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 7.0 features.</span></span> <span data-ttu-id="014f9-107">Im weiteren Verlauf dieses Artikels finden Sie eine Übersicht über die einzelnen Features, in der jeweils ein Link enthalten ist, über den Sie weitere Informationen zum Feature erhalten.</span><span class="sxs-lookup"><span data-stu-id="014f9-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="014f9-108">Deklarationen von out-Variablen am Speicherort der Zuweisung</span><span class="sxs-lookup"><span data-stu-id="014f9-108">Out variable declarations at the assignment location</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"014f9-109\">Die vorhandene Syntax zur Unterstützung von `out`-Parametern wurde in dieser Version verbessert.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-109\">The existing syntax that supports `out` parameters has been improved in this version.</span></span> <span data-ttu-id=\"014f9-110\">Klicken Sie auf die Schaltfläche *Enter Focus Mode (Fokusmodus aktivieren)* unten auf dieser Seite, und testen Sie dann den folgenden Code im interaktiven Fenster:</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-110\">Click the *Enter Focus Mode* button at the bottom of this page, then try the following code in the interactive window:</span></span> \n\n[!code-csharp[OutVariableOldStyle](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableOldStyle \"classic out variable declaration\")]\n\n<span data-ttu-id=\"014f9-111\">Nun können Sie `out`-Variablen in der Argumentliste eines Methodenaufrufs deklarieren, anstatt eine separate Deklarationsanweisung zu schreiben.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-111\">You can now declare `out` variables in the argument list of a method call, rather than writing a separate declaration statement.</span></span> <span data-ttu-id=\"014f9-112\">Sie können die Deklaration in den Methodenaufruf verschieben.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-112\">You can move the declaration into the method call.</span></span> <span data-ttu-id=\"014f9-113\">Fügen Sie im interaktiven Fenster unten den folgenden Code hinzu:</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-113\">Add the following code to the bottom of the interactive window:</span></span>\n\n[!code-csharp[OutVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableDeclarations \"Out variable declarations\")]\n\n<span data-ttu-id=\"014f9-114\">Sie können die `int`-Deklaration in eine `var`-Deklaration ändern.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-114\">You can change the `int` declaration to a `var` declaration.</span></span> <span data-ttu-id=\"014f9-115\">Fügen Sie dem interaktiven Fenster den folgenden Code hinzu:</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-115\">Add the following code to the interactive window:</span></span>\n\n[!code-csharp[OutVarVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVarVariableDeclarations \"Implicitly typed Out variable\")]\n\n<span data-ttu-id=\"014f9-116\">Die neue Syntax bietet zwei wichtige Vorteile gegenüber der bisherigen Syntax:</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-116\">The new syntax provides two important advantages over the existing syntax:</span></span>\n\n* <span data-ttu-id=\"014f9-117\">Der Code ist einfacher zu lesen.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-117\">The code is easier to read.</span></span> \n    - <span data-ttu-id=\"014f9-118\">Sie deklarieren die out-Variable, wenn Sie sie verwenden, nicht in einer anderen Zeile weiter oben.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-118\">You declare the out variable where you use it, not on another line above.</span></span>\n* <span data-ttu-id=\"014f9-119\">Sie müssen keinen Anfangswert zuweisen.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-119\">No need to assign an initial value.</span></span>\n    - <span data-ttu-id=\"014f9-120\">Durch das Deklarieren der `out`-Variable, wenn sie in einem Methodenaufruf verwendet wird, können Sie sie nicht versehentlich verwenden, bevor sie zugewiesen wurde.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-120\">By declaring the `out` variable where it is used in a method call, you can't accidentally use it before it is assigned.</span></span>\n\n<span data-ttu-id=\"014f9-121\">Der Bereich der deklarierten Variable entspricht dem Bereich, der die `if`-Anweisung einschließt.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-121\">The declared variable's scope is the scope enclosing the `if` statement.</span></span> <span data-ttu-id=\"014f9-122\">Dadurch können Sie die Variable anschließend verwenden.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-122\">This allows you to use the variable afterwards.</span></span> <span data-ttu-id=\"014f9-123\">Ändern Sie den letzten `if`-Block wie im folgenden Codeausschnitt gezeigt:</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-123\">Modify the last `if` block as shown in the following snippet.</span></span>\n\n```csharp\nif (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nConsole.WriteLine(result);\n```\n"
- title: <span data-ttu-id="014f9-124">Tupel erstellen einfache Datenstrukturen</span><span class="sxs-lookup"><span data-stu-id="014f9-124">Tuples create light-weight data structures</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"014f9-125\">Tupel sind einfache Datenstrukturen, die mehrere Felder zur Darstellung der Datenmember enthalten.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-125\">Tuples are lightweight data structures that contain multiple fields to represent the data members.</span></span> <span data-ttu-id=\"014f9-126\">Die Felder werden nicht überprüft, und Sie können keine eigenen Methoden definieren.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-126\">The fields are not validated, and you cannot define your own methods.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"014f9-127\">Tupel waren schon vor C# 7.0 verfügbar, sie waren jedoch ineffizient und hatten keine Sprachunterstützung.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-127\">Tuples were available before C# 7.0, but they were inefficient and had no language support.</span></span> <span data-ttu-id=\"014f9-128\">Das brachte mit sich, dass auf Tupelelemente nur als `Item1`, `Item2` usw. verwiesen werden konnte.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-128\">This meant that tuple elements could only be referenced as `Item1`, `Item2` and so on.</span></span> <span data-ttu-id=\"014f9-129\">Mit C# 7.0 wird Sprachunterstützung für Tupel eingeführt, wodurch semantische Namen für die Felder eines Tupels mithilfe neuer, effizienterer Tupeltypen möglich werden.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-129\">C# 7.0 introduces language support for tuples, which enables semantic names for the fields of a tuple using new more efficient tuple types.</span></span>\n\n<span data-ttu-id=\"014f9-130\">Sie können ein Tupel erstellen, indem Sie jedem benannten Member einen Wert zuweisen:</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-130\">You can create a tuple by assigning a value to each named member:</span></span>\n\n[!code-csharp[NamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#NamedTuple \"Named tuple\")]\n\n<span data-ttu-id=\"014f9-131\">Das `namedLetters`-Tupel enthält Felder, die als `Alpha` und `Beta` bezeichnet werden.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-131\">The `namedLetters` tuple contains fields referred to as `Alpha` and `Beta`.</span></span> <span data-ttu-id=\"014f9-132\">Diese Namen bestehen nur zur Kompilierzeit und werden zur Laufzeit nicht beibehalten (wenn das Tupel beispielsweise mithilfe von Reflektion untersucht wird).</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-132\">Those names exist only at compile time and are not preserved at runtime (when inspecting the tuple using reflection, for example).</span></span>\n\n<span data-ttu-id=\"014f9-133\">In einer Tupelzuweisung können Sie auch die Namen der Felder auf der rechten Seite der Zuweisung angeben:</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-133\">In a tuple assignment, you can also specify the names of the fields on the right-hand side of the assignment:</span></span> \n\n[!code-csharp[ImplicitNamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#ImplicitNamedTuple \"Implicitly named tuple\")]\n\n<span data-ttu-id=\"014f9-134\">Sie können Namen für die Felder auf der linken und rechten Seite der Zuweisung angeben, jedoch werden die Namen auf der rechten Seite ignoriert.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-134\">You can specify names for the fields on both the left and right-hand side of the assignment, but the names on the right side are ignored.</span></span>\n\n<span data-ttu-id=\"014f9-135\">Tupel sind am nützlichsten als Rückgabetypen für `private`- und `internal`-Methoden.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-135\">Tuples are most useful as return types for `private` and `internal` methods.</span></span> <span data-ttu-id=\"014f9-136\">Mit Tupeln können diese Methoden in einfacher Syntax mehrere diskrete Werte zurückgeben.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-136\">Tuples provide a simple syntax for those methods to return multiple discrete values.</span></span>\n\n<span data-ttu-id=\"014f9-137\">Ein Tupel zu erstellen, ist effizienter und produktiver als das Erstellen einer Klasse oder Struktur.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-137\">Creating a tuple is more efficient and more productive that creating a class or struct.</span></span> <span data-ttu-id=\"014f9-138\">Es besitzt eine einfachere Syntax, um eine Datenstruktur mit mehr als einem Wert zu definieren.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-138\">It has a simpler, lightweight syntax to define a data structure that carries more than one value.</span></span> <span data-ttu-id=\"014f9-139\">Die folgende Beispielmethode gibt die minimalen und maximalen Werte in einer Sequenz von ganzen Zahlen zurück.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-139\">The example method below returns the minimum and maximum values found in a sequence of integers.</span></span> <span data-ttu-id=\"014f9-140\">Fügen Sie zum Testen den folgenden Code im Browser hinzu:</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-140\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[TupleReturningMethod](~/samples/snippets/csharp/new-in-7/program.cs#TupleReturningMethod \"Tuple returning method\")]\n\n<span data-ttu-id=\"014f9-141\">Manchmal möchten Sie vielleicht die Member eines Tupels entpacken, die von einer Methode zurückgegeben wurden.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-141\">There may be times when you want to unpackage the members of a tuple that were returned from a method.</span></span>  <span data-ttu-id=\"014f9-142\">Sie können dazu für jeden Wert im Tupel separate Variablen deklarieren.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-142\">You can do that by declaring separate variables for each of the values in the tuple.</span></span> <span data-ttu-id=\"014f9-143\">Dies wird als *Dekonstruieren* des Tupels bezeichnet.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-143\">This is called *deconstructing* the tuple.</span></span> <span data-ttu-id=\"014f9-144\">Fügen Sie zum Testen den folgenden Code im Browser hinzu:</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-144\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[CallingWithDeconstructor](~/samples/snippets/csharp/new-in-7/program.cs#CallingWithDeconstructor \"Deconstructing a tuple\")]\n\n<span data-ttu-id=\"014f9-145\">Bei der Arbeit mit Tupeln werden Sie feststellen, dass nicht alle Member eines Tupelergebnisses verwendet werden.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-145\">As you work with tuples, you'll often find that you don't use all of the members of a tuple result.</span></span> <span data-ttu-id=\"014f9-146\">In diesem Fall können Sie einen oder mehrere der zurückgegebenen Werte verwerfen, indem Sie anstelle einer Variablen `_` verwenden.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-146\">When that happens, you can discard one or more of the returned values by using `_` in place of a variable.</span></span> <span data-ttu-id=\"014f9-147\">Fügen Sie zum Testen den folgenden Code im Browser hinzu:</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-147\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[DiscardTupleMember](~/samples/snippets/csharp/new-in-7/program.cs#DiscardMember \"Discard a tuple member\")]\n\n<span data-ttu-id=\"014f9-148\">Ausführliche Informationen zu Tupeln finden Sie im Artikel zu [Tupeln](../../tuples.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-148\">You can learn more in depth about tuples in the [tuples article](../../tuples.md).</span></span>\n<span data-ttu-id=\"014f9-149\">Weitere Informationen zum Verwerfen von Elementen finden Sie im Artikel zum Thema [Verwerfen](../../discards.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-149\">You can learn more about discards in the [discards article](../../discards.md).</span></span>\n"
- title: <span data-ttu-id="014f9-150">Verwenden des Typmusters mit dem Is-Ausdruck</span><span class="sxs-lookup"><span data-stu-id="014f9-150">Use the type pattern with the is expression</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="014f9-151">Der Musterausdruck `is` erweitert den vertrauten [`is`-Operator](../../language-reference/keywords/is.md#pattern-matching-with-is), um ein Objekt über dessen Typ hinaus abzufragen.</span><span class="sxs-lookup"><span data-stu-id="014f9-151">The `is` pattern expression extends the familiar [`is` operator](../../language-reference/keywords/is.md#pattern-matching-with-is) to query an object beyond its type.</span></span>


    <span data-ttu-id="014f9-152">Testen Sie den folgenden Code in Ihrem Browser:</span><span class="sxs-lookup"><span data-stu-id="014f9-152">Try the following code in your browser window:</span></span>


    [!code-csharp[SimpleIs](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleIsPattern "Simple Is pattern")]


    <span data-ttu-id="014f9-153">Ändern Sie die Variablendeklaration in eine Zeichenfolge:</span><span class="sxs-lookup"><span data-stu-id="014f9-153">Change the variable declaration to a string instead:</span></span>


    ```csharp

    object count = "5";

    ```


    <span data-ttu-id="014f9-154">Jetzt ist der `is`-Ausdruck FALSE, weshalb die `else`-Verzweigung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="014f9-154">Now, the `is` expression is false, so the `else` branch is executed.</span></span> <span data-ttu-id="014f9-155">Versuchen Sie, `count` in der Else-Verzweigung in `number` zu ändern:</span><span class="sxs-lookup"><span data-stu-id="014f9-155">Try to change `count` to `number` in the else branch:</span></span>


    ```csharp

    Console.WriteLine($"{number} is not an integer");

    ```


    <span data-ttu-id="014f9-156">Der oben genannte Code wird nicht kompiliert, da `number` in der `else`-Verzweigung nicht zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="014f9-156">The above won't compile because `number` isn't assigned in the `else` branch.</span></span> <span data-ttu-id="014f9-157">Es ist nur in der `true`-Verzweigung der `if`-Anweisung zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="014f9-157">It's only assigned in the `true` branch of the `if` statement.</span></span>


    <span data-ttu-id="014f9-158">Das Typmuster des `is`-Ausdrucks ist nützlich, wenn eine kleine Anzahl von Typen getestet werden soll.</span><span class="sxs-lookup"><span data-stu-id="014f9-158">The `is` expression type pattern is useful when you have a small number of types to test against.</span></span> <span data-ttu-id="014f9-159">Häufig müssen jedoch mehrere Typen getestet werden.</span><span class="sxs-lookup"><span data-stu-id="014f9-159">Often, you may need to test multiple types.</span></span> <span data-ttu-id="014f9-160">Dafür wird die `switch`-Anweisung für den Musterabgleich benötigt.</span><span class="sxs-lookup"><span data-stu-id="014f9-160">That requires the pattern matching `switch` statement.</span></span>
- title: <span data-ttu-id="014f9-161">Musterabgleich in der Switch-Anweisung</span><span class="sxs-lookup"><span data-stu-id="014f9-161">Pattern matching in the switch statement</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="014f9-162">Der *Vergleichsausdruck* verfügt über eine vertraute Syntax, die auf der `switch`-Anweisung basiert, die bereits Teil der C#-Sprache ist.</span><span class="sxs-lookup"><span data-stu-id="014f9-162">The *match expression* has a familiar syntax, based on the `switch` statement already part of the C# language.</span></span> <span data-ttu-id="014f9-163">Das folgende Beispiel basiert auf einer `is`-Ausdruckssyntax, die Sie auf der vorherigen Seite kennengelernt haben:</span><span class="sxs-lookup"><span data-stu-id="014f9-163">Let's start with a small sample based on the `is` expression syntax you explored on the previous page:</span></span>


    [!code-csharp[SimpleSwitch](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleSwitchPattern "simple switch")]


    <span data-ttu-id="014f9-164">Der vorhergehende Code sucht nach `int` oder `null`.</span><span class="sxs-lookup"><span data-stu-id="014f9-164">The preceding code checks for an `int` or `null`.</span></span> <span data-ttu-id="014f9-165">Jeder andere Typ hat die Standardanfrage erreicht.</span><span class="sxs-lookup"><span data-stu-id="014f9-165">Every other type reached the default case.</span></span> <span data-ttu-id="014f9-166">Fügen Sie die folgenden beiden Zeilen hinzu, um das Verhalten zu überprüfen:</span><span class="sxs-lookup"><span data-stu-id="014f9-166">Add the following two lines to verify the behavior:</span></span>


    [!code-csharp[AddLongCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestLong "Add a case for long")]


    <span data-ttu-id="014f9-167">Der `switch`-Ausdruck konvertiert einen Nullable-Typ in den entsprechenden Typ.</span><span class="sxs-lookup"><span data-stu-id="014f9-167">The `switch` expression will convert a nullable type to its corresponding type.</span></span> <span data-ttu-id="014f9-168">Fügen Sie zur Überprüfung die folgenden Zeilen hinzu:</span><span class="sxs-lookup"><span data-stu-id="014f9-168">Add the following to verify:</span></span>


    [!code-csharp[NullableCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#NullableSwitch "Add a nullable case")]


    <span data-ttu-id="014f9-169">Switch-Anweisungen können beliebig viele andere Typmusterausdrücke hinzufügt werden.</span><span class="sxs-lookup"><span data-stu-id="014f9-169">You can add any number of other type pattern expressions to the switch statements.</span></span> <span data-ttu-id="014f9-170">Fügen Sie diese vor der `null`-Anfrage hinzu:</span><span class="sxs-lookup"><span data-stu-id="014f9-170">Add these before the `null` case:</span></span>


    [!code-csharp[MoreTypeCases](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreCases "Add more type cases")]


    <span data-ttu-id="014f9-171">Stellen Sie sicher, dass die Ausdrücke funktionieren, indem Sie die folgenden Tests hinzufügen:</span><span class="sxs-lookup"><span data-stu-id="014f9-171">Make sure these work by adding the following tests:</span></span>


    [!code-csharp[AddMoreTests](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreTests "Add more type tests")]


    <span data-ttu-id="014f9-172">Die Vergleichsausdrücke unterstützen auch Konstanten.</span><span class="sxs-lookup"><span data-stu-id="014f9-172">The match expressions also support constants.</span></span> <span data-ttu-id="014f9-173">Dies kann durch das Ausklammern von einfachen Fällen Zeit sparen:</span><span class="sxs-lookup"><span data-stu-id="014f9-173">This can save time by factoring out simple cases:</span></span>


    [!code-csharp[ConstantCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#ConstantCase "Add a constant case")]


    <span data-ttu-id="014f9-174">Die vorherige Anfrage muss *vor* dem `case int:`-Ausdruck hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="014f9-174">You must add the preceding case *before* the `case int:` expression.</span></span> <span data-ttu-id="014f9-175">Wird sie nach der Anfrage hinzugefügt, erhalten Sie eine Compilermeldung mit der Warnung, dass der Ausdruck bereits von einer vorherigen Anfrage behandelt wurde.</span><span class="sxs-lookup"><span data-stu-id="014f9-175">If you add it after that case, the compiler warns you that it has already been handled by a previous case.</span></span>


    <span data-ttu-id="014f9-176">Sie können einer beliebigen Musterabfrage eine `when`-Klausel hinzufügen, damit Sie auch andere Bedingungen als einen Typ oder konstanten Wert testen können.</span><span class="sxs-lookup"><span data-stu-id="014f9-176">You can add a `when` clause to any pattern case so that you can test other conditions beyond a type or a constant value.</span></span> <span data-ttu-id="014f9-177">Fügen Sie die folgende Anfrage zum Testen oberhalb der allgemeinen `string`-Anfrage hinzu:</span><span class="sxs-lookup"><span data-stu-id="014f9-177">Try it by adding the following case above the general `string` case:</span></span>


    [!code-csharp[WhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#WhenClause "Add a when clause")]


    <span data-ttu-id="014f9-178">Der Test könnte etwa folgendermaßen aussehen:</span><span class="sxs-lookup"><span data-stu-id="014f9-178">Test it with something like the following code:</span></span>


    [!code-csharp[TestWhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestWhenClause "Test the when clause")]


    <span data-ttu-id="014f9-179">Die neue Syntax für Mustervergleichsausdrücke erleichtert das Erstellen von Verteilungsalgorithmen mit einer klaren und präzisen Syntax auf der Basis des Typs oder anderer Eigenschaften eines Objekts.</span><span class="sxs-lookup"><span data-stu-id="014f9-179">The new syntax for pattern matching expressions makes it easier to create dispatch algorithms using a clear and concise syntax based on an object's type or other properties.</span></span> <span data-ttu-id="014f9-180">Mustervergleichsausdrücke ermöglichen diese Konstrukte auf Datentypen, die durch Vererbung nicht verbunden sind.</span><span class="sxs-lookup"><span data-stu-id="014f9-180">Pattern matching expressions enable these constructs on data types that are unrelated by inheritance.</span></span>


    <span data-ttu-id="014f9-181">Weitere Informationen zum Mustervergleich finden Sie im Artikel zum [Mustervergleich in C#](../../pattern-matching.md).</span><span class="sxs-lookup"><span data-stu-id="014f9-181">You can learn more about pattern matching in the article dedicated to [pattern matching in C#](../../pattern-matching.md).</span></span>
- title: <span data-ttu-id="014f9-182">Optimieren des Arbeitsspeichers mithilfe von lokalen ref-Variablen und Rückgabetypen</span><span class="sxs-lookup"><span data-stu-id="014f9-182">Optimize memory storage using ref locals and returns</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="014f9-183">Diese Funktion ermöglicht Algorithmen, die Verweise auf Variablen verwenden und zurückgeben, die an anderer Stelle definiert sind.</span><span class="sxs-lookup"><span data-stu-id="014f9-183">This feature enables algorithms that use and return references to variables defined elsewhere.</span></span> <span data-ttu-id="014f9-184">Ein Beispiel ist das Arbeiten mit großen Matrizen und die Suche nach einem einzigen Ort mit bestimmten Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="014f9-184">One example is with large matrices and finding a single location with certain characteristics.</span></span> <span data-ttu-id="014f9-185">Eine Methode gibt die zwei Indizes für einen einzigen Speicherort in der Matrix zurück:</span><span class="sxs-lookup"><span data-stu-id="014f9-185">One method would return the two indices a single location in the matrix:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#EverythingByValue "return indices by value")]


    <span data-ttu-id="014f9-186">Sie können diese Methode mit dem folgenden Code testen:</span><span class="sxs-lookup"><span data-stu-id="014f9-186">You can test this method using the following code:</span></span>


    [!code-csharp[TestByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return indices by value")]



    <span data-ttu-id="014f9-187">Diese `Find`-Methode gibt die Indizes an das Element in der Matrix zurück.</span><span class="sxs-lookup"><span data-stu-id="014f9-187">This `Find` method returns the indices to the item in the matrix.</span></span> <span data-ttu-id="014f9-188">Daraus ergibt sich, dass Aufrufer Code schreiben, der mit diesen Indizes die Matrix dereferenziert und ein einzelnes Element ändert.</span><span class="sxs-lookup"><span data-stu-id="014f9-188">That leads callers to write code that uses those indices to dereference the matrix and modify a single element.</span></span> <span data-ttu-id="014f9-189">Sie würden eher eine Methode schreiben, die einen *Verweis* auf das Element der Matrix zurückgibt, die Sie ändern möchten.</span><span class="sxs-lookup"><span data-stu-id="014f9-189">You'd rather write a method that returns a *reference* to the element of the matrix that you want to change.</span></span>


    <span data-ttu-id="014f9-190">Betrachten wir nun eine Reihe von Änderungen, um die lokale ref-Funktion zu präsentieren und zu zeigen, wie Sie eine Methode erstellen, die einen Verweis auf den internen Speicher zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="014f9-190">Let's walk through a series of changes to demonstrate the ref local feature and show how to create a method that returns a reference to internal storage.</span></span> <span data-ttu-id="014f9-191">Nebenbei lernen Sie die Regeln der ref-Rückgabe und der lokalen ref-Funktion kennen, damit Sie diese nicht versehentlich falsch verwenden.</span><span class="sxs-lookup"><span data-stu-id="014f9-191">Along the way, you'll learn the rules of the ref return and ref local feature that protect you from accidentally misusing it.</span></span>


    <span data-ttu-id="014f9-192">Ändern Sie zuerst die `Find`-Methodendeklaration, sodass sie eine `ref int` anstelle eines Tupels zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="014f9-192">Start by modifying the `Find` method declaration so that it returns a `ref int` instead of a tuple.</span></span>


    ```csharp

    ref int Find(int[,] matrix, Func<int, bool> predicate)

    ```


    <span data-ttu-id="014f9-193">Ändern Sie die return-Anweisung, damit das Element an die richtigen Indizes zurückgegeben wird:</span><span class="sxs-lookup"><span data-stu-id="014f9-193">Modify the return statement to return the item at the correct indices:</span></span>


    ```csharp

    return matrix[i,j];

    ```


    <span data-ttu-id="014f9-194">Ändern Sie die letzte Rückgabe, sodass stattdessen eine Ausnahme ausgelöst wird:</span><span class="sxs-lookup"><span data-stu-id="014f9-194">Change the final return to throw an exception instead:</span></span>


    ```csharp

    throw new InvalidOperationException("Not found");

    ```


    <span data-ttu-id="014f9-195">Beachten Sie, dass der Code so nicht kompiliert wird.</span><span class="sxs-lookup"><span data-stu-id="014f9-195">Note that this won't compile.</span></span> <span data-ttu-id="014f9-196">Die Methodendeklaration gibt eine `ref`-Rückgabe an, die return-Anweisung jedoch die Rückgabe eines Werts.</span><span class="sxs-lookup"><span data-stu-id="014f9-196">The method declaration indicates a `ref` return, but the return statement specifies a value return.</span></span> <span data-ttu-id="014f9-197">Sie müssen jeder return-Anweisung das `ref`-Schlüsselwort hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="014f9-197">You must add the `ref` keyword to each return statement.</span></span> <span data-ttu-id="014f9-198">So wird die Rückgabe durch Verweis angegeben, sodass Entwickler später beim Lesen des Codes wissen, dass die Methode durch Verweis zurückgibt:</span><span class="sxs-lookup"><span data-stu-id="014f9-198">That indicates return by reference, and helps developers reading the code later remember that the method returns by reference:</span></span>


    ```csharp

    return ref matrix[i,j];

    ```


    <span data-ttu-id="014f9-199">Nun gibt die Methode einen Verweis auf den ganzzahligen Wert in der Matrix zurück, und Sie müssen ändern, wo sie aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="014f9-199">Now that the method returns a reference to the integer value in the matrix, you need to modify where it's called.</span></span> <span data-ttu-id="014f9-200">Die `var`-Deklaration bedeutet, dass `valItem` jetzt eine `int` anstatt eines Tupels ist.</span><span class="sxs-lookup"><span data-stu-id="014f9-200">The `var` declaration means that `valItem` is now an `int` rather than a tuple.</span></span> <span data-ttu-id="014f9-201">Ändern Sie den aufrufenden Code in den folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="014f9-201">Change the calling code to the following:</span></span>


    ```csharp

    var valItem = Find(matrix, (val) => val == 42);

    Console.WriteLine(valItem);

    valItem = 24;

    Console.WriteLine(matrix[4, 2]);

    ```


    <span data-ttu-id="014f9-202">Die zweite `WriteLine`-Anweisung im obigen Beispiel gibt den Wert `42` aus und nicht `24`.</span><span class="sxs-lookup"><span data-stu-id="014f9-202">The second `WriteLine` statement in the example above prints out the value `42`, not `24`.</span></span> <span data-ttu-id="014f9-203">Die Variable `valItem` ist eine `int` und nicht eine `ref int`.</span><span class="sxs-lookup"><span data-stu-id="014f9-203">The variable `valItem` is an `int`, not a `ref int`.</span></span> <span data-ttu-id="014f9-204">Durch das `var`-Schlüsselwort kann der Compiler den Typ angeben, fügt jedoch nicht implizit den `ref`-Modifizierer hinzu.</span><span class="sxs-lookup"><span data-stu-id="014f9-204">The `var` keyword enables the compiler to specify the type but will not implicitly add the `ref` modifier.</span></span> <span data-ttu-id="014f9-205">Stattdessen wird der Wert, auf den `ref return` verweist, an die Variable auf der linken Seite der Zuweisung *kopiert*.</span><span class="sxs-lookup"><span data-stu-id="014f9-205">Instead, the value referred to by the `ref return` is *copied* to the variable on the left-hand side of the assignment.</span></span> <span data-ttu-id="014f9-206">Die Variable ist keine lokale `ref`.</span><span class="sxs-lookup"><span data-stu-id="014f9-206">The variable is not a `ref` local.</span></span>


    <span data-ttu-id="014f9-207">Damit der zurückgegebene Verweis geändert werden kann, müssen Sie den `ref`-Modifizierer der Deklaration der lokalen Variablen vor dem Aufruf von `Find` hinzufügen, um aus der Variable einen Verweis herzustellen, wenn der Rückgabewert ein Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="014f9-207">In order to modify the returned reference, you need to add the `ref` modifier to the local variable declaration and before the call to `Find` to make the variable a reference when the return value is a reference.</span></span> <span data-ttu-id="014f9-208">Ändern Sie den Testcode in Ihrem Browser in den folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="014f9-208">Modify the test code in your browser to match the following:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return object by reference")]


    <span data-ttu-id="014f9-209">Nun gibt die zweite `WriteLine`-Anweisung im obigen Beispiel den Wert `24` aus, der angibt, dass der Speicher in der Matrix geändert wurde.</span><span class="sxs-lookup"><span data-stu-id="014f9-209">Now, the second `WriteLine` statement in the example above prints out the value `24`, indicating that the storage in the matrix has been modified.</span></span> <span data-ttu-id="014f9-210">Die lokale Variable wurde mit dem `ref`-Modifizierer deklariert und nimmt eine `ref`-Rückgabe an.</span><span class="sxs-lookup"><span data-stu-id="014f9-210">The local variable has been declared with the `ref` modifier, and it will take a `ref` return.</span></span> <span data-ttu-id="014f9-211">Sie müssen eine `ref`-Variable initialisieren, wenn sie deklariert wird. Deklaration und Initialisierung können nicht voneinander getrennt werden.</span><span class="sxs-lookup"><span data-stu-id="014f9-211">You must initialize a `ref` variable when it is declared; you cannot split the declaration and the initialization.</span></span>


    <span data-ttu-id="014f9-212">Die C#-Sprache verfügt über drei weitere Regeln, die Sie vor der falschen Verwendung der lokalen `ref`-Variablen und Rückgaben schützen:</span><span class="sxs-lookup"><span data-stu-id="014f9-212">The C# language has three other rules that protect you from misusing the `ref` locals and returns:</span></span>


    * <span data-ttu-id="014f9-213">Sie können einer lokalen `ref`-Variablen keinen Standard-Methodenrückgabewert zuweisen.</span><span class="sxs-lookup"><span data-stu-id="014f9-213">You cannot assign a standard method return value to a `ref` local variable.</span></span>

    * <span data-ttu-id="014f9-214">Sie können eine `ref` nicht an eine Variable zurückgeben, deren Lebensdauer sich nicht über die Ausführung der Methode hinaus erstreckt.</span><span class="sxs-lookup"><span data-stu-id="014f9-214">You cannot return a `ref` to a variable whose lifetime does not extend beyond the execution of the method.</span></span>

    * <span data-ttu-id="014f9-215">Lokale `ref`-Variablen und Rückgabewerte können nicht in Verbindung mit asynchronen Methoden verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="014f9-215">`ref` locals and returns can't be used with async methods.</span></span>


    <span data-ttu-id="014f9-216">Das Hinzufügen von lokalen ref-Variablen und ref-Rückgaben ermöglicht effizientere Algorithmen, da Werte nicht kopiert oder dereferenzierende Vorgänge nicht mehrmals ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="014f9-216">The addition of ref locals and ref returns enable algorithms that are more efficient by avoiding copying values or performing dereferencing operations multiple times.</span></span>


    <span data-ttu-id="014f9-217">Weitere Informationen finden Sie im Artikel [Schlüsselwort „ref“](../../language-reference/keywords/ref.md).</span><span class="sxs-lookup"><span data-stu-id="014f9-217">For more information, see the [ref keyword](../../language-reference/keywords/ref.md) article.</span></span>
- title: <span data-ttu-id="014f9-218">Minimieren des Zugriffs auf Code mit lokalen Funktionen</span><span class="sxs-lookup"><span data-stu-id="014f9-218">Minimize access to code with local functions</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"014f9-219\">Sie können nun lokale Funktionen deklarieren, die in anderen Funktionen geschachtelt sind.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-219\">You can now declare local functions that are nested inside other functions.</span></span> <span data-ttu-id=\"014f9-220\">Dadurch können Sie die Sichtbarkeit dieser Funktionen minimieren.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-220\">This enables you to minimize the visibility of these functions.</span></span> <span data-ttu-id=\"014f9-221\">Lokale Funktionen besitzen drei offensichtliche Anwendungsfälle:</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-221\">There are three obvious use cases for local functions:</span></span>\n\n- <span data-ttu-id=\"014f9-222\">Rekursive Funktionen.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-222\">Recursive functions.</span></span>\n- <span data-ttu-id=\"014f9-223\">Iteratormethoden</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-223\">Iterator methods.</span></span>\n- <span data-ttu-id=\"014f9-224\">Asynchrone Methoden</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-224\">Asynchronous methods.</span></span>\n\n<span data-ttu-id=\"014f9-225\">Beginnen wir mit rekursiven Methoden.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-225\">Let's start with recursive methods.</span></span> <span data-ttu-id=\"014f9-226\">Geben Sie den folgenden Code zum Testen in den Browser ein, um (die Fakultät von) `6!` zu berechnen:</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-226\">Try the following code in the browser to calculate `6!` (factorial):</span></span>\n\n```csharp\nint LocalFunctionFactorial(int n)\n{\n    return nthFactorial(n);\n\n    int nthFactorial(int number) => (number < 2) ? \n        1 : number * nthFactorial(number - 1);\n}\n\nConsole.WriteLine(LocalFunctionFactorial(6));\n```\n\n<span data-ttu-id=\"014f9-227\">Lokale Funktionen eignen sich hervorragend zur Implementierung rekursiver Algorithmen.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-227\">Local functions are a great way to implement recursive algorithms.</span></span> <span data-ttu-id=\"014f9-228\">Weitere Verwendungsmöglichkeiten sind öffentliche Iterator- und öffentliche asynchrone Methoden.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-228\">Other common uses are for public iterator methods and public async methods.</span></span> <span data-ttu-id=\"014f9-229\">Mit beiden Arten von Methoden wird Code generiert, der Fehler später meldet, als Programmierer es erwarten würden.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-229\">Both types of methods generate     code that reports errors later than programmers might expect.</span></span> <span data-ttu-id=\"014f9-230\">Bei Iteratormethoden werden Ausnahmen nur festgestellt, wenn Code aufgerufen wird, der die zurückgegebene Sequenz auflistet.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-230\">In the case of iterator methods, any exceptions are observed only when calling code that enumerates the returned sequence.</span></span> <span data-ttu-id=\"014f9-231\">Bei asynchronen Methoden werden Ausnahmen nur festgestellt, wenn der zurückgegebene `Task` erwartet wird.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-231\">In the case of async methods, any exceptions are only observed when the returned `Task` is awaited.</span></span>\n\n<span data-ttu-id=\"014f9-232\">Da sich Iteratormethoden einfacher im Browser untersuchen lassen, werden sie für diese Untersuchung verwendet.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-232\">Iterator methods are easier to explore in the browser, so let's use those in this exploration.</span></span> <span data-ttu-id=\"014f9-233\">Rufen Sie mit dem folgenden Code eine Iteratormethode in Ihrem Browser auf:</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-233\">Try the following code that calls an iterator method in your browser:</span></span>\n\n[!code-csharp[IteratorMethod](~/samples/snippets/csharp/new-in-7/Iterator.cs#SnippetIteratorMethod \"Iterator method\")]\n\n<span data-ttu-id=\"014f9-234\">Führen Sie den Code aus.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-234\">Run the code.</span></span> <span data-ttu-id=\"014f9-235\">Beachten Sie, dass die Ausnahme ausgelöst wird, wenn der Code mit dem Durchlaufen des zweiten Resultsets beginnt.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-235\">Notice that the exception is thrown when the code begins iterating the second result set.</span></span> <span data-ttu-id=\"014f9-236\">Der Code, der das erste Resultset durchläuft, wurde bereits ausgeführt.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-236\">The code that iterates the first result set has already run.</span></span> <span data-ttu-id=\"014f9-237\">Da dieses Beispiel klein ist und keine Datenstrukturen verändert, ist es harmlos und leicht zu beheben.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-237\">This sample is both small and doesn't change any data structures, so it's harmless and easy to fix.</span></span> <span data-ttu-id=\"014f9-238\">In einem größeren Programm, bei dem die beiden Iteratorobjekte in unterschiedlichen untergeordneten Methoden erstellt werden können, ist die Ursache möglicherweise schwer zu finden.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-238\">But, in a larger program, where the two iterator objects may be created in different child methods the root cause could be hard to find.</span></span> <span data-ttu-id=\"014f9-239\">Wenn die erste Iteratormethode den Datenstatus geändert hat, kann es sogar zu einer Datenbeschädigung kommen.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-239\">If the first iterator method changed data state, it could even cause data corruption.</span></span> <span data-ttu-id=\"014f9-240\">Daher wäre es wünschenswert, dass die Ausnahme sofort ausgelöst wird, bevor mit der Arbeit begonnen wird.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-240\">You'd prefer the exception was thrown immediately, before any work is done.</span></span> <span data-ttu-id=\"014f9-241\">Sie können den Code so umgestalten, dass die öffentliche Methode alle Argumente überprüft und eine lokale Funktion die Enumeration ausführt:</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-241\">You can refactor the code so that the public method validates all arguments, and a local function performs the enumeration:</span></span>\n\n[!code-csharp[IteratorMethodRefactored](~/samples/snippets/csharp/new-in-7/Iterator.cs#IteratorMethodLocalInteractive \"Iterator method refactored\")]\n\n<span data-ttu-id=\"014f9-242\">Die vorhergehende Version macht deutlich, dass auf die lokale Methode nur im Kontext der äußeren Methode verwiesen wird.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-242\">The preceding version makes it clear that the local method is referenced only in the context of the outer method.</span></span> <span data-ttu-id=\"014f9-243\">Die Regeln für lokale Funktionen stellen auch sicher, dass ein Entwickler nicht versehentlich die lokale Funktion von einem anderen Speicherort in der Klasse aufrufen und die Argumentüberprüfung umgehen kann.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-243\">The rules for local functions also ensure that a developer can't accidentally call the local function from another location in the class and bypass the argument validation.</span></span>\n\n<span data-ttu-id=\"014f9-244\">Das gleiche Verfahren kann bei `async`-Methoden eingesetzt werden, um sicherzustellen, dass Ausnahmen aufgrund der Argumentüberprüfung ausgelöst werden, bevor mit der asynchronen Arbeit begonnen wird.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-244\">The same technique can be employed with `async` methods to ensure that exceptions arising from argument validation are thrown before the asynchronous work begins.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"014f9-245\">Einige der Entwürfe, die von lokalen Funktionen unterstützt werden, könnten auch mithilfe von *Lambdaausdrücken* erreicht werden.</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-245\">Some of the designs that are supported by local functions could also be accomplished using *lambda expressions*.</span></span> <span data-ttu-id=\"014f9-246\">Weitere Informationen zu den Unterschieden finden Sie im Artikel zu den [Unterschieden zwischen lokalen Funktionen und Lambdaausdrücken](../../local-functions-vs-lambdas.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"014f9-246\">Those interested can [read more about the differences](../../local-functions-vs-lambdas.md).</span></span>\n"
- content: <span data-ttu-id="014f9-247">Damit haben Sie die Einführung in die wichtigsten neuen Features in C# 7 abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="014f9-247">You've completed an exploration of the major new features in C# 7.</span></span> <span data-ttu-id="014f9-248">Jetzt können Sie sie selbst in Ihrer eigenen Anwendung ausprobieren.</span><span class="sxs-lookup"><span data-stu-id="014f9-248">Now try them yourself in your applications.</span></span> <span data-ttu-id="014f9-249">Die vollständige Liste der Neuerungen finden Sie im Artikel [Neues in C# 7](../../whats-new/csharp-7.md).</span><span class="sxs-lookup"><span data-stu-id="014f9-249">You can see the full list in the [what's new in C# 7](../../whats-new/csharp-7.md) article.</span></span>
