---
title: Ausdrücke – C#-Programmierhandbuch
ms.date: 05/11/2017
helpviewer_keywords:
- expressions [C#]
- C# language, expressions
ms.assetid: c7d8feb0-0e58-4f94-8bf6-4d070550a832
ms.openlocfilehash: 4bbee8f15c2591e8b172df9a6759449d48697804
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 01/07/2020
ms.locfileid: "75699092"
---
# <a name="expressions-c-programming-guide"></a><span data-ttu-id="77409-102">Ausdrücke (C#-Programmierhandbuch)</span><span class="sxs-lookup"><span data-stu-id="77409-102">Expressions (C# Programming Guide)</span></span>

<span data-ttu-id="77409-103">Ein *Ausdruck* ist eine Sequenz von einem oder mehr Operanden und null oder mehr [Operatoren](../../language-reference/operators/index.md), die einen einzelnen Wert, ein Objekt, eine Methode oder einen Namespace annehmen können.</span><span class="sxs-lookup"><span data-stu-id="77409-103">An *expression* is a sequence of one or more operands and zero or more [operators](../../language-reference/operators/index.md) that can be evaluated to a single value, object, method, or namespace.</span></span> <span data-ttu-id="77409-104">Ausdrücke können einen literalen Wert, einen Methodenaufruf, einen Operator und die entsprechenden Operanden oder einen *einfachen Namen* enthalten.</span><span class="sxs-lookup"><span data-stu-id="77409-104">Expressions can consist of a literal value, a method invocation, an operator and its operands, or a *simple name*.</span></span> <span data-ttu-id="77409-105">Einfache Namen können der Name einer Variablen, eines Typmembers, eines Methodenparameters, eines Namespaces oder eines Typs sein.</span><span class="sxs-lookup"><span data-stu-id="77409-105">Simple names can be the name of a variable, type member, method parameter, namespace or type.</span></span>  
  
 <span data-ttu-id="77409-106">Ausdrücke können Operatoren verwenden, die wiederum andere Ausdrücke als Parameter oder Methodenaufrufe verwenden können, deren Parameter wiederum andere Methodenaufrufe darstellen. Ausdrücke können also einfach aber auch sehr komplex sein.</span><span class="sxs-lookup"><span data-stu-id="77409-106">Expressions can use operators that in turn use other expressions as parameters, or method calls whose parameters are in turn other method calls, so expressions can range from simple to very complex.</span></span> <span data-ttu-id="77409-107">Nachstehend sind zwei Beispiele für Ausdrücke:</span><span class="sxs-lookup"><span data-stu-id="77409-107">Following are two examples of expressions:</span></span>  
  
```csharp  
((x < 10) && ( x > 5)) || ((x > 20) && (x < 25));

System.Convert.ToInt32("35");  
```  
  
## <a name="expression-values"></a><span data-ttu-id="77409-108">Ausdruckswerte</span><span class="sxs-lookup"><span data-stu-id="77409-108">Expression values</span></span>

 <span data-ttu-id="77409-109">In den meisten Fällen, in denen Ausdrücke verwendet werden, z.B. in Ausdrücken oder Methodenparametern, wird erwartet, dass der Ausdruck einen Wert ergibt.</span><span class="sxs-lookup"><span data-stu-id="77409-109">In most of the contexts in which expressions are used, for example in statements or method parameters, the expression is expected to evaluate to some value.</span></span> <span data-ttu-id="77409-110">Wenn x und y ganze Zahlen sind, ergibt der Ausdruck `x + y` einen numerischen Wert.</span><span class="sxs-lookup"><span data-stu-id="77409-110">If x and y are integers, the expression `x + y` evaluates to a numeric value.</span></span> <span data-ttu-id="77409-111">Der Ausdruck `new MyClass()` ergibt einen Verweis auf eine neue Instanz einer `MyClass`-Klasse.</span><span class="sxs-lookup"><span data-stu-id="77409-111">The expression `new MyClass()` evaluates to a reference to a new instance of a `MyClass` class.</span></span> <span data-ttu-id="77409-112">Der Ausdruck `myClass.ToString()` ergibt eine Zeichenfolge, da dies der Rückgabetyp der Methode ist.</span><span class="sxs-lookup"><span data-stu-id="77409-112">The expression `myClass.ToString()` evaluates to a string because that is the return type of the method.</span></span> <span data-ttu-id="77409-113">Obwohl ein Namespacename jedoch als Ausdruck klassifiziert ist, ergibt er keinen Wert und kann deshalb nie das Endergebnis eines Ausdrucks sein.</span><span class="sxs-lookup"><span data-stu-id="77409-113">However, although a namespace name is classified as an expression, it does not evaluate to a value and therefore can never be the final result of any expression.</span></span> <span data-ttu-id="77409-114">Sie können keinen Namespacenamen einem Methodenparameter übergeben oder ihn in einem neuen Ausdruck verwenden bzw. ihn einer Variable zuweisen.</span><span class="sxs-lookup"><span data-stu-id="77409-114">You cannot pass a namespace name to a method parameter, or use it in a new expression, or assign it to a variable.</span></span> <span data-ttu-id="77409-115">Sie können ihn nur als Unterausdruck in einem größeren Ausdruck verwenden.</span><span class="sxs-lookup"><span data-stu-id="77409-115">You can only use it as a sub-expression in a larger expression.</span></span> <span data-ttu-id="77409-116">Das gleiche gilt auch für Typen (im Unterschied zu <xref:System.Type?displayProperty=nameWithType>-Objekten), Methodengruppennamen (im Unterschied zu bestimmten Methoden) und Ereignisaccessoren [add](../../language-reference/keywords/add.md) und [remove](../../language-reference/keywords/remove.md).</span><span class="sxs-lookup"><span data-stu-id="77409-116">The same is true for types (as distinct from <xref:System.Type?displayProperty=nameWithType> objects), method group names (as distinct from specific methods), and event [add](../../language-reference/keywords/add.md) and [remove](../../language-reference/keywords/remove.md) accessors.</span></span>  
  
 <span data-ttu-id="77409-117">Jeder Wert verfügt über einen zugeordneten Typ.</span><span class="sxs-lookup"><span data-stu-id="77409-117">Every value has an associated type.</span></span> <span data-ttu-id="77409-118">Wenn z.B. x und y jeweils Variablen vom Typ `int` sind, wird der Wert des Ausdrucks `x + y` auch als `int` geschrieben.</span><span class="sxs-lookup"><span data-stu-id="77409-118">For example, if x and y are both variables of type `int`, the value of the expression `x + y` is also typed as `int`.</span></span> <span data-ttu-id="77409-119">Wenn der Wert einer Variable eines anderen Typs zugewiesen ist oder wenn x und y unterschiedliche Typen sind, werden die Regeln der Typkonvertierung angewendet.</span><span class="sxs-lookup"><span data-stu-id="77409-119">If the value is assigned to a variable of a different type, or if x and y are different types, the rules of type conversion are applied.</span></span> <span data-ttu-id="77409-120">Weitere Informationen darüber, wie Konvertierungen funktionieren, finden Sie unter [Umwandlung und Typkonvertierungen](../types/casting-and-type-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="77409-120">For more information about how such conversions work, see [Casting and Type Conversions](../types/casting-and-type-conversions.md).</span></span>  
  
## <a name="overflows"></a><span data-ttu-id="77409-121">Überläufe</span><span class="sxs-lookup"><span data-stu-id="77409-121">Overflows</span></span>

 <span data-ttu-id="77409-122">Numerische Ausdrücke können zu Überläufen führen, wenn der Wert größer als der Maximalwert des Typs des Werts ist.</span><span class="sxs-lookup"><span data-stu-id="77409-122">Numeric expressions may cause overflows if the value is larger than the maximum value of the value's type.</span></span> <span data-ttu-id="77409-123">Weitere Informationen finden Sie unter [Checked und Unchecked](../../language-reference/keywords/checked-and-unchecked.md) und dem Abschnitt [Explizite numerische Konvertierungen](../../language-reference/builtin-types/numeric-conversions.md#explicit-numeric-conversions) des Artikels [Integrierte numerische Konvertierungen](../../language-reference/builtin-types/numeric-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="77409-123">For more information, see [Checked and Unchecked](../../language-reference/keywords/checked-and-unchecked.md) and the [Explicit numeric conversions](../../language-reference/builtin-types/numeric-conversions.md#explicit-numeric-conversions) section of the [Built-in numeric conversions](../../language-reference/builtin-types/numeric-conversions.md) article.</span></span>
  
## <a name="operator-precedence-and-associativity"></a><span data-ttu-id="77409-124">Operatorrangfolge und Assoziativität</span><span class="sxs-lookup"><span data-stu-id="77409-124">Operator precedence and associativity</span></span>

 <span data-ttu-id="77409-125">Die Art und Weise, wie ein Ausdruck ausgewertet wird, unterliegt den Regeln der Assoziativität und Operatorrangfolge.</span><span class="sxs-lookup"><span data-stu-id="77409-125">The manner in which an expression is evaluated is governed by the rules of associativity and operator precedence.</span></span> <span data-ttu-id="77409-126">Weitere Informationen finden Sie unter [Operatoren](../../language-reference/operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="77409-126">For more information, see [Operators](../../language-reference/operators/index.md).</span></span>  
  
 <span data-ttu-id="77409-127">Die meisten Ausdrücke, außer Zuweisungsausdrücke und Methodenaufrufausdrücke, müssen in einer Anweisung eingebettet sein.</span><span class="sxs-lookup"><span data-stu-id="77409-127">Most expressions, except assignment expressions and method invocation expressions, must be embedded in a statement.</span></span> <span data-ttu-id="77409-128">Weitere Informationen finden Sie unter [Anweisungen](./statements.md).</span><span class="sxs-lookup"><span data-stu-id="77409-128">For more information, see [Statements](./statements.md).</span></span>  
  
## <a name="literals-and-simple-names"></a><span data-ttu-id="77409-129">Literale und einfache Namen</span><span class="sxs-lookup"><span data-stu-id="77409-129">Literals and simple names</span></span>

 <span data-ttu-id="77409-130">Die zwei einfachsten Typen von Ausdrücken sind Literale und einfache Namen.</span><span class="sxs-lookup"><span data-stu-id="77409-130">The two simplest types of expressions are literals and simple names.</span></span> <span data-ttu-id="77409-131">Ein Literal ist ein konstanter Wert, der keinen Namen besitzt.</span><span class="sxs-lookup"><span data-stu-id="77409-131">A literal is a constant value that has no name.</span></span> <span data-ttu-id="77409-132">Im folgenden Codebeispiel sind z.B. `5` und `"Hello World"` jeweils Literalwerte:</span><span class="sxs-lookup"><span data-stu-id="77409-132">For example, in the following code example, both `5` and `"Hello World"` are literal values:</span></span>  
  
 [!code-csharp[csProgGuideStatements#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#2)]  
  
 <span data-ttu-id="77409-133">Weitere Informationen zu Literalen finden Sie unter [Typen](/dotnet/csharp/language-reference/keywords).</span><span class="sxs-lookup"><span data-stu-id="77409-133">For more information on literals, see [Types](/dotnet/csharp/language-reference/keywords).</span></span>  
  
 <span data-ttu-id="77409-134">Im vorherigen Beispiel sind `i` und `s` jeweils einfache Namen, die lokale Variablen identifizieren.</span><span class="sxs-lookup"><span data-stu-id="77409-134">In the preceding example, both `i` and `s` are simple names that identify local variables.</span></span> <span data-ttu-id="77409-135">Wenn diese Variablen in einem Ausdruck verwendet werden, ergibt der Variablenname einen Wert, der derzeit am Speicherort der Variable im Speicher gespeichert ist.</span><span class="sxs-lookup"><span data-stu-id="77409-135">When those variables are used in an expression, the variable name evaluates to the value that is currently stored in the variable's location in memory.</span></span> <span data-ttu-id="77409-136">Dies wird im folgenden Beispiel gezeigt:</span><span class="sxs-lookup"><span data-stu-id="77409-136">This is shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#3)]

## <a name="invocation-expressions"></a><span data-ttu-id="77409-137">Aufrufausdrücke</span><span class="sxs-lookup"><span data-stu-id="77409-137">Invocation expressions</span></span>

 <span data-ttu-id="77409-138">Im folgenden Codebeispiel ist der Aufruf von `DoWork` ein Aufrufausdruck.</span><span class="sxs-lookup"><span data-stu-id="77409-138">In the following code example, the call to `DoWork` is an invocation expression.</span></span>  
  
```csharp
DoWork();  
```  
  
 <span data-ttu-id="77409-139">Ein Methodenaufruf erfordert den Namen der Methode entweder als Name wie im vorherigen Beispiel oder als Ergebnis eines anderen Ausdrucks, gefolgt von einer Klammer und beliebigen Methodenparametern.</span><span class="sxs-lookup"><span data-stu-id="77409-139">A method invocation requires the name of the method, either as a name as in the previous example, or as the result of another expression, followed by parenthesis and any method parameters.</span></span> <span data-ttu-id="77409-140">Weitere Informationen finden Sie unter [Methoden](../classes-and-structs/methods.md).</span><span class="sxs-lookup"><span data-stu-id="77409-140">For more information, see [Methods](../classes-and-structs/methods.md).</span></span> <span data-ttu-id="77409-141">Ein Delegataufruf verwendet den Namen eines Delegaten sowie Methodenparameter in Klammern.</span><span class="sxs-lookup"><span data-stu-id="77409-141">A delegate invocation uses the name of a delegate and method parameters in parenthesis.</span></span> <span data-ttu-id="77409-142">Weitere Informationen finden Sie unter [Delegaten](../delegates/index.md).</span><span class="sxs-lookup"><span data-stu-id="77409-142">For more information, see [Delegates](../delegates/index.md).</span></span> <span data-ttu-id="77409-143">Methodenaufrufe und Delegataufrufe ergeben den Rückgabewert der Methode, wenn die Methode einen Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="77409-143">Method invocations and delegate invocations evaluate to the return value of the method, if the method returns a value.</span></span> <span data-ttu-id="77409-144">Methoden, die „void“ zurückgeben, können nicht anstatt eines Werts in einem Ausdruck verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="77409-144">Methods that return void cannot be used in place of a value in an expression.</span></span>  

## <a name="query-expressions"></a><span data-ttu-id="77409-145">Abfrageausdrücke</span><span class="sxs-lookup"><span data-stu-id="77409-145">Query expressions</span></span>

 <span data-ttu-id="77409-146">Die gleichen Regeln für Ausdrücke gelten allgemein für Abfrageausdrücke.</span><span class="sxs-lookup"><span data-stu-id="77409-146">The same rules for expressions in general apply to query expressions.</span></span> <span data-ttu-id="77409-147">Weitere Informationen finden Sie unter [LINQ](../../linq/index.md).</span><span class="sxs-lookup"><span data-stu-id="77409-147">For more information, see [LINQ](../../linq/index.md).</span></span>  
  
## <a name="lambda-expressions"></a><span data-ttu-id="77409-148">Lambdaausdrücke</span><span class="sxs-lookup"><span data-stu-id="77409-148">Lambda expressions</span></span>

 <span data-ttu-id="77409-149">Lambdaausdrücke stellen „Inlinemethoden“ dar, die keinen Namen haben, jedoch über Eingabeparameter und mehrere Anweisungen verfügen können.</span><span class="sxs-lookup"><span data-stu-id="77409-149">Lambda expressions represent "inline methods" that have no name but can have input parameters and multiple statements.</span></span> <span data-ttu-id="77409-150">Sie werden häufig in LINQ verwendet, um Argumente Methoden zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="77409-150">They are used extensively in LINQ to pass arguments to methods.</span></span> <span data-ttu-id="77409-151">Lambdaausdrücke werden entweder zu Delegaten oder Ausdrucksbaumstrukturen kompiliert. Dies hängt vom Kontext ab, in dem sie verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="77409-151">Lambda expressions are compiled to either delegates or expression trees depending on the context in which they are used.</span></span> <span data-ttu-id="77409-152">Weitere Informationen finden Sie unter [Lambdaausdrücke](lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="77409-152">For more information, see [Lambda Expressions](lambda-expressions.md).</span></span>  
  
## <a name="expression-trees"></a><span data-ttu-id="77409-153">Ausdrucksbaumstrukturen</span><span class="sxs-lookup"><span data-stu-id="77409-153">Expression trees</span></span>

<span data-ttu-id="77409-154">Mithilfe von Ausdrucksbaumstrukturen können Ausdrücke als Datenstrukturen dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="77409-154">Expression trees enable expressions to be represented as data structures.</span></span> <span data-ttu-id="77409-155">Sie werden häufig von LINQ-Anbietern verwendet, um Abfrageausdrücke in Code zu übersetzen, der in einem anderen Kontext aussagekräftig ist, z.B. als SQL-Datenbank.</span><span class="sxs-lookup"><span data-stu-id="77409-155">They are used extensively by LINQ providers to translate query expressions into code that is meaningful in some other context, such as a SQL database.</span></span> <span data-ttu-id="77409-156">Weitere Informationen finden Sie unter [Ausdrucksbaumstrukturen (C#)](../concepts/expression-trees/index.md).</span><span class="sxs-lookup"><span data-stu-id="77409-156">For more information, see [Expression Trees (C#)](../concepts/expression-trees/index.md).</span></span>
  
## <a name="expression-body-definitions"></a><span data-ttu-id="77409-157">Ausdruckstextdefinitionen</span><span class="sxs-lookup"><span data-stu-id="77409-157">Expression body definitions</span></span>

<span data-ttu-id="77409-158">C# unterstützt *Ausdruckskörpermember*, mit denen Sie eine präzise Ausdrückskörperdefiniton für Methoden, Konstruktoren, Finalizer, Eigenschaften und Indexer angeben können.</span><span class="sxs-lookup"><span data-stu-id="77409-158">C# supports *expression-bodied members*, which allow you to supply a concise expression body definition for methods, constructors, finalizers, properties, and indexers.</span></span> <span data-ttu-id="77409-159">Weitere Informationen finden Sie unter [Ausdruckskörpermember](expression-bodied-members.md).</span><span class="sxs-lookup"><span data-stu-id="77409-159">For more information, see [Expression-bodied members](expression-bodied-members.md).</span></span>

## <a name="remarks"></a><span data-ttu-id="77409-160">Hinweise</span><span class="sxs-lookup"><span data-stu-id="77409-160">Remarks</span></span>

 <span data-ttu-id="77409-161">Wann immer eine Variable, eine Objekteigenschaft oder ein Objektindexerzugriff von einem Ausdruck identifiziert wird, wird der Wert dieses Elements als Wert des Ausdrucks verwendet.</span><span class="sxs-lookup"><span data-stu-id="77409-161">Whenever a variable, object property, or object indexer access is identified from an expression, the value of that item is used as the value of the expression.</span></span> <span data-ttu-id="77409-162">Ein Ausdruck kann dort in C# platziert werden, wo ein Wert oder Objekt benötigt wird, solange der Ausdruck letztendlich den geforderten Typ ergibt.</span><span class="sxs-lookup"><span data-stu-id="77409-162">An expression can be placed anywhere in C# where a value or object is required, as long as the expression ultimately evaluates to the required type.</span></span>  

## <a name="c-language-specification"></a><span data-ttu-id="77409-163">C#-Sprachspezifikation</span><span class="sxs-lookup"><span data-stu-id="77409-163">C# language specification</span></span>

<span data-ttu-id="77409-164">Weitere Informationen finden Sie im Abschnitt [Ausdrücke](~/_csharplang/spec/expressions.md) der [C#-Sprachspezifikation](~/_csharplang/spec/introduction.md).</span><span class="sxs-lookup"><span data-stu-id="77409-164">For more information, see the [Expressions](~/_csharplang/spec/expressions.md) section of the [C# language specification](~/_csharplang/spec/introduction.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="77409-165">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="77409-165">See also</span></span>

- [<span data-ttu-id="77409-166">C#-Programmierhandbuch</span><span class="sxs-lookup"><span data-stu-id="77409-166">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="77409-167">Operatoren</span><span class="sxs-lookup"><span data-stu-id="77409-167">Operators</span></span>](../../language-reference/operators/index.md)
- [<span data-ttu-id="77409-168">Methoden</span><span class="sxs-lookup"><span data-stu-id="77409-168">Methods</span></span>](../classes-and-structs/methods.md)
- [<span data-ttu-id="77409-169">Delegaten</span><span class="sxs-lookup"><span data-stu-id="77409-169">Delegates</span></span>](../delegates/index.md)
- [<span data-ttu-id="77409-170">Typen</span><span class="sxs-lookup"><span data-stu-id="77409-170">Types</span></span>](../types/index.md)
- [<span data-ttu-id="77409-171">LINQ</span><span class="sxs-lookup"><span data-stu-id="77409-171">LINQ</span></span>](../../linq/index.md)
