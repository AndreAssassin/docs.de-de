---
title: C#-Typen und -Variablen – Überblick über C#
description: Erfahren Sie mehr über das Definieren von Typen und Deklarieren von Variablen in C#.
ms.date: 08/10/2016
ms.assetid: f8a8051e-0049-43f1-b594-9c84cc7b1224
ms.openlocfilehash: ae44dd273a2460e5718adc7324fae324e3de5bba
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 04/17/2019
ms.locfileid: "59672367"
---
# <a name="types-and-variables"></a><span data-ttu-id="ecd0c-103">Typen und Variablen</span><span class="sxs-lookup"><span data-stu-id="ecd0c-103">Types and variables</span></span>

<span data-ttu-id="ecd0c-104">Es gibt zwei Arten von Typen in C#: *Werttypen* und *Verweistypen*.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-104">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="ecd0c-105">Variablen von Werttypen enthalten ihre Daten direkt, Variablen von Verweistypen speichern hingegen Verweise auf ihre Daten – letztere werden als Objekte bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-105">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="ecd0c-106">Mit Verweistypen können zwei Variablen auf das gleiche Objekt verweisen, und so können an einer Variablen durchgeführte Vorgänge das Objekt beeinflussen, auf das die andere Variable verweist.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-106">With reference types, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="ecd0c-107">Bei Werttypen besitzt jede Variable eine eigene Kopie der Daten, und auf eine Variable angewendete Vorgänge können die andere Variable nicht beeinflussen (außer im Fall von `ref`- und `out`-Parametervariablen).</span><span class="sxs-lookup"><span data-stu-id="ecd0c-107">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other (except in the case of `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="ecd0c-108">C#-Werttypen sind weiter unterteilt in *einfache Typen*, *Enumerationstypen*, *Strukturtypen* und *auf NULL festlegbare Werttypen*.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-108">C#’s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="ecd0c-109">C#-Verweistypen sind weiter unterteilt in *Klassentypen*, *Schnittstellentypen*, *Arraytypen* und *Delegattypen*.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-109">C#’s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="ecd0c-110">Im Folgenden finden Sie eine Übersicht des C#-Typsystems.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-110">The following provides an overview of C#’s type system.</span></span>

* <span data-ttu-id="ecd0c-111">[Werttypen][ValueTypes]</span><span class="sxs-lookup"><span data-stu-id="ecd0c-111">[Value types][ValueTypes]</span></span>
  - <span data-ttu-id="ecd0c-112">[Einfache Typen][SimpleTypes]</span><span class="sxs-lookup"><span data-stu-id="ecd0c-112">[Simple types][SimpleTypes]</span></span>
    * <span data-ttu-id="ecd0c-113">Ganzzahlig mit Vorzeichen: `sbyte`, `short`, `int`,`long`</span><span class="sxs-lookup"><span data-stu-id="ecd0c-113">Signed integral: `sbyte`, `short`, `int`, `long`</span></span>
    * <span data-ttu-id="ecd0c-114">Ganzzahlig ohne Vorzeichen: `byte`, `ushort`, `uint`,`ulong`</span><span class="sxs-lookup"><span data-stu-id="ecd0c-114">Unsigned integral: `byte`, `ushort`, `uint`, `ulong`</span></span>
    * <span data-ttu-id="ecd0c-115">Unicode-Zeichen: `char`</span><span class="sxs-lookup"><span data-stu-id="ecd0c-115">Unicode characters: `char`</span></span>
    * <span data-ttu-id="ecd0c-116">IEEE-Gleitkomma: `float`, `double`</span><span class="sxs-lookup"><span data-stu-id="ecd0c-116">IEEE floating point: `float`, `double`</span></span>
    * <span data-ttu-id="ecd0c-117">Dezimalwert mit hoher Genauigkeit: `decimal`</span><span class="sxs-lookup"><span data-stu-id="ecd0c-117">High-precision decimal: `decimal`</span></span>
    * <span data-ttu-id="ecd0c-118">Boolesch: `bool`</span><span class="sxs-lookup"><span data-stu-id="ecd0c-118">Boolean: `bool`</span></span>
  - <span data-ttu-id="ecd0c-119">[Enumerationstypen][EnumTypes]</span><span class="sxs-lookup"><span data-stu-id="ecd0c-119">[Enum types][EnumTypes]</span></span>
    * <span data-ttu-id="ecd0c-120">Benutzerdefinierte Typen der Form `enum E {...}`</span><span class="sxs-lookup"><span data-stu-id="ecd0c-120">User-defined types of the form `enum E {...}`</span></span>
  - <span data-ttu-id="ecd0c-121">[Strukturtypen][StructTypes]</span><span class="sxs-lookup"><span data-stu-id="ecd0c-121">[Struct types][StructTypes]</span></span>
    * <span data-ttu-id="ecd0c-122">Benutzerdefinierte Typen der Form `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="ecd0c-122">User-defined types of the form `struct S {...}`</span></span>
  - <span data-ttu-id="ecd0c-123">[Auf NULL festlegbare Werttypen][NullableTypes]</span><span class="sxs-lookup"><span data-stu-id="ecd0c-123">[Nullable value types][NullableTypes]</span></span>
    * <span data-ttu-id="ecd0c-124">Erweiterungen aller anderen Werttypen mit einem `null`-Wert</span><span class="sxs-lookup"><span data-stu-id="ecd0c-124">Extensions of all other value types with a `null` value</span></span>
* <span data-ttu-id="ecd0c-125">[Verweistypen][ReferenceTypes]</span><span class="sxs-lookup"><span data-stu-id="ecd0c-125">[Reference types][ReferenceTypes]</span></span>
  - <span data-ttu-id="ecd0c-126">[Klassentypen][ClassTypes]</span><span class="sxs-lookup"><span data-stu-id="ecd0c-126">[Class types][ClassTypes]</span></span>
    * <span data-ttu-id="ecd0c-127">Ultimative Basisklasse aller anderen Typen:`object`</span><span class="sxs-lookup"><span data-stu-id="ecd0c-127">Ultimate base class of all other types: `object`</span></span>
    * <span data-ttu-id="ecd0c-128">Unicode-Zeichenfolgen: `string`</span><span class="sxs-lookup"><span data-stu-id="ecd0c-128">Unicode strings: `string`</span></span>
    * <span data-ttu-id="ecd0c-129">Benutzerdefinierte Typen der Form `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="ecd0c-129">User-defined types of the form `class C {...}`</span></span>
  - <span data-ttu-id="ecd0c-130">[Schnittstellentypen][InterfaceTypes]</span><span class="sxs-lookup"><span data-stu-id="ecd0c-130">[Interface types][InterfaceTypes]</span></span>
    * <span data-ttu-id="ecd0c-131">Benutzerdefinierte Typen der Form `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="ecd0c-131">User-defined types of the form `interface I {...}`</span></span>
  - <span data-ttu-id="ecd0c-132">[Arraytypen][ArrayTypes]</span><span class="sxs-lookup"><span data-stu-id="ecd0c-132">[Array types][ArrayTypes]</span></span>
    * <span data-ttu-id="ecd0c-133">Ein- und mehrdimensional, z.B. `int[]` und`int[,]`</span><span class="sxs-lookup"><span data-stu-id="ecd0c-133">Single- and multi-dimensional, for example, `int[]` and `int[,]`</span></span>
  - <span data-ttu-id="ecd0c-134">[Delegattypen][DelegateTypes]</span><span class="sxs-lookup"><span data-stu-id="ecd0c-134">[Delegate types][DelegateTypes]</span></span>
    * <span data-ttu-id="ecd0c-135">Benutzerdefinierte Typen der Form `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="ecd0c-135">User-defined types of the form `delegate int D(...)`</span></span>

[ValueTypes]: ../language-reference/keywords/value-types-table.md
[SimpleTypes]: ../language-reference/keywords/value-types.md#simple-types
[EnumTypes]: ../language-reference/keywords/enum.md
[StructTypes]: ../language-reference/keywords/struct.md
[NullableTypes]: ../programming-guide/nullable-types/index.md
[ReferenceTypes]: ../language-reference/keywords/reference-types.md
[ClassTypes]: ../language-reference/keywords/class.md
[InterfaceTypes]: ../language-reference/keywords/interface.md
[DelegateTypes]: ../language-reference/keywords/delegate.md
[ArrayTypes]: ../programming-guide/arrays/index.md

<span data-ttu-id="ecd0c-136">Die acht Ganzzahltypen unterstützen 8-Bit-, 16-Bit, 32-Bit- und 64-Bit-Werte mit oder ohne Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-136">The eight integral types provide support for 8-bit, 16-bit, 32-bit, and 64-bit values in signed or unsigned form.</span></span>

<span data-ttu-id="ecd0c-137">Die zwei Gleitkommatypen `float` und `double` werden jeweils im 32-Bit-IEC-60559-Format mit einfacher Genauigkeit und 64-Bit-IEC-60559-Format mit doppelter Genauigkeit dargestellt.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-137">The two floating-point types, `float` and `double`, are represented using the 32-bit single-precision and 64-bit double-precision IEC-60559 formats, respectively.</span></span>

<span data-ttu-id="ecd0c-138">Der `decimal`-Typ ist ein für Finanz-und Währungsberechnungen geeigneter 128-Bit-Datentyp.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-138">The `decimal` type is a 128-bit data type suitable for financial and monetary calculations.</span></span>

<span data-ttu-id="ecd0c-139">Der `bool`-Typ von C# dient zur Darstellung boolescher Werte – Werte, die entweder `true` oder `false` sind.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-139">C#’s `bool` type is used to represent Boolean values—values that are either `true` or `false`.</span></span>

<span data-ttu-id="ecd0c-140">Zur Zeichen- und Zeichenfolgenverarbeitung in C# wird die Unicode-Codierung verwendet.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-140">Character and string processing in C# uses Unicode encoding.</span></span> <span data-ttu-id="ecd0c-141">Der `char`-Typ stellt eine UTF-16-Codeeinheit dar und der `string`-Typ eine Folge von UTF-16-Codeeinheiten.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-141">The `char` type represents a UTF-16 code unit, and the `string` type represents a sequence of UTF-16 code units.</span></span>

<span data-ttu-id="ecd0c-142">Hier sind die numerischen Typen von C# zusammengefasst.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-142">This summarizes C#’s numeric types.</span></span>

* <span data-ttu-id="ecd0c-143">Ganzzahlig mit Vorzeichen</span><span class="sxs-lookup"><span data-stu-id="ecd0c-143">Signed Integral</span></span>
  - <span data-ttu-id="ecd0c-144">`sbyte`:  8 Bit, Bereich von -128 bis 127</span><span class="sxs-lookup"><span data-stu-id="ecd0c-144">`sbyte`:  8 bits, range from -128 to 127</span></span>
  - <span data-ttu-id="ecd0c-145">`short`: 16 Bit, Bereich von -32.768 bis 32.767</span><span class="sxs-lookup"><span data-stu-id="ecd0c-145">`short`: 16 bits, range from -32,768 to 32,767</span></span>
  - <span data-ttu-id="ecd0c-146">`int`: 32 Bit, Bereich von -2.147.483.648 bis 2.147.483.647</span><span class="sxs-lookup"><span data-stu-id="ecd0c-146">`int`  : 32 bits, range from -2,147,483,648 to 2,147,483,647</span></span>
  - <span data-ttu-id="ecd0c-147">`long` : 64 Bit, Bereich von -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807</span><span class="sxs-lookup"><span data-stu-id="ecd0c-147">`long` : 64 bits, range from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</span></span>
* <span data-ttu-id="ecd0c-148">Ganzzahlig ohne Vorzeichen</span><span class="sxs-lookup"><span data-stu-id="ecd0c-148">Unsigned integral</span></span>
  - <span data-ttu-id="ecd0c-149">`byte`:  8 Bit, Bereich von -0 bis 255</span><span class="sxs-lookup"><span data-stu-id="ecd0c-149">`byte`   :  8 bits, range from 0 to 255</span></span>
  - <span data-ttu-id="ecd0c-150">`ushort` : 16 Bit, Bereich von 0 bis 65.535</span><span class="sxs-lookup"><span data-stu-id="ecd0c-150">`ushort` : 16 bits, range from 0 to 65,535</span></span>
  - <span data-ttu-id="ecd0c-151">`uint`: 32 Bit, Bereich von 0 bis 4.294.967.295</span><span class="sxs-lookup"><span data-stu-id="ecd0c-151">`uint`   : 32 bits, range from 0 to 4,294,967,295</span></span>
  - <span data-ttu-id="ecd0c-152">`ulong`: 64 Bit, Bereich von 0 bis 18.446.744.073.709.551.615</span><span class="sxs-lookup"><span data-stu-id="ecd0c-152">`ulong`  : 64 bits, range from 0 to 18,446,744,073,709,551,615</span></span>
* <span data-ttu-id="ecd0c-153">Gleitkomma</span><span class="sxs-lookup"><span data-stu-id="ecd0c-153">Floating point</span></span>
  - <span data-ttu-id="ecd0c-154">`float`: 32 Bit, Bereich von 1,5 × 10<sup>-45</sup> bis 3,4 x 10<sup>38</sup>, Genauigkeit von 7 Stellen</span><span class="sxs-lookup"><span data-stu-id="ecd0c-154">`float`  : 32 bits, range from 1.5 × 10<sup>-45</sup> to 3.4 × 10<sup>38</sup>,    7-digit precision</span></span>
  - <span data-ttu-id="ecd0c-155">`double` : 64 Bit, Bereich von 5,0 × 10<sup>-324</sup> bis 1,7 x 10<sup>308</sup>, Genauigkeit von 15 Stellen</span><span class="sxs-lookup"><span data-stu-id="ecd0c-155">`double` : 64 bits, range from 5.0 × 10<sup>-324</sup> to 1.7 × 10<sup>308</sup>, 15-digit precision</span></span>
* <span data-ttu-id="ecd0c-156">Decimal</span><span class="sxs-lookup"><span data-stu-id="ecd0c-156">Decimal</span></span>
  - <span data-ttu-id="ecd0c-157">`decimal` : 128 Bit, Bereich mindestens -7,9 × 10<sup>-28</sup> bis 7,9 x 10<sup>28</sup>, mit einer Genauigkeit von mindestens 28 Stellen</span><span class="sxs-lookup"><span data-stu-id="ecd0c-157">`decimal` : 128 bits, range is at least -7.9 × 10<sup>-28</sup> to 7.9 × 10<sup>28</sup>, with at least 28-digit precision</span></span>

<span data-ttu-id="ecd0c-158">C#-Programme verwenden *Typdeklarationen*, um neue Typen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-158">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="ecd0c-159">Eine Typdeklaration gibt den Namen und die Member des neuen Typs an.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-159">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="ecd0c-160">Fünf Typkategorien von C# sind benutzerdefinierbar: Klassentypen, Strukturtypen, Schnittstellentypen, Enumerationstypen und Delegattypen.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-160">Five of C#’s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

<span data-ttu-id="ecd0c-161">Ein `class`-Typ definiert eine Datenstruktur, die Datenmember (Felder) und Funktionsmember (Methoden, Eigenschaften usw.) enthält.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-161">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="ecd0c-162">Klassentypen unterstützen einzelne Vererbung und Polymorphie. Dies sind Mechanismen, durch die abgeleitete Klassen erweitert und Basisklassen spezialisiert werden können.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-162">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>

<span data-ttu-id="ecd0c-163">Ein `struct`-Typ ähnelt einem Klassentyp, da er eine Struktur mit Datenmembern und Funktionsmembern darstellt.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-163">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="ecd0c-164">Allerdings sind Strukturen im Gegensatz zu Klassen Werttypen und erfordern in der Regel keine Heapzuordnung.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-164">However, unlike classes, structs are value types and do not typically require heap allocation.</span></span> <span data-ttu-id="ecd0c-165">Strukturtypen unterstützen keine benutzerdefinierte Vererbung, und alle Strukturtypen erben implizit vom Typ `object`.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-165">Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>

<span data-ttu-id="ecd0c-166">Ein `interface`-Typ definiert einen Vertrag als benannter Satz öffentlicher Funktionsmember.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-166">An `interface` type defines a contract as a named set of public function members.</span></span> <span data-ttu-id="ecd0c-167">Eine `class` oder `struct`, die eine `interface` implementiert, muss Implementierungen der Funktionsmember der Schnittstelle bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-167">A `class` or `struct` that implements an `interface` must provide implementations of the interface’s function members.</span></span> <span data-ttu-id="ecd0c-168">Eine `interface` kann von mehreren Basisschnittstellen erben, und eine `class` oder `struct` kann mehrere Schnittstellen implementieren.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-168">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>

<span data-ttu-id="ecd0c-169">Ein `delegate`-Typ stellt Verweise auf Methoden mit einer bestimmten Parameterliste und dem Rückgabetyp dar.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-169">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="ecd0c-170">Delegate ermöglichen die Behandlung von Methoden als Entitäten, die Variablen zugewiesen und als Parameter übergeben werden können.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-170">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="ecd0c-171">Delegate werden analog zu Funktionstypen von funktionalen Sprachen bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-171">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="ecd0c-172">Sie ähneln auch dem Konzept von Funktionszeigern, die Sie in einigen anderen Sprachen finden. Im Gegensatz zu Funktionszeigern sind Delegate allerdings objektorientiert und typsicher.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-172">They are also similar to the concept of function pointers found in some other languages, but unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="ecd0c-173">Die Typen, `class`, `struct`, `interface` und `delegate` unterstützen Generics, wobei sie mit anderen Typen parametrisiert werden können.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-173">The `class`, `struct`, `interface` and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="ecd0c-174">Ein `enum`-Typ ist ein eigenständiger Typ mit einer benannten Konstante.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-174">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="ecd0c-175">Jeder `enum`-Typ verfügt über einen zugrunde liegenden Typ, der einer der acht ganzzahligen Typen sein muss.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-175">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="ecd0c-176">Der Satz von Werten eines `enum`-Typs ist mit dem Satz von Werten des zugrunde liegenden Typs identisch.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-176">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>

<span data-ttu-id="ecd0c-177">C# unterstützt ein- und mehrdimensionale Arrays beliebigen Typs.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-177">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="ecd0c-178">Im Gegensatz zu den oben aufgeführten Typen müssen Arraytypen nicht deklariert werden, bevor sie verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-178">Unlike the types listed above, array types do not have to be declared before they can be used.</span></span> <span data-ttu-id="ecd0c-179">Stattdessen werden Arraytypen erstellt, indem hinter einen Typnamen eckige Klammern gesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-179">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="ecd0c-180">Beispielsweise ist `int[]` ein eindimensionales Array von `int`, `int[,]` ein zweidimensionales Array von `int` und `int[][]` ein eindimensionales Array des eindimensionalen Arrays von `int`.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-180">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array of `int`.</span></span>

<span data-ttu-id="ecd0c-181">Auf NULL festlegbare Werttypen müssen auch nicht deklariert werden, bevor sie verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-181">Nullable value types also do not have to be declared before they can be used.</span></span> <span data-ttu-id="ecd0c-182">Für jeden nicht auf NULL festlegbaren Werttypen `T` gibt es einen entsprechenden auf NULL festlegbaren Werttypen `T?`, der einen zusätzlichen Wert enthalten kann, `null`.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-182">For each non-nullable value type `T` there is a corresponding nullable value type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="ecd0c-183">Beispielsweise ist `int?` ein Typ, der jeden 32-Bit-Ganzzahlwert oder den Wert `null` enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-183">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`.</span></span>

<span data-ttu-id="ecd0c-184">Das C#-Typsystem ist dahingehend vereinheitlicht, dass ein Wert eines beliebigen Typs als `object` behandelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-184">C#’s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="ecd0c-185">Jeder Typ in C# ist direkt oder indirekt vom `object`-Klassentyp abgeleitet, und `object` ist die ultimative Basisklasse aller Typen.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-185">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="ecd0c-186">Werte von Verweistypen werden als Objekte behandelt, indem die Werte einfach als Typ `object` angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-186">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="ecd0c-187">Werte von Werttypen werden durch Ausführen von *Boxing*- und *Unboxingvorgängen* als Objekte behandelt.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-187">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="ecd0c-188">Im folgenden Beispiel wird ein `int`-Wert in ein `object` und wieder in einen `int`-Wert konvertiert.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-188">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

[!code-csharp[Boxing](../../../samples/snippets/csharp/tour/types-and-variables/Program.cs#L1-L10)]

<span data-ttu-id="ecd0c-189">Wenn ein Wert eines Werttyps in den Typ `object` konvertiert wird, wird eine auch „Box“ genannte `object`-Instanz zum Speichern des Werts zugeordnet, und der Wert wird in diese Box kopiert.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-189">When a value of a value type is converted to type `object`, an `object` instance, also called a "box", is allocated to hold the value, and the value is copied into that box.</span></span> <span data-ttu-id="ecd0c-190">Wenn umgekehrt ein `object`-Verweis in einen Werttyp umgewandelt wird, wird überprüft, ob das `object`, auf das verwiesen wird, eine Box des korrekten Datentyps ist, und bei erfolgreicher Überprüfung wird der Wert in der Box kopiert.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-190">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type, and, if the check succeeds, the value in the box is copied out.</span></span>

<span data-ttu-id="ecd0c-191">Aus dem einheitlichen C#-Typensystem resultiert, dass Werttypen „bei Nachfrage“ Objekte werden können.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-191">C#’s unified type system effectively means that value types can become objects "on demand."</span></span> <span data-ttu-id="ecd0c-192">Aufgrund der Vereinheitlichung können Bibliotheken für allgemeine Zwecke, die den Typ `object` verwenden, sowohl mit Verweis- als auch Werttypen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-192">Because of the unification, general-purpose libraries that use type `object` can be used with both reference types and value types.</span></span>

<span data-ttu-id="ecd0c-193">Es gibt mehrere Arten von *Variablen* in C#, einschließlich Feldern, Arrayelementen, lokalen Variablen und Parametern.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-193">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="ecd0c-194">Variablen stellen Speicherorte dar, und jede Variable hat einen Typ, der bestimmt, welche Werte in der Variablen gespeichert werden können, wie unten gezeigt.</span><span class="sxs-lookup"><span data-stu-id="ecd0c-194">Variables represent storage locations, and every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

* <span data-ttu-id="ecd0c-195">Nicht auf NULL festlegbarer Werttyp</span><span class="sxs-lookup"><span data-stu-id="ecd0c-195">Non-nullable value type</span></span>
  - <span data-ttu-id="ecd0c-196">Ein Wert genau dieses Typs</span><span class="sxs-lookup"><span data-stu-id="ecd0c-196">A value of that exact type</span></span>
* <span data-ttu-id="ecd0c-197">Auf NULL festlegbarer Werttyp</span><span class="sxs-lookup"><span data-stu-id="ecd0c-197">Nullable value type</span></span>
  - <span data-ttu-id="ecd0c-198">Ein `null`-Wert oder ein Wert genau dieses Typs</span><span class="sxs-lookup"><span data-stu-id="ecd0c-198">A `null` value or a value of that exact type</span></span>
* <span data-ttu-id="ecd0c-199">object</span><span class="sxs-lookup"><span data-stu-id="ecd0c-199">object</span></span>
  - <span data-ttu-id="ecd0c-200">Ein `null`-Verweis, ein Verweis auf ein Objekt eines beliebigen Verweistyps oder ein Verweis auf einen geschachtelten Wert eines beliebigen Werttyps</span><span class="sxs-lookup"><span data-stu-id="ecd0c-200">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
* <span data-ttu-id="ecd0c-201">Klassentyp</span><span class="sxs-lookup"><span data-stu-id="ecd0c-201">Class type</span></span>
  - <span data-ttu-id="ecd0c-202">Ein `null`-Verweis, ein Verweis auf eine Instanz dieses Klassentyps oder ein Verweis auf eine Instanz einer Klasse, die von diesem Klassentyp abgeleitet ist</span><span class="sxs-lookup"><span data-stu-id="ecd0c-202">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
* <span data-ttu-id="ecd0c-203">Schnittstellentyp</span><span class="sxs-lookup"><span data-stu-id="ecd0c-203">Interface type</span></span>
  - <span data-ttu-id="ecd0c-204">Ein `null`-Verweis, ein Verweis auf eine Instanz eines Klassentyps, der diesen Schnittstellentyp implementiert, oder ein Verweis auf einen geschachtelten Wert eines Werttyps, der diesen Schnittstellentyp implementiert</span><span class="sxs-lookup"><span data-stu-id="ecd0c-204">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
* <span data-ttu-id="ecd0c-205">Arraytyp</span><span class="sxs-lookup"><span data-stu-id="ecd0c-205">Array type</span></span>
  - <span data-ttu-id="ecd0c-206">Ein `null`-Verweis, ein Verweis auf eine Instanz dieses Arraytyps oder ein Verweis auf eine Instanz eines kompatiblen Arraytyps</span><span class="sxs-lookup"><span data-stu-id="ecd0c-206">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
* <span data-ttu-id="ecd0c-207">Delegattyp</span><span class="sxs-lookup"><span data-stu-id="ecd0c-207">Delegate type</span></span>
  - <span data-ttu-id="ecd0c-208">Ein `null`-Verweis oder ein Verweis auf eine Instanz eines kompatiblen Delegattyp</span><span class="sxs-lookup"><span data-stu-id="ecd0c-208">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="ecd0c-209">[Zurück](program-structure.md)
> [Weiter](expressions.md)</span><span class="sxs-lookup"><span data-stu-id="ecd0c-209">[Previous](program-structure.md)
[Next](expressions.md)</span></span>
