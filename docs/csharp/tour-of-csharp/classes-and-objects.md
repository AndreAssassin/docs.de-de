---
title: Klassen und Objekte in C# – Überblick über C#
description: Neu bei C#? Lesen Sie diese Übersicht über Klassen, Objekte und Vererbung.
ms.date: 02/27/2020
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.openlocfilehash: c178e11b5667905f75538555c8a309e2fdb4a9ef
ms.sourcegitcommit: 00aa62e2f469c2272a457b04e66b4cc3c97a800b
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 02/28/2020
ms.locfileid: "78159181"
---
# <a name="classes-and-objects"></a><span data-ttu-id="2a9be-104">Klassen und Objekte</span><span class="sxs-lookup"><span data-stu-id="2a9be-104">Classes and objects</span></span>

<span data-ttu-id="2a9be-105">*Klassen* sind die grundlegendsten der C#-Typen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-105">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="2a9be-106">Eine Klasse ist eine Datenstruktur, die einen Zustand (Felder) und Aktionen (Methoden und andere Funktionsmember) in einer einzigen Einheit kombiniert.</span><span class="sxs-lookup"><span data-stu-id="2a9be-106">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="2a9be-107">Eine Klasse stellt eine Definition für dynamisch erstellte *Instanzen* der Klasse, auch bekannt als *Objekte* bereit.</span><span class="sxs-lookup"><span data-stu-id="2a9be-107">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="2a9be-108">Klassen unterstützen *Vererbung* und *Polymorphie*. Dies sind Mechanismen, durch die *abgeleitete Klassen* erweitert und *Basisklassen* spezialisiert werden können.</span><span class="sxs-lookup"><span data-stu-id="2a9be-108">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="2a9be-109">Neue Klassen werden mithilfe von Klassendeklarationen erstellt.</span><span class="sxs-lookup"><span data-stu-id="2a9be-109">New classes are created using class declarations.</span></span> <span data-ttu-id="2a9be-110">Eine Klassendeklaration beginnt mit einem Header, der die Attribute und Modifizierer der Klasse, den Namen der Klasse, die Basisklasse (sofern vorhanden) und die von der Klasse implementierten Schnittstellen angibt.</span><span class="sxs-lookup"><span data-stu-id="2a9be-110">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="2a9be-111">Auf den Header folgt der Klassenkörper. Dieser besteht aus einer Liste der Memberdeklarationen, die zwischen den Trennzeichen `{` und `}` eingefügt werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-111">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="2a9be-112">Im folgenden Code wird die Deklaration einer einfachen Klasse namens `Point` veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="2a9be-112">The following code shows a declaration of a simple class named `Point`:</span></span>

[!code-csharp[PointClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]

<span data-ttu-id="2a9be-113">Instanzen von Klassen werden mit dem `new`-Operator erstellt. Dieser reserviert Speicher für eine neue Instanz, ruft einen Konstruktor zum Initialisieren der Instanz auf und gibt einen Verweis auf die Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="2a9be-113">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="2a9be-114">Mit den folgenden Anweisungen werden zwei Point-Objekte erstellt und Verweise auf diese Objekte in zwei Variablen gespeichert:</span><span class="sxs-lookup"><span data-stu-id="2a9be-114">The following statements create two Point objects and store references to those objects in two variables:</span></span>

[!code-csharp[PointExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]

<span data-ttu-id="2a9be-115">Der von einem Objekt belegte Speicher wird automatisch wieder freigegeben, wenn das Objekt nicht mehr erreichbar ist.</span><span class="sxs-lookup"><span data-stu-id="2a9be-115">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="2a9be-116">Es ist weder erforderlich noch möglich, die Zuweisung von Objekten in C# explizit aufzuheben.</span><span class="sxs-lookup"><span data-stu-id="2a9be-116">It's neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="2a9be-117">Member</span><span class="sxs-lookup"><span data-stu-id="2a9be-117">Members</span></span>

<span data-ttu-id="2a9be-118">Die Member einer Klasse sind entweder statische Member oder Instanzmember.</span><span class="sxs-lookup"><span data-stu-id="2a9be-118">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="2a9be-119">Statische Member gehören zu Klassen, Instanzmember gehören zu Objekten (Instanzen von Klassen).</span><span class="sxs-lookup"><span data-stu-id="2a9be-119">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="2a9be-120">In der folgenden Liste finden Sie einen Überblick über die Memberarten, die eine Klasse enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="2a9be-120">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="2a9be-121">Konstanten</span><span class="sxs-lookup"><span data-stu-id="2a9be-121">Constants</span></span>
  - <span data-ttu-id="2a9be-122">Konstante Werte, die der Klasse zugeordnet sind</span><span class="sxs-lookup"><span data-stu-id="2a9be-122">Constant values associated with the class</span></span>
- <span data-ttu-id="2a9be-123">Felder</span><span class="sxs-lookup"><span data-stu-id="2a9be-123">Fields</span></span>
  - <span data-ttu-id="2a9be-124">Variablen der Klasse</span><span class="sxs-lookup"><span data-stu-id="2a9be-124">Variables of the class</span></span>
- <span data-ttu-id="2a9be-125">Methoden</span><span class="sxs-lookup"><span data-stu-id="2a9be-125">Methods</span></span>
  - <span data-ttu-id="2a9be-126">Berechnungen und Aktionen, die von der Klasse ausgeführt werden</span><span class="sxs-lookup"><span data-stu-id="2a9be-126">Computations and actions that can be performed by the class</span></span>
- <span data-ttu-id="2a9be-127">Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="2a9be-127">Properties</span></span>
  - <span data-ttu-id="2a9be-128">Aktionen im Zusammenhang mit dem Lesen und Schreiben von benannten Eigenschaften der Klasse</span><span class="sxs-lookup"><span data-stu-id="2a9be-128">Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="2a9be-129">Indexer</span><span class="sxs-lookup"><span data-stu-id="2a9be-129">Indexers</span></span>
  - <span data-ttu-id="2a9be-130">Aktionen im Zusammenhang mit dem Indizieren von Instanzen der Klasse, z.B. einem Array</span><span class="sxs-lookup"><span data-stu-id="2a9be-130">Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="2a9be-131">Ereignisse</span><span class="sxs-lookup"><span data-stu-id="2a9be-131">Events</span></span>
  - <span data-ttu-id="2a9be-132">Benachrichtigungen, die von der Klasse generiert werden können</span><span class="sxs-lookup"><span data-stu-id="2a9be-132">Notifications that can be generated by the class</span></span>
- <span data-ttu-id="2a9be-133">Operatoren</span><span class="sxs-lookup"><span data-stu-id="2a9be-133">Operators</span></span>
  - <span data-ttu-id="2a9be-134">Operatoren für Konvertierungen und Ausdrücke, die von der Klasse unterstützt werden</span><span class="sxs-lookup"><span data-stu-id="2a9be-134">Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="2a9be-135">Konstruktoren</span><span class="sxs-lookup"><span data-stu-id="2a9be-135">Constructors</span></span>
  - <span data-ttu-id="2a9be-136">Aktionen, die zum Initialisieren von Instanzen der Klasse oder der Klasse selbst benötigt werden</span><span class="sxs-lookup"><span data-stu-id="2a9be-136">Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="2a9be-137">Finalizer</span><span class="sxs-lookup"><span data-stu-id="2a9be-137">Finalizers</span></span>
  - <span data-ttu-id="2a9be-138">Aktionen, die ausgeführt werden, bevor Instanzen der Klasse dauerhaft verworfen werden</span><span class="sxs-lookup"><span data-stu-id="2a9be-138">Actions to perform before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="2a9be-139">Typen</span><span class="sxs-lookup"><span data-stu-id="2a9be-139">Types</span></span>
  - <span data-ttu-id="2a9be-140">Geschachtelte Typen, die von der Klasse deklariert werden</span><span class="sxs-lookup"><span data-stu-id="2a9be-140">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="2a9be-141">Zugriff</span><span class="sxs-lookup"><span data-stu-id="2a9be-141">Accessibility</span></span>

<span data-ttu-id="2a9be-142">Jeder Member einer Klasse ist mit einem Zugriff verknüpft, der die Regionen des Programmtexts steuert, die auf den Member zugreifen können.</span><span class="sxs-lookup"><span data-stu-id="2a9be-142">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="2a9be-143">Es gibt sechs mögliche Formen des Zugriffs.</span><span class="sxs-lookup"><span data-stu-id="2a9be-143">There are six possible forms of accessibility.</span></span> <span data-ttu-id="2a9be-144">Die Zugriffsmodifizierer werden im Folgenden zusammengefasst.</span><span class="sxs-lookup"><span data-stu-id="2a9be-144">The access modifiers are summarized below.</span></span>

- `public`
  - <span data-ttu-id="2a9be-145">Der Zugriff ist nicht eingeschränkt.</span><span class="sxs-lookup"><span data-stu-id="2a9be-145">Access isn't limited.</span></span>
- `protected`
  - <span data-ttu-id="2a9be-146">Der Zugriff ist auf diese Klasse oder von dieser abgeleiteten Klassen beschränkt.</span><span class="sxs-lookup"><span data-stu-id="2a9be-146">Access is limited to this class or classes derived from this class.</span></span>
- `internal`
  - <span data-ttu-id="2a9be-147">Der Zugriff ist auf die aktuelle Assembly beschränkt („.exe“, „.dll“ usw.).</span><span class="sxs-lookup"><span data-stu-id="2a9be-147">Access is limited to the current assembly (.exe, .dll, and so on.).</span></span>
- `protected internal`
  - <span data-ttu-id="2a9be-148">Der Zugriff ist auf die enthaltende Klasse, auf Klassen, die von der enthaltenden Klasse abgeleitet sind, oder auf Klassen innerhalb der gleichen Assembly beschränkt.</span><span class="sxs-lookup"><span data-stu-id="2a9be-148">Access is limited to the containing class, classes derived from the containing class, or classes within the same assembly.</span></span>
- `private`
  - <span data-ttu-id="2a9be-149">Der Zugriff ist auf diese Klasse beschränkt.</span><span class="sxs-lookup"><span data-stu-id="2a9be-149">Access is limited to this class.</span></span>
- `private protected`
  - <span data-ttu-id="2a9be-150">Der Zugriff ist auf die enthaltende Klasse oder auf Klassen beschränkt, die vom enthaltenden Typ in der gleichen Assembly abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-150">Access is limited to the containing class or classes derived from the containing type within the same assembly.</span></span>

## <a name="type-parameters"></a><span data-ttu-id="2a9be-151">Typparameter</span><span class="sxs-lookup"><span data-stu-id="2a9be-151">Type parameters</span></span>

<span data-ttu-id="2a9be-152">Eine Klassendefinition kann einen Satz an Typparametern angeben, indem eine Liste der Typparameternamen in spitzen Klammern an den Klassennamen angehängt wird.</span><span class="sxs-lookup"><span data-stu-id="2a9be-152">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="2a9be-153">Die Typparameter können dann im Körper der Klassendeklarationen zum Definieren der Klassenmember verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-153">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="2a9be-154">Im folgenden Beispiel lauten die Typparameter von `Pair``TFirst` und `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="2a9be-154">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

[!code-csharp[Pair](~/samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]

<span data-ttu-id="2a9be-155">Ein Klassentyp, der zum Akzeptieren von Typparametern deklariert wird, wird als *generischer Klassentyp* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="2a9be-155">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="2a9be-156">Struktur-, Schnittstellen- und Delegattypen können auch generisch sein.</span><span class="sxs-lookup"><span data-stu-id="2a9be-156">Struct, interface, and delegate types can also be generic.</span></span>
<span data-ttu-id="2a9be-157">Wenn die generische Klasse verwendet wird, müssen für jeden der Typparameter Typargumente angegeben werden:</span><span class="sxs-lookup"><span data-stu-id="2a9be-157">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

[!code-csharp[PairExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]

<span data-ttu-id="2a9be-158">Ein generischer Typ, für den Typargumente angegeben wurden (siehe `Pair<int,string>` oben), wird als *konstruierter Typ* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="2a9be-158">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="2a9be-159">Basisklassen</span><span class="sxs-lookup"><span data-stu-id="2a9be-159">Base classes</span></span>

<span data-ttu-id="2a9be-160">Eine Klassendeklaration kann eine Basisklasse angeben, indem ein Doppelpunkt und der Name der Basisklasse an den Klassennamen und die Typparameter angehängt wird.</span><span class="sxs-lookup"><span data-stu-id="2a9be-160">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="2a9be-161">Das Auslassen einer Basisklassenspezifikation ist dasselbe wie eine Ableitung vom Typ `object`.</span><span class="sxs-lookup"><span data-stu-id="2a9be-161">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="2a9be-162">Im folgenden Beispiel ist `Point` die Basisklasse von `Point3D`, und die Basisklasse von `Point` ist `object`:</span><span class="sxs-lookup"><span data-stu-id="2a9be-162">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

[!code-csharp[Point3DClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]

<span data-ttu-id="2a9be-163">Eine Klasse erbt die Member der zugehörigen Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="2a9be-163">A class inherits the members of its base class.</span></span> <span data-ttu-id="2a9be-164">Vererbung bedeutet, dass eine Klasse implizit alle Member dieser Basisklasse enthält, mit Ausnahme der Instanzkonstruktoren und der statischen Konstruktoren sowie der Finalizer der Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="2a9be-164">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="2a9be-165">Eine abgeleitete Klasse kann den geerbten Membern neue Member hinzufügen, aber die Definition eines geerbten Members kann nicht entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-165">A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.</span></span> <span data-ttu-id="2a9be-166">Im vorherigen Beispiel erbt `Point3D` die Felder `x` und `y` von `Point`, und jede `Point3D`-Instanz enthält drei Felder: `x`, `y` und `z`.</span><span class="sxs-lookup"><span data-stu-id="2a9be-166">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="2a9be-167">Ein Klassentyp kann implizit in einen beliebigen zugehörigen Basisklassentyp konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-167">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="2a9be-168">Eine Variable eines Klassentyps kann auf eine Instanz der Klasse oder eine Instanz einer beliebigen abgeleiteten Klasse verweisen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-168">A variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="2a9be-169">Beispielsweise kann in den vorherigen Klassendeklarationen eine Variable vom Typ `Point` entweder auf `Point` oder auf `Point3D` verweisen:</span><span class="sxs-lookup"><span data-stu-id="2a9be-169">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

[!code-csharp[Point3DExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]

## <a name="fields"></a><span data-ttu-id="2a9be-170">Felder</span><span class="sxs-lookup"><span data-stu-id="2a9be-170">Fields</span></span>

<span data-ttu-id="2a9be-171">Ein *Feld* ist eine Variable, die einer Klasse oder einer Instanz einer Klasse zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="2a9be-171">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="2a9be-172">Ein Feld, das mit dem static-Modifizierer deklariert wurde, definiert ein statisches Feld.</span><span class="sxs-lookup"><span data-stu-id="2a9be-172">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="2a9be-173">Ein statisches Feld identifiziert genau einen Speicherort.</span><span class="sxs-lookup"><span data-stu-id="2a9be-173">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="2a9be-174">Unabhängig davon, wie viele Instanzen einer Klasse erstellt werden, gibt es immer nur eine Kopie eines statischen Felds.</span><span class="sxs-lookup"><span data-stu-id="2a9be-174">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="2a9be-175">Ein Feld, das ohne den static-Modifizierer deklariert wurde, definiert ein Instanzfeld.</span><span class="sxs-lookup"><span data-stu-id="2a9be-175">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="2a9be-176">Jede Instanz einer Klasse enthält eine separate Kopie aller Instanzfelder dieser Klasse.</span><span class="sxs-lookup"><span data-stu-id="2a9be-176">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="2a9be-177">Im folgenden Beispiel weist jede Instanz der `Color`-Klasse eine separate Kopie der Instanzfelder `r`, `g` und `b` auf, aber es gibt nur eine Kopie der statischen Felder `Black`, `White`, `Red`, `Green` und `Blue`:</span><span class="sxs-lookup"><span data-stu-id="2a9be-177">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

[!code-csharp[ColorClass](~/samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]

<span data-ttu-id="2a9be-178">Wie im vorherigen Beispiel gezeigt, können *schreibgeschützte Felder* mit einem `readonly`-Modifizierer deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-178">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="2a9be-179">Einem `readonly`-Feld können Werte nur als Teil einer Deklaration oder in einem Konstruktor derselben Klasse zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-179">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="2a9be-180">Methoden</span><span class="sxs-lookup"><span data-stu-id="2a9be-180">Methods</span></span>

<span data-ttu-id="2a9be-181">Eine *Methode* ist ein Member, das eine Berechnung oder eine Aktion implementiert, die durch ein Objekt oder eine Klasse durchgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="2a9be-181">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="2a9be-182">Auf *statische Methoden* wird über die Klasse zugegriffen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-182">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="2a9be-183">Auf *Instanzmethoden* wird über Instanzen der Klasse zugegriffen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-183">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="2a9be-184">Methoden können über eine Liste von *Parametern* – diese repräsentieren die an die Methode übergebene Werte oder Variablenverweise – sowie über einen *Rückgabetyp* verfügen, der den Typ des Werts angibt, der von der Methode berechnet und zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="2a9be-184">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="2a9be-185">Der Rückgabetyp einer Methode lautet `void`, wenn kein Wert zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="2a9be-185">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="2a9be-186">Ebenso wie Typen können Methoden einen Satz an Typparametern aufweisen, für den beim Aufruf der Methode Typargumente angegeben werden müssen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-186">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="2a9be-187">Im Gegensatz zu Typen können die Typargumente häufig aus den Argumenten eines Methodenaufrufs abgeleitet werden und müssen nicht explizit angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-187">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="2a9be-188">Die *Signatur* einer Methode muss innerhalb der Klasse eindeutig sein, in der die Methode deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="2a9be-188">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="2a9be-189">Die Signatur einer Methode besteht aus dem Namen der Methode, der Anzahl von Typparametern und der Anzahl, den Modifizierern und den Typen der zugehörigen Parameter.</span><span class="sxs-lookup"><span data-stu-id="2a9be-189">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="2a9be-190">Die Signatur einer Methode umfasst nicht den Rückgabetyp.</span><span class="sxs-lookup"><span data-stu-id="2a9be-190">The signature of a method doesn't include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="2a9be-191">Parameter</span><span class="sxs-lookup"><span data-stu-id="2a9be-191">Parameters</span></span>

<span data-ttu-id="2a9be-192">Parameter werden dazu verwendet, Werte oder Variablenverweise an Methoden zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="2a9be-192">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="2a9be-193">Die Parameter einer Methode erhalten ihre tatsächlichen Werte über *Argumente*, die angegeben werden, wenn die Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="2a9be-193">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="2a9be-194">Es gibt vier Arten von Parametern: Wertparameter, Verweisparameter, Ausgabeparameter und Parameterarrays.</span><span class="sxs-lookup"><span data-stu-id="2a9be-194">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="2a9be-195">Ein *Wertparameter* wird zum Übergeben von Eingabeargumenten verwendet.</span><span class="sxs-lookup"><span data-stu-id="2a9be-195">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="2a9be-196">Ein Wertparameter entspricht einer lokalen Variablen, die ihren Anfangswert von dem Argument erhält, das für den Parameter übergeben wurde.</span><span class="sxs-lookup"><span data-stu-id="2a9be-196">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="2a9be-197">Änderungen an einem Wertparameter wirken sich nicht auf das Argument aus, das für den Parameter übergeben wurde.</span><span class="sxs-lookup"><span data-stu-id="2a9be-197">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="2a9be-198">Wertparameter können optional sein, indem ein Standardwert festgelegt wird, damit die zugehörigen Argumente weggelassen werden können.</span><span class="sxs-lookup"><span data-stu-id="2a9be-198">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="2a9be-199">Ein *Verweisparameter* wird zum Übergeben von Argumenten als Verweis verwendet.</span><span class="sxs-lookup"><span data-stu-id="2a9be-199">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="2a9be-200">Das für einen Verweisparameter übergebene Argument muss eine Variable mit eindeutigem Wert sein, und während der Ausführung der Methode repräsentiert der Verweisparameter denselben Speicherort wie die Argumentvariable.</span><span class="sxs-lookup"><span data-stu-id="2a9be-200">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="2a9be-201">Ein Verweisparameter wird mit dem `ref`-Modifizierer deklariert.</span><span class="sxs-lookup"><span data-stu-id="2a9be-201">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="2a9be-202">Das folgende Beispiel veranschaulicht die Verwendung des `ref`-Parameters.</span><span class="sxs-lookup"><span data-stu-id="2a9be-202">The following example shows the use of `ref` parameters.</span></span>

[!code-csharp[swapExample](~/samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]

<span data-ttu-id="2a9be-203">Ein *Ausgabeparameter* wird zum Übergeben von Argumenten als Verweis verwendet.</span><span class="sxs-lookup"><span data-stu-id="2a9be-203">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="2a9be-204">Er ist einem Verweisparameter ähnlich, außer dass er nicht erfordert, dass Sie explizit dem vom Aufrufer bereitgestellten Argument einen Wert zuweisen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-204">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="2a9be-205">Ein Ausgabeparameter wird mit dem `out`-Modifizierer deklariert.</span><span class="sxs-lookup"><span data-stu-id="2a9be-205">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="2a9be-206">Das folgende Beispiel zeigt die Verwendung von `out`-Parametern mithilfe der in C# 7 eingeführten Syntax.</span><span class="sxs-lookup"><span data-stu-id="2a9be-206">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

[!code-csharp[OutExample](~/samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]

<span data-ttu-id="2a9be-207">Ein *Parameterarray* ermöglicht es, eine variable Anzahl von Argumenten an eine Methode zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="2a9be-207">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="2a9be-208">Ein Parameterarray wird mit dem `params`-Modifizierer deklariert.</span><span class="sxs-lookup"><span data-stu-id="2a9be-208">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="2a9be-209">Nur der letzte Parameter einer Methode kann ein Parameterarray sein, und es muss sich um ein eindimensionales Parameterarray handeln.</span><span class="sxs-lookup"><span data-stu-id="2a9be-209">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="2a9be-210">Die Write- und WriteLine-Methoden der <xref:System.Console?displayProperty=nameWithType>-Klasse sind gute Beispiele für die Verwendung eines Parameterarrays.</span><span class="sxs-lookup"><span data-stu-id="2a9be-210">The Write and WriteLine methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="2a9be-211">Sie werden folgendermaßen deklariert.</span><span class="sxs-lookup"><span data-stu-id="2a9be-211">They're declared as follows.</span></span>

[!code-csharp[ConsoleExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]

<span data-ttu-id="2a9be-212">Innerhalb einer Methode mit einem Parameterarray verhält sich das Parameterarray wie ein regulärer Parameter des Arraytyps.</span><span class="sxs-lookup"><span data-stu-id="2a9be-212">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="2a9be-213">Beim Aufruf einer Methode mit einem Parameterarray ist es jedoch möglich, entweder ein einzelnes Argument des Parameterarraytyps oder eine beliebige Anzahl von Argumenten des Elementtyps des Parameterarrays zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="2a9be-213">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="2a9be-214">Im letzteren Fall wird automatisch eine Arrayinstanz erstellt und mit den vorgegebenen Argumenten initialisiert.</span><span class="sxs-lookup"><span data-stu-id="2a9be-214">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="2a9be-215">Dieses Beispiel:</span><span class="sxs-lookup"><span data-stu-id="2a9be-215">This example</span></span>

[!code-csharp[StringFormat](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]

<span data-ttu-id="2a9be-216">...entspricht dem folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="2a9be-216">is equivalent to writing the following.</span></span>

[!code-csharp[StringFormat2](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]

### <a name="method-body-and-local-variables"></a><span data-ttu-id="2a9be-217">Methodenkörper und lokale Variablen</span><span class="sxs-lookup"><span data-stu-id="2a9be-217">Method body and local variables</span></span>

<span data-ttu-id="2a9be-218">Der Methodenkörper gibt die Anweisungen an, die beim Aufruf der Methode ausgeführt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-218">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="2a9be-219">Ein Methodenkörper kann Variablen deklarieren, die für den Aufruf der Methode spezifisch sind.</span><span class="sxs-lookup"><span data-stu-id="2a9be-219">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="2a9be-220">Diese Variable werden *lokale Variablen* genannt.</span><span class="sxs-lookup"><span data-stu-id="2a9be-220">Such variables are called *local variables*.</span></span> <span data-ttu-id="2a9be-221">Die Deklaration einer lokalen Variable gibt einen Typnamen, einen Variablennamen und eventuell einen Anfangswert an.</span><span class="sxs-lookup"><span data-stu-id="2a9be-221">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="2a9be-222">Im folgenden Beispiel wird eine lokale Variable `i` mit einem Anfangswert von 0 und einer lokalen Variablen `j` ohne Anfangswert deklariert.</span><span class="sxs-lookup"><span data-stu-id="2a9be-222">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

[!code-csharp[Squares](~/samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]

<span data-ttu-id="2a9be-223">In C# muss eine lokale Variable *definitiv zugewiesen* sein, bevor ihr Wert abgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="2a9be-223">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="2a9be-224">Wenn beispielsweise die vorherige Deklaration von `i` keinen Anfangswert enthielte, würde der Compiler bei der nachfolgenden Verwendung von `i` einen Fehler melden, weil `i` zu diesen Zeitpunkten im Programm nicht definitiv zugewiesen wäre.</span><span class="sxs-lookup"><span data-stu-id="2a9be-224">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="2a9be-225">Eine Methode kann `return`-Anweisungen verwenden, um die Steuerung an den zugehörigen Aufrufer zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="2a9be-225">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="2a9be-226">In einer Methode, die `void` zurückgibt, können `return`-Anweisungen keinen Ausdruck angeben.</span><span class="sxs-lookup"><span data-stu-id="2a9be-226">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="2a9be-227">In einer Methode, die nicht „void“ zurückgibt, müssen`return`-Anweisungen einen Ausdruck enthalten, der den Rückgabewert berechnet.</span><span class="sxs-lookup"><span data-stu-id="2a9be-227">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="2a9be-228">Statische Methoden und Instanzmethoden</span><span class="sxs-lookup"><span data-stu-id="2a9be-228">Static and instance methods</span></span>

<span data-ttu-id="2a9be-229">Eine mit einem statischen Modifizierer deklarierte Methode ist eine *statische Methode*.</span><span class="sxs-lookup"><span data-stu-id="2a9be-229">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="2a9be-230">Eine statische Methode führt keine Vorgänge für eine spezifische Instanz aus und kann nur direkt auf statische Member zugreifen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-230">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="2a9be-231">Eine ohne einen statischen Modifizierer deklarierte Methode ist eine *Instanzmethode*.</span><span class="sxs-lookup"><span data-stu-id="2a9be-231">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="2a9be-232">Eine Instanzmethode führt Vorgänge für eine spezifische Instanz aus und kann sowohl auf statische Member als auch auf Instanzmember zugreifen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-232">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="2a9be-233">Auf die Instanz, für die eine Instanzmethode aufgerufen wurde, kann explizit als `this` zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-233">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="2a9be-234">Es ist ein Fehler, in einer statischen Methode auf `this` zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-234">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="2a9be-235">Die folgende `Entity`-Klasse umfasst sowohl statische Member als auch Instanzmember.</span><span class="sxs-lookup"><span data-stu-id="2a9be-235">The following `Entity` class has both static and instance members.</span></span>

[!code-csharp[Entity](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]

<span data-ttu-id="2a9be-236">Jede `Entity`-Instanz enthält eine Seriennummer (und vermutlich weitere Informationen, die hier nicht angezeigt werden).</span><span class="sxs-lookup"><span data-stu-id="2a9be-236">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="2a9be-237">Der `Entity`-Konstruktor (der einer Instanzmethode ähnelt) initialisiert die neue Instanz mit der nächsten verfügbaren Seriennummer.</span><span class="sxs-lookup"><span data-stu-id="2a9be-237">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="2a9be-238">Da der Konstruktor ein Instanzmember ist, kann er sowohl auf das `serialNo`-Instanzfeld als auch auf das statische `nextSerialNo`-Feld zugreifen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-238">Because the constructor is an instance member, it's permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="2a9be-239">Die statischen Methoden `GetNextSerialNo` und `SetNextSerialNo` können auf das statische Feld `nextSerialNo` zugreifen, aber es wäre ein Fehler, über diese Methoden direkt auf das Instanzfeld `serialNo` zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-239">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="2a9be-240">Das folgende Beispiel zeigt die Verwendung der Entity-Klasse.</span><span class="sxs-lookup"><span data-stu-id="2a9be-240">The following example shows the use of the Entity class.</span></span>

[!code-csharp[EntityExample](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]

<span data-ttu-id="2a9be-241">Die statischen Methoden `SetNextSerialNo` und `GetNextSerialNo` werden für die Klasse aufgerufen, während die `GetSerialNo`-Instanzmethode für Instanzen der Klasse aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="2a9be-241">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="2a9be-242">Virtuelle, überschriebene und abstrakte Methoden</span><span class="sxs-lookup"><span data-stu-id="2a9be-242">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="2a9be-243">Wenn die Deklaration einer Instanzmethode einen `virtual`-Modifizierer enthält, wird die Methode als *virtuelle Methode* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="2a9be-243">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="2a9be-244">Ist kein virtual-Modifizierer vorhanden, spricht man von einer *nicht virtuellen Methode*.</span><span class="sxs-lookup"><span data-stu-id="2a9be-244">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="2a9be-245">Beim Aufruf einer virtuellen Methode bestimmt der *Laufzeittyp* der Instanz, für die der Aufruf erfolgt, die tatsächlich aufzurufende Methodenimplementierung.</span><span class="sxs-lookup"><span data-stu-id="2a9be-245">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="2a9be-246">Beim Aufruf einer nicht virtuellen Methode ist der *Kompilierzeittyp* der bestimmende Faktor.</span><span class="sxs-lookup"><span data-stu-id="2a9be-246">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="2a9be-247">Eine virtuelle Methode kann in einer abgeleiteten Klasse *überschrieben* werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-247">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="2a9be-248">Wenn eine Instanzmethodendeklaration einen override-Modifizierer enthält, überschreibt die Methode eine geerbte virtuelle Methode mit derselben Signatur.</span><span class="sxs-lookup"><span data-stu-id="2a9be-248">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="2a9be-249">Während eine Deklaration einer virtuellen Methode eine neue Methode einführt, spezialisiert eine Deklaration einer überschriebenen Methode eine vorhandene geerbte virtuelle Methode, indem eine neue Implementierung dieser Methode bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="2a9be-249">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="2a9be-250">Eine *abstrakte Methode* ist eine virtuelle Methode ohne Implementierung.</span><span class="sxs-lookup"><span data-stu-id="2a9be-250">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="2a9be-251">Eine abstrakte Methode wird mit dem abstract-Modifizierer deklariert und ist nur in einer Klasse erlaubt, die auch als abstrakt deklariert wurde.</span><span class="sxs-lookup"><span data-stu-id="2a9be-251">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="2a9be-252">Eine abstrakte Methode muss in jeder nicht abstrakten abgeleiteten Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-252">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="2a9be-253">Im folgenden Beispiel wird die abstrakte Klasse `Expression` deklariert, die einen Ausdrucksbaumstrukturknoten sowie drei abgeleitete Klassen repräsentiert: `Constant`, `VariableReference` und `Operation`. Diese implementieren Ausdrucksbaumstrukturknoten für Konstanten, variable Verweise und arithmetische Operationen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-253">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="2a9be-254">(Dieses Beispiel ähnelt den Ausdrucksbaumstrukturtypen, sollte aber mit diesen nicht verwechselt werden.)</span><span class="sxs-lookup"><span data-stu-id="2a9be-254">(This example is similar to, but not to be confused with the expression tree types).</span></span>

[!code-csharp[ExpressionClass](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]

<span data-ttu-id="2a9be-255">Die vorherigen vier Klassen können zum Modellieren arithmetischer Ausdrücke verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-255">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="2a9be-256">Beispielsweise kann mithilfe von Instanzen dieser Klassen der Ausdruck `x + 3` folgendermaßen dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-256">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

[!code-csharp[ExpressionExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]

<span data-ttu-id="2a9be-257">Die `Evaluate`-Methode einer `Expression`-Instanz wird aufgerufen, um den vorgegebenen Ausdruck auszuwerten und einen `double`-Wert zu generieren.</span><span class="sxs-lookup"><span data-stu-id="2a9be-257">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="2a9be-258">Die Methode verwendet ein `Dictionary`-Argument, das Variablennamen (als Schlüssel der Einträge) und Werte (als Werte der Einträge) enthält.</span><span class="sxs-lookup"><span data-stu-id="2a9be-258">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="2a9be-259">Da `Evaluate` eine abstrakte Methode ist, müssen nicht-abstrakte Klassen, die von `Expression` abgeleitet sind, `Evaluate` außer Kraft setzen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-259">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="2a9be-260">Eine Implementierung von `Constant` für `Evaluate` gibt lediglich die gespeicherte Konstante zurück.</span><span class="sxs-lookup"><span data-stu-id="2a9be-260">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="2a9be-261">Eine Implementierung von `VariableReference` sucht im Wörterbuch nach dem Variablennamen und gibt den Ergebniswert zurück.</span><span class="sxs-lookup"><span data-stu-id="2a9be-261">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="2a9be-262">Eine Implementierung von `Operation` wertet zunächst (durch einen rekursiven Aufruf der zugehörigen `Evaluate`-Methoden) den linken und rechten Operanden aus und führt dann die vorgegebene arithmetische Operation aus.</span><span class="sxs-lookup"><span data-stu-id="2a9be-262">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="2a9be-263">Das folgende Programm verwendet die `Expression`-Klassen zum Auswerten des Ausdrucks `x * (y + 2)` für verschiedene Werte von `x` und `y`.</span><span class="sxs-lookup"><span data-stu-id="2a9be-263">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

[!code-csharp[ExpressionUsage](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]

### <a name="method-overloading"></a><span data-ttu-id="2a9be-264">Methodenüberladung</span><span class="sxs-lookup"><span data-stu-id="2a9be-264">Method overloading</span></span>

<span data-ttu-id="2a9be-265">Das *Überladen* von Methoden macht es möglich, dass mehrere Methoden in derselben Klasse denselben Namen verwenden, solange sie eindeutige Signaturen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-265">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="2a9be-266">Beim Kompilieren des Aufrufs einer überladenen Methode verwendet der Compiler die *Überladungsauflösung*, um die spezifische Methode zu ermitteln, die aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="2a9be-266">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="2a9be-267">Mithilfe der Überladungsauflösung wird die Methode ermittelt, die den Argumenten am besten entspricht, bzw. es wird ein Fehler ausgegeben, wenn keine passende Methode gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="2a9be-267">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="2a9be-268">Das folgende Beispiel zeigt die Verwendung der Überladungsauflösung.</span><span class="sxs-lookup"><span data-stu-id="2a9be-268">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="2a9be-269">Der Kommentar für jeden Aufruf in der `UsageExample`-Methode zeigt, welche Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="2a9be-269">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

[!code-csharp[OverloadUsage](~/samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]

<span data-ttu-id="2a9be-270">Wie im Beispiel gezeigt, kann eine bestimmte Methode immer ausgewählt werden, indem die Argumente explizit in die passenden Parametertypen konvertiert und/oder explizit Typargumente angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-270">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="2a9be-271">Andere Funktionsmember</span><span class="sxs-lookup"><span data-stu-id="2a9be-271">Other function members</span></span>

<span data-ttu-id="2a9be-272">Member, die ausführbaren Code enthalten, werden als *Funktionsmember* einer Klasse bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="2a9be-272">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="2a9be-273">Im vorherigen Abschnitt wurden Methoden beschrieben, die die Haupttypen von Funktionsmembern sind.</span><span class="sxs-lookup"><span data-stu-id="2a9be-273">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="2a9be-274">In diesem Abschnitt werden die weiteren Funktionsmember behandelt, die C# unterstützt: Konstruktoren, Eigenschaften, Indexer, Ereignisse, Operatoren und Finalizer.</span><span class="sxs-lookup"><span data-stu-id="2a9be-274">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="2a9be-275">Im folgenden Beispiel wird eine generische Klasse namens `MyList<T>` gezeigt, die eine wachsende Liste von Objekten implementiert.</span><span class="sxs-lookup"><span data-stu-id="2a9be-275">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="2a9be-276">Die Klasse enthält verschiedene Beispiele der gängigsten Arten von Funktionsmembern.</span><span class="sxs-lookup"><span data-stu-id="2a9be-276">The class contains several examples of the most common kinds of function members.</span></span>

> [!NOTE]
> <span data-ttu-id="2a9be-277">In diesem Beispiel wird eine `MyList`-Klasse erstellt, die nicht identisch ist mit der .NET-Standardklasse <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2a9be-277">This example creates a `MyList` class, which is not the same as the .NET standard <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2a9be-278">Sie veranschaulicht die für diesen Überblick erforderlichen Konzepte, ist aber kein Ersatz für diese Klasse.</span><span class="sxs-lookup"><span data-stu-id="2a9be-278">It does illustrate the concepts needed for this tour, but is not a replacement for that class.</span></span>

[!code-csharp[ListClass](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]

### <a name="constructors"></a><span data-ttu-id="2a9be-279">Konstruktoren</span><span class="sxs-lookup"><span data-stu-id="2a9be-279">Constructors</span></span>

<span data-ttu-id="2a9be-280">C# unterstützt sowohl Instanzkonstruktoren als auch statische Konstruktoren.</span><span class="sxs-lookup"><span data-stu-id="2a9be-280">C# supports both instance and static constructors.</span></span> <span data-ttu-id="2a9be-281">Ein *Instanzkonstruktor* ist ein Member, der die erforderlichen Aktionen zum Initialisieren einer Instanz einer Klasse implementiert.</span><span class="sxs-lookup"><span data-stu-id="2a9be-281">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="2a9be-282">Ein *statischer Konstruktor* ist ein Member, der die zum Initialisieren einer Klasse erforderlichen Aktionen implementiert, um die Klasse beim ersten Laden selbst zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="2a9be-282">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="2a9be-283">Ein Konstruktor wird wie eine Methode ohne Rückgabetyp und mit demselben Namen wie die enthaltende Klasse deklariert.</span><span class="sxs-lookup"><span data-stu-id="2a9be-283">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="2a9be-284">Wenn eine Konstruktordeklaration einen static-Modifizierer enthält, deklariert sie einen statischen Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="2a9be-284">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="2a9be-285">Andernfalls wird ein Instanzkonstruktor deklariert.</span><span class="sxs-lookup"><span data-stu-id="2a9be-285">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="2a9be-286">Instanzkonstruktoren können überladen werden und optionale Parameter verwenden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-286">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="2a9be-287">Die `MyList<T>`-Klasse deklariert z.B. einen Instanzkonstruktor mit einem einzelnen optionalen `int`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="2a9be-287">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="2a9be-288">Instanzkonstruktoren werden über den `new`-Operator aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-288">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="2a9be-289">Die folgenden Anweisungen weisen zwei Instanzen von `MyList<string>` unter Verwendung des Konstruktors der `MyList`-Klasse zu, mit dem optionalen Argument und ohne das optionale Argument.</span><span class="sxs-lookup"><span data-stu-id="2a9be-289">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

[!code-csharp[ListExample1](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]

<span data-ttu-id="2a9be-290">Im Gegensatz zu anderen Members werden Instanzkonstruktoren nicht geerbt, und eine Klasse verfügt über keine anderen Instanzkonstruktoren auf als diejenigen, die tatsächlich in der Klasse deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-290">Unlike other members, instance constructors aren't inherited, and a class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="2a9be-291">Wenn kein Instanzkonstruktor für eine Klasse angegeben ist, wird automatisch ein leerer Instanzkonstruktor ohne Parameter bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="2a9be-291">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="2a9be-292">Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="2a9be-292">Properties</span></span>

<span data-ttu-id="2a9be-293">*Eigenschaften* sind eine natürliche Erweiterung der Felder.</span><span class="sxs-lookup"><span data-stu-id="2a9be-293">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="2a9be-294">Beide sind benannte Member mit zugeordneten Typen, und für den Zugriff auf Felder und Eigenschaften wird dieselbe Syntax verwendet.</span><span class="sxs-lookup"><span data-stu-id="2a9be-294">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="2a9be-295">Im Gegensatz zu Feldern geben Eigenschaften jedoch keine Speicherorte an.</span><span class="sxs-lookup"><span data-stu-id="2a9be-295">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="2a9be-296">Stattdessen verfügen Eigenschaften über *Accessors* zum Angeben der Anweisungen, die beim Lesen oder Schreiben ihrer Werte ausgeführt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-296">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="2a9be-297">Eine Eigenschaft wird wie ein Feld deklariert, abgesehen davon, dass die Deklaration nicht auf ein Semikolon, sondern auf einen get- und/oder einen set-Accessor endet, der von den Trennzeichen `{` und `}` umschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="2a9be-297">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="2a9be-298">Eine Eigenschaft, die sowohl einen get- als auch einen set-Accessor aufweist, ist eine *Eigenschaft mit Lese- und Schreibzugriff*. Eine Eigenschaft, die nur einen get-Accessor aufweist, ist *schreibgeschützt*, eine Eigenschaft, die nur einen set-Accessor aufweist, ist *lesegeschützt*.</span><span class="sxs-lookup"><span data-stu-id="2a9be-298">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="2a9be-299">Ein get-Accessor entspricht einer Methode ohne Parameter mit einem Rückgabewert des Eigenschaftstyps.</span><span class="sxs-lookup"><span data-stu-id="2a9be-299">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="2a9be-300">Wenn eine Eigenschaft kein Ziel einer Zuweisung ist, sondern in einem Ausdruck referenziert wird, wird der get-Accessor der Eigenschaft aufgerufen, um ihren Wert zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-300">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="2a9be-301">Ein set-Accessor entspricht einer Methode mit einem einzigen Parameter namens „value“ ohne Rückgabetyp.</span><span class="sxs-lookup"><span data-stu-id="2a9be-301">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="2a9be-302">Wenn auf eine Eigenschaft als Ziel einer Zuweisung der als Operand ++ oder -- verwiesen wird, erfolgt der Aufruf des set-Accessors mit einem Argument, das den neuen Wert bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="2a9be-302">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="2a9be-303">Die `MyList<T>`-Klasse deklariert die beiden Eigenschaften „`Count`“ und „`Capacity`“, von denen die eine schreibgeschützt ist und die andere Lese- und Schreibzugriff besitzt.</span><span class="sxs-lookup"><span data-stu-id="2a9be-303">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="2a9be-304">Im folgenden Beispielcode wird die Verwendung dieser Eigenschaften veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="2a9be-304">The following code is an example of use of these properties:</span></span>

[!code-csharp[ListExample2](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]

<span data-ttu-id="2a9be-305">Ähnlich wie bei Feldern und Methoden unterstützt C# sowohl Instanzeigenschaften als auch statische Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2a9be-305">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="2a9be-306">Statische Eigenschaften werden mit dem static-Modifizierer, Instanzeigenschaften werden ohne static-Modifizierer deklariert.</span><span class="sxs-lookup"><span data-stu-id="2a9be-306">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="2a9be-307">Die Accessors einer Eigenschaft können virtuell sein.</span><span class="sxs-lookup"><span data-stu-id="2a9be-307">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="2a9be-308">Wenn eine Eigenschaftendeklaration einen `virtual`-, `abstract`- oder `override`-Modifizierer enthält, wird dieser auf den Accessor der Eigenschaft angewendet.</span><span class="sxs-lookup"><span data-stu-id="2a9be-308">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="2a9be-309">Indexer</span><span class="sxs-lookup"><span data-stu-id="2a9be-309">Indexers</span></span>

<span data-ttu-id="2a9be-310">Ein *Indexer* ist ein Member, mit dem Objekte wie ein Array indiziert werden können.</span><span class="sxs-lookup"><span data-stu-id="2a9be-310">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="2a9be-311">Ein Indexer wird wie eine Eigenschaft deklariert, abgesehen davon, dass der Name des Members `this` ist, gefolgt von einer Parameterliste, die zwischen die Trennzeichen `[` und `]` geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="2a9be-311">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="2a9be-312">Die Parameter stehen im Accessor des Indexers zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="2a9be-312">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="2a9be-313">Ähnlich wie Eigenschaften können Indexer Lese-/Schreibzugriff besitzen, schreibgeschützt und lesegeschützt sein und virtuelle Accessors verwenden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-313">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="2a9be-314">Die `MyList<T>`-Klasse deklariert einen einzigen Indexer mit Lese-/Schreibzugriff, der einen `int`-Parameter akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="2a9be-314">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="2a9be-315">Der Indexer ermöglicht es, Instanzen von `MyList<T>` mit `int`-Werten zu indizieren.</span><span class="sxs-lookup"><span data-stu-id="2a9be-315">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="2a9be-316">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="2a9be-316">For example:</span></span>

[!code-csharp[ListExample3](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]

<span data-ttu-id="2a9be-317">Indexer können überladen werden, d.h. eine Klasse kann mehrere Indexer deklarieren, solange sich die Anzahl oder Typen ihrer Parameter unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-317">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="2a9be-318">Ereignisse</span><span class="sxs-lookup"><span data-stu-id="2a9be-318">Events</span></span>

<span data-ttu-id="2a9be-319">Ein *Ereignis* ist ein Member, der es einer Klasse oder einem Objekt ermöglicht, Benachrichtigungen bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-319">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="2a9be-320">Ein Ereignis wird wie ein Feld deklariert, abgesehen davon, dass es ein event-Schlüsselwort enthält und einen Delegattyp aufweisen muss.</span><span class="sxs-lookup"><span data-stu-id="2a9be-320">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="2a9be-321">Innerhalb einer Klasse, die einen Ereignismember deklariert, verhält sich das Ereignis wie ein Feld des Delegattyps (vorausgesetzt, das Ereignis ist nicht abstrakt und deklariert keine Zugriffsmethoden).</span><span class="sxs-lookup"><span data-stu-id="2a9be-321">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="2a9be-322">Das Feld speichert einen Verweis auf einen Delegaten, der die Ereignishandler repräsentiert, die dem Ereignis hinzugefügt wurden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-322">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="2a9be-323">Wenn keine Ereignishandler vorhanden sind, ist das Feld `null`.</span><span class="sxs-lookup"><span data-stu-id="2a9be-323">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="2a9be-324">Die `MyList<T>`-Klasse deklariert einen einzigen Ereignismember namens `Changed`, der angibt, dass der Liste ein neues Element hinzugefügt wurde.</span><span class="sxs-lookup"><span data-stu-id="2a9be-324">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="2a9be-325">Das Changed-Ereignis wird durch die virtuelle Methode `OnChanged` ausgelöst, die zunächst prüft, ob das Ereignis `null` ist (d.h. nicht über Handler verfügt).</span><span class="sxs-lookup"><span data-stu-id="2a9be-325">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="2a9be-326">Das Auslösen eines Ereignisses entspricht exakt dem Aufrufen des Delegaten, der durch das Ereignis repräsentiert wird, es gibt deshalb keine besonderen Sprachkonstrukte zum Auslösen von Ereignissen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-326">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="2a9be-327">Clients reagieren über *Ereignishandler* auf Ereignisse.</span><span class="sxs-lookup"><span data-stu-id="2a9be-327">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="2a9be-328">Ereignishandler werden unter Verwendung des `+=`-Operators angefügt und mit dem `-=`-Operator entfernt.</span><span class="sxs-lookup"><span data-stu-id="2a9be-328">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="2a9be-329">Im folgenden Beispiel wird dem `Changed`-Ereignis von `MyList<string>` ein Ereignishandler hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="2a9be-329">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

[!code-csharp[EventExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]

<span data-ttu-id="2a9be-330">In fortgeschrittenen Szenarios, in denen die zugrunde liegende Speicherung eines Ereignisses gesteuert werden soll, kann eine Ereignisdeklaration explizit die Zugriffsmethoden `add` und `remove` bereitstellen, die der Zugriffsmethode `set` einer Eigenschaft ähneln.</span><span class="sxs-lookup"><span data-stu-id="2a9be-330">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="2a9be-331">Operatoren</span><span class="sxs-lookup"><span data-stu-id="2a9be-331">Operators</span></span>

<span data-ttu-id="2a9be-332">Ein *Operator* ist ein Member, der die Bedeutung der Anwendung eines bestimmten Ausdrucksoperators auf Instanzen einer Klasse definiert.</span><span class="sxs-lookup"><span data-stu-id="2a9be-332">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="2a9be-333">Es können drei Arten von Operatoren definiert werden: unäre Operatoren, binäre Operatoren und Konvertierungsoperatoren.</span><span class="sxs-lookup"><span data-stu-id="2a9be-333">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="2a9be-334">Alle Operatoren müssen als `public` und `static` deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-334">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="2a9be-335">Die `MyList<T>`-Klasse deklariert zwei Operatoren, `operator ==` und `operator !=`, und verleiht so Ausdrücken, die diese Operatoren auf `MyList`-Instanzen anwenden, eine neue Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="2a9be-335">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="2a9be-336">Insbesondere die Operatoren definieren die Gleichheit für zwei Instanzen von `MyList<T>`, indem alle enthaltenen Objekte mithilfe ihrer Equals-Methoden verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-336">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="2a9be-337">Im folgenden Beispiel wird der `==`-Operator verwendet, um zwei Instanzen von `MyList<int>` zu vergleichen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-337">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

[!code-csharp[OperatorExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]

<span data-ttu-id="2a9be-338">Die erste Methode `Console.WriteLine` gibt `True` aus, weil die zwei Listen dieselbe Anzahl von Objekten mit denselben Werten in derselben Reihenfolge enthalten.</span><span class="sxs-lookup"><span data-stu-id="2a9be-338">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="2a9be-339">Wenn `MyList<T>` nicht `operator ==` definieren würde, würde die Ausgabe der ersten `Console.WriteLine`-Methode `False` lauten, weil `a` und `b` auf unterschiedliche `MyList<int>`-Instanzen verweisen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-339">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="2a9be-340">Finalizer</span><span class="sxs-lookup"><span data-stu-id="2a9be-340">Finalizers</span></span>

<span data-ttu-id="2a9be-341">Ein *Finalizer* ist ein Member, der die erforderlichen Aktionen zum Bereinigen einer Instanz einer Klasse implementiert.</span><span class="sxs-lookup"><span data-stu-id="2a9be-341">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="2a9be-342">Finalizer können weder Parameter noch Zugriffsmodifizierer aufweisen und können nicht explizit aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-342">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="2a9be-343">Der Finalizer für eine Instanz wird bei der Garbagecollection automatisch aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="2a9be-343">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="2a9be-344">Der Garbage Collector kann weitestgehend selbst über den Zeitpunkt der Objektbereinigung und die Ausführung der Finalizer entscheiden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-344">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="2a9be-345">Insbesondere der Zeitpunkt für den Aufruf der Finalizer ist nicht festgelegt, und Finalizer können für beliebige Threads ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="2a9be-345">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="2a9be-346">Aus diesen und weiteren Gründen sollten Klassen Finalizer nur dann implementieren, wenn keine andere Lösung möglich ist.</span><span class="sxs-lookup"><span data-stu-id="2a9be-346">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="2a9be-347">Die `using`-Anweisung bietet einen besseren Ansatz für die Objektzerstörung.</span><span class="sxs-lookup"><span data-stu-id="2a9be-347">The `using` statement provides a better approach to object destruction.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="2a9be-348">[Zurück](statements.md)
> [Weiter](arrays.md)</span><span class="sxs-lookup"><span data-stu-id="2a9be-348">[Previous](statements.md)
[Next](arrays.md)</span></span>
