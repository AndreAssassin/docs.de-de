---
title: Grundlagen zu Abfrageausdrücken (LINQ in C#)
description: Führt Konzepte im Zusammenhang mit Abfrageausdrücken ein
ms.date: 11/30/2016
ms.assetid: 027db1f8-346f-44d2-a16e-043fcea3a4e0
ms.openlocfilehash: 83beaa82d4b4b42ff9da5230edddd391b33a0717
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/14/2020
ms.locfileid: "79173353"
---
# <a name="query-expression-basics"></a><span data-ttu-id="cdd2a-103">Grundlagen zu Abfrageausdrücken</span><span class="sxs-lookup"><span data-stu-id="cdd2a-103">Query expression basics</span></span>

<span data-ttu-id="cdd2a-104">In diesem Artikel werden die grundlegenden Konzepte für Abfrageausdrücke in C# vorgestellt.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-104">This article introduces the basic concepts related to query expressions in C#.</span></span>

## <a name="what-is-a-query-and-what-does-it-do"></a><span data-ttu-id="cdd2a-105">Was ist eine Abfrage, und welche Funktion hat sie?</span><span class="sxs-lookup"><span data-stu-id="cdd2a-105">What is a query and what does it do?</span></span>

<span data-ttu-id="cdd2a-106">Eine *Abfrage* ist ein Satz von Anweisungen, der beschreibt, welche Daten aus einer bestimmten Datenquelle (oder Quellen) abgerufen werden sollen, und welche Form und Organisation die zurückgegebenen Daten haben sollen.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-106">A *query* is a set of instructions that describes what data to retrieve from a given data source (or sources) and what shape and organization the returned data should have.</span></span> <span data-ttu-id="cdd2a-107">Eine Abfrage unterscheidet sich von den Ergebnissen, die sie erzeugt.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-107">A query is distinct from the results that it produces.</span></span>

<span data-ttu-id="cdd2a-108">Im Allgemeinen werden die Quelldaten logisch als Sequenz von Elementen der gleichen Art organisiert.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-108">Generally, the source data is organized logically as a sequence of elements of the same kind.</span></span> <span data-ttu-id="cdd2a-109">Eine SQL-Datenbanktabelle enthält z.B. eine Sequenz von Zeilen.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-109">For example, a SQL database table contains a sequence of rows.</span></span> <span data-ttu-id="cdd2a-110">In einer XML-Datei gibt es eine „Sequenz“ von XML-Elementen (auch wenn diese hierarchisch in einer Baumstruktur organisiert sind).</span><span class="sxs-lookup"><span data-stu-id="cdd2a-110">In an XML file, there is a "sequence" of XML elements (although these are organized hierarchically in a tree structure).</span></span> <span data-ttu-id="cdd2a-111">Eine Auflistung im Arbeitsspeicher enthält eine Sequenz von Objekten.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-111">An in-memory collection contains a sequence of objects.</span></span>

<span data-ttu-id="cdd2a-112">Aus Sicht einer Anwendung ist der spezifische Typ und die Struktur der ursprünglichen Datenquelle nicht wichtig.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-112">From an application's viewpoint, the specific type and structure of the original source data is not important.</span></span> <span data-ttu-id="cdd2a-113">Die Anwendung sieht die Quelldaten immer als eine <xref:System.Collections.Generic.IEnumerable%601>- oder <xref:System.Linq.IQueryable%601>-Auflistung an.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-113">The application always sees the source data as an <xref:System.Collections.Generic.IEnumerable%601> or <xref:System.Linq.IQueryable%601> collection.</span></span> <span data-ttu-id="cdd2a-114">In LINQ to XML werden die Quelldaten z.B. als ein `IEnumerable`\<<xref:System.Xml.Linq.XElement> sichtbar gemacht.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-114">For example, in LINQ to XML, the source data is made visible as an `IEnumerable`\<<xref:System.Xml.Linq.XElement>>.</span></span>

<span data-ttu-id="cdd2a-115">Wenn diese Quellsequenz vorliegt, kann eine Abfrage eine der folgenden drei Aktionen durchführen:</span><span class="sxs-lookup"><span data-stu-id="cdd2a-115">Given this source sequence, a query may do one of three things:</span></span>

- <span data-ttu-id="cdd2a-116">Abrufen einer Teilmenge der Elemente zum Erstellen einer neuen Sequenz ohne die einzelnen Elemente zu verändern.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-116">Retrieve a subset of the elements to produce a new sequence without modifying the individual elements.</span></span> <span data-ttu-id="cdd2a-117">Die Abfrage kann die zurückgegebenen Sequenzen dann auf verschiedene Arten sortieren oder gruppieren, wie im folgenden Beispiel gezeigt wird (Annahme: `scores` ist `int[]`):</span><span class="sxs-lookup"><span data-stu-id="cdd2a-117">The query may then sort or group the returned sequence in various ways, as shown in the following example (assume `scores` is an `int[]`):</span></span>

    [!code-csharp[csrefQueryExpBasics#45](~/samples/snippets/csharp/concepts/linq/query-expression-basics_1.cs)]

- <span data-ttu-id="cdd2a-118">Abrufen einer Sequenz von Elementen wie im vorherigen Beispiel, aber mit Transformation der Elemente in einen neuen Objekttyp.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-118">Retrieve a sequence of elements as in the previous example but transform them to a new type of object.</span></span> <span data-ttu-id="cdd2a-119">Eine Abfrage kann z.B. nur die Nachnamen aus bestimmten Kundendatensätzen in einer Datenquelle abrufen.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-119">For example, a query may retrieve only the last names from certain customer records in a data source.</span></span> <span data-ttu-id="cdd2a-120">Sie kann möglicherweise auch den vollständigen Datensatz abrufen und ihn zum Erstellen eines anderen Objekttyps im Arbeitsspeicher oder sogar XML-Daten vor dem Generieren der endgültigen Ergebnissequenz verwenden.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-120">Or it may retrieve the complete record and then use it to construct another in-memory object type or even XML data before generating the final result sequence.</span></span> <span data-ttu-id="cdd2a-121">Im folgenden Beispiel wird eine Projektion von `int` in `string` veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-121">The following example shows a projection from an `int` to a `string`.</span></span> <span data-ttu-id="cdd2a-122">Beachten Sie den neuen Typ von `highScoresQuery`.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-122">Note the new type of `highScoresQuery`.</span></span>

    [!code-csharp[csrefQueryExpBasics#46](~/samples/snippets/csharp/concepts/linq/query-expression-basics_2.cs)]

- <span data-ttu-id="cdd2a-123">Abrufen eines Singleton-Werts zu den Quelldaten, z.B.:</span><span class="sxs-lookup"><span data-stu-id="cdd2a-123">Retrieve a singleton value about the source data, such as:</span></span>

  - <span data-ttu-id="cdd2a-124">Die Anzahl der Elemente, die eine bestimmte Bedingung erfüllen</span><span class="sxs-lookup"><span data-stu-id="cdd2a-124">The number of elements that match a certain condition.</span></span>

  - <span data-ttu-id="cdd2a-125">Das Element, das den größten oder den niedrigsten Wert hat</span><span class="sxs-lookup"><span data-stu-id="cdd2a-125">The element that has the greatest or least value.</span></span>

  - <span data-ttu-id="cdd2a-126">Das erste Element, das einer Bedingung entspricht oder die Summe bestimmter Werte in einer angegebenen Menge von Elementen</span><span class="sxs-lookup"><span data-stu-id="cdd2a-126">The first element that matches a condition, or the sum of particular values in a specified set of elements.</span></span> <span data-ttu-id="cdd2a-127">Die folgende Abfrage gibt z.B. die Anzahl von Ergebnissen aus dem `scores`-Ganzzahlarray zurück, die höher als 80 sind:</span><span class="sxs-lookup"><span data-stu-id="cdd2a-127">For example, the following query returns the number of scores greater than 80 from the `scores` integer array:</span></span>

    [!code-csharp[csrefQueryExpBasics#47](~/samples/snippets/csharp/concepts/linq/query-expression-basics_3.cs)]

    <span data-ttu-id="cdd2a-128">Beachten Sie im vorherigen Beispiel die Verwendung von Klammern um den Abfrageausdruck vor dem Aufruf der `Count`-Methode.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-128">In the previous example, note the use of parentheses around the query expression before the call to the `Count` method.</span></span> <span data-ttu-id="cdd2a-129">Sie können dies auch mit einer neuen Variable ausdrücken, um das konkrete Ergebnis zu speichern.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-129">You can also express this by using a new variable to store the concrete result.</span></span> <span data-ttu-id="cdd2a-130">Diese Technik ist besser lesbar, da die Variablen, die die Abfrage speichern, von der Abfrage getrennt sind, die ein Ergebnis speichert.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-130">This technique is more readable because it keeps the variable that stores the query separate from the query that stores a result.</span></span>

    [!code-csharp[csrefQueryExpBasics#48](~/samples/snippets/csharp/concepts/linq/query-expression-basics_4.cs)]

<span data-ttu-id="cdd2a-131">Im vorherigen Beispiel wird die Abfrage im Aufruf von `Count` ausgeführt, da `Count` die Ergebnisse durchlaufen muss, um die Anzahl der von `highScoresQuery` zurückgegebenen Elemente zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-131">In the previous example, the query is executed in the call to `Count`, because `Count` must iterate over the results in order to determine the number of elements returned by `highScoresQuery`.</span></span>

## <a name="what-is-a-query-expression"></a><span data-ttu-id="cdd2a-132">Was ist ein Abfrageausdruck?</span><span class="sxs-lookup"><span data-stu-id="cdd2a-132">What is a query expression?</span></span>

<span data-ttu-id="cdd2a-133">Ein *Abfrageausdruck* ist eine in der Abfragesyntax ausgedrückte Abfrage.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-133">A *query expression* is a query expressed in query syntax.</span></span> <span data-ttu-id="cdd2a-134">Ein Abfrageausdruck ist ein erstklassiges Sprachkonstrukt.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-134">A query expression is a first-class language construct.</span></span> <span data-ttu-id="cdd2a-135">Er verhält sich wie jeder andere Ausdruck und kann in jedem Kontext verwendet werden, in dem ein C#-Ausdruck gültig ist.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-135">It is just like any other expression and can be used in any context in which a C# expression is valid.</span></span> <span data-ttu-id="cdd2a-136">Ein Abfrageausdruck besteht aus einem Satz von in einer deklarativen Syntax geschriebenen Klauseln, ähnlich wie SQL oder XQuery.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-136">A query expression consists of a set of clauses written in a declarative syntax similar to SQL or XQuery.</span></span> <span data-ttu-id="cdd2a-137">Jede Klausel umfasst wiederum einen oder mehrere C#-Ausdrücke. Diese Ausdrücke sind möglicherweise selbst Abfrageausdrücke oder enthalten einen Abfrageausdruck.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-137">Each clause in turn contains one or more C# expressions, and these expressions may themselves be either a query expression or contain a query expression.</span></span>

<span data-ttu-id="cdd2a-138">Ein Abfrageausdruck muss mit einer [from](../language-reference/keywords/from-clause.md)-Klausel beginnen und mit einer [select](../language-reference/keywords/select-clause.md)- oder [group](../language-reference/keywords/group-clause.md)-Klausel enden.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-138">A query expression must begin with a [from](../language-reference/keywords/from-clause.md) clause and must end with a [select](../language-reference/keywords/select-clause.md) or [group](../language-reference/keywords/group-clause.md) clause.</span></span> <span data-ttu-id="cdd2a-139">Zwischen der ersten `from`-Klausel und der letzten `select`- oder `group`-Klausel kann ein Abfrageausdruck eine oder mehrere der folgenden optionalen Klauseln enthalten: [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) und sogar zusätzliche [from](../language-reference/keywords/from-clause.md)-Klauseln.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-139">Between the first `from` clause and the last `select` or `group` clause, it can contain one or more of these optional clauses: [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) and even additional [from](../language-reference/keywords/from-clause.md) clauses.</span></span> <span data-ttu-id="cdd2a-140">Sie können auch das Schlüsselwort [into](../language-reference/keywords/into.md) verwenden, um zuzulassen, das das Ergebnis einer `join`- oder `group`-Klausel als Quelle für zusätzliche Abfrageklauseln im selben Abfrageausdruck dient.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-140">You can also use the [into](../language-reference/keywords/into.md) keyword to enable the result of a `join` or `group` clause to serve as the source for additional query clauses in the same query expression.</span></span>

### <a name="query-variable"></a><span data-ttu-id="cdd2a-141">Abfragevariable</span><span class="sxs-lookup"><span data-stu-id="cdd2a-141">Query variable</span></span>

<span data-ttu-id="cdd2a-142">In LINQ ist eine Abfragevariable eine beliebige Variable, die eine *Abfrage* anstatt des *Ergebnisses* einer Abfrage speichert.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-142">In LINQ, a query variable is any variable that stores a *query* instead of the *results* of a query.</span></span> <span data-ttu-id="cdd2a-143">Genauer gesagt ist eine Abfragevariable immer ein Enumerable-Typ, der eine Sequenz von Elementen erzeugt, wenn er in einer `foreach`-Anweisung oder einem direkten Aufruf der `IEnumerator.MoveNext`-Methode durchlaufen wird.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-143">More specifically, a query variable is always an enumerable type that will produce a sequence of elements when it is iterated over in a `foreach` statement or a direct call to its `IEnumerator.MoveNext` method.</span></span>

<span data-ttu-id="cdd2a-144">Das folgende Codebeispiel zeigt einen einfachen Abfrageausdruck mit einer Datenquelle, einer Filtering-Klausel, einer Ordering-Klausel und ohne Transformationen der Quellelemente.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-144">The following code example shows a simple query expression with one data source, one filtering clause, one ordering clause, and no transformation of the source elements.</span></span> <span data-ttu-id="cdd2a-145">Die Klausel `select` beendet die Abfrage.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-145">The `select` clause ends the query.</span></span>

[!code-csharp[csrefQueryExpBasics#49](~/samples/snippets/csharp/concepts/linq/query-expression-basics_5.cs)]

<span data-ttu-id="cdd2a-146">Im vorherigen Beispiel ist `scoreQuery` eine *Abfragevariable*, die manchmal auch einfach als *Abfrage* bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-146">In the previous example, `scoreQuery` is a *query variable,* which is sometimes referred to as just a *query*.</span></span> <span data-ttu-id="cdd2a-147">Die Abfragevariable speichert keine tatsächlichen Ergebnisdaten, die in der `foreach`-Schleife erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-147">The query variable stores no actual result data, which is produced in the `foreach` loop.</span></span> <span data-ttu-id="cdd2a-148">Wenn die `foreach`-Anweisung ausgeführt wird, werden die Ergebnisse der Abfrage nicht über die Abfragevariable `scoreQuery` zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-148">And when the `foreach` statement executes, the query results are not returned through the query variable `scoreQuery`.</span></span> <span data-ttu-id="cdd2a-149">Stattdessen werden sie über die Iterationsvariable `testScore` zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-149">Rather, they are returned through the iteration variable `testScore`.</span></span> <span data-ttu-id="cdd2a-150">Die `scoreQuery`-Variable kann in einer zweiten `foreach`-Schleife durchlaufen werden.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-150">The `scoreQuery` variable can be iterated in a second `foreach` loop.</span></span> <span data-ttu-id="cdd2a-151">Die gleichen Ergebnisse werden erzeugt, solange weder die Variable noch die Datenquelle geändert wurde.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-151">It will produce the same results as long as neither it nor the data source has been modified.</span></span>

<span data-ttu-id="cdd2a-152">Eine Abfragevariable kann eine Abfrage speichern, die in einer Abfragesyntax oder Methodensyntax oder einer Kombination aus beiden ausgedrückt wird.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-152">A query variable may store a query that is expressed in query syntax or method syntax, or a combination of the two.</span></span> <span data-ttu-id="cdd2a-153">In den folgenden Beispielen sind sowohl `queryMajorCities` als auch `queryMajorCities2` Abfragevariablen:</span><span class="sxs-lookup"><span data-stu-id="cdd2a-153">In the following examples, both `queryMajorCities` and `queryMajorCities2` are query variables:</span></span>

[!code-csharp[csrefQueryExpBasics#50](~/samples/snippets/csharp/concepts/linq/query-expression-basics_6.cs)]

<span data-ttu-id="cdd2a-154">Andererseits zeigen die beiden nächsten Beispiele Variablen, die keine Abfragevariablen sind, obwohl beide mit einer Abfrage initialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-154">On the other hand, the following two examples show variables that are not query variables even though each is initialized with a query.</span></span> <span data-ttu-id="cdd2a-155">Sie sind keine Abfragevariablen, da sie Ergebnisse speichern:</span><span class="sxs-lookup"><span data-stu-id="cdd2a-155">They are not query variables because they store results:</span></span>

[!code-csharp[csrefQueryExpBasics#51](~/samples/snippets/csharp/concepts/linq/query-expression-basics_7.cs)]

<span data-ttu-id="cdd2a-156">Weitere Informationen zu den verschiedenen Verfahren zum Ausdrücken von Abfragen finden Sie unter [Query syntax and method syntax in LINQ (Abfragesyntax und Methodensyntax in LINQ)](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span><span class="sxs-lookup"><span data-stu-id="cdd2a-156">For more information about the different ways to express queries, see [Query syntax and method syntax in LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span></span>

#### <a name="explicit-and-implicit-typing-of-query-variables"></a><span data-ttu-id="cdd2a-157">Explizite und implizite Typisierung von Abfragevariablen</span><span class="sxs-lookup"><span data-stu-id="cdd2a-157">Explicit and implicit typing of query variables</span></span>

<span data-ttu-id="cdd2a-158">Diese Dokumentation enthält normalerweise den expliziten Typ der Abfragevariablen, um die Typbeziehung zwischen der Abfrage und der [select-Klausel](../language-reference/keywords/select-clause.md) darzustellen.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-158">This documentation usually provides the explicit type of the query variable in order to show the type relationship between the query variable and the [select clause](../language-reference/keywords/select-clause.md).</span></span> <span data-ttu-id="cdd2a-159">Sie können aber auch das Schlüsselwort [var](../language-reference/keywords/var.md) verwenden, um den Compiler anzuweisen, den Typ einer Abfragevariable (oder eine andere lokale Variable) zur Kompilierzeit abzuleiten.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-159">However, you can also use the [var](../language-reference/keywords/var.md) keyword to instruct the compiler to infer the type of a query variable (or any other local variable) at compile time.</span></span> <span data-ttu-id="cdd2a-160">Das Beispiel einer Abfrage, das vorher in diesem Thema gezeigt wurde, kann beispielsweise auch durch implizierte Typisierung ausgedrückt werden:</span><span class="sxs-lookup"><span data-stu-id="cdd2a-160">For example, the query example that was shown previously in this topic can also be expressed by using implicit typing:</span></span>

[!code-csharp[csrefQueryExpBasics#52](~/samples/snippets/csharp/concepts/linq/query-expression-basics_8.cs)]

<span data-ttu-id="cdd2a-161">Weitere Informationen finden Sie unter [Implizit typisierte lokale Variablen](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) und [Type relationships in LINQ query operations (Typbeziehungen in LINQ-Abfragevorgängen)](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span><span class="sxs-lookup"><span data-stu-id="cdd2a-161">For more information, see [Implicitly typed local variables](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) and [Type relationships in LINQ query operations](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span></span>

### <a name="starting-a-query-expression"></a><span data-ttu-id="cdd2a-162">Starten eines Abfrageausdrucks</span><span class="sxs-lookup"><span data-stu-id="cdd2a-162">Starting a query expression</span></span>

<span data-ttu-id="cdd2a-163">Ein Abfrageausdruck muss mit einer `from`-Klausel beginnen.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-163">A query expression must begin with a `from` clause.</span></span> <span data-ttu-id="cdd2a-164">Er gibt eine Datenquelle zusammen mit einer Bereichsvariablen an.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-164">It specifies a data source together with a range variable.</span></span> <span data-ttu-id="cdd2a-165">Die Bereichsvariable stellt jedes darauffolgende Element in der Quellsequenz dar, wenn das Quellelement durchsucht wird.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-165">The range variable represents each successive element in the source sequence as the source sequence is being traversed.</span></span> <span data-ttu-id="cdd2a-166">Die Bereichsvariable ist, basierend auf den Typen des Elements in der Datenquelle, stark typisiert.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-166">The range variable is strongly typed based on the type of elements in the data source.</span></span> <span data-ttu-id="cdd2a-167">Im folgenden Beispiel ist die Bereichsvariable auch als `Country` typisiert, da `countries` ein Array von `Country`-Objekten ist.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-167">In the following example, because `countries` is an array of `Country` objects, the range variable is also typed as `Country`.</span></span> <span data-ttu-id="cdd2a-168">Da die Bereichsvariable stark typisiert ist, können Sie den Punktoperator verwenden, um auf verfügbare Member des Typs zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-168">Because the range variable is strongly typed, you can use the dot operator to access any available members of the type.</span></span>

[!code-csharp[csrefQueryExpBasics#53](~/samples/snippets/csharp/concepts/linq/query-expression-basics_9.cs)]

<span data-ttu-id="cdd2a-169">Die Bereichsvariable befindet sich im Geltungsbereich, bis die Abfrage entweder mit einem Semikolon oder einer *continuation*-Klausel beendet wird.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-169">The range variable is in scope until the query is exited either with a semicolon or with a *continuation* clause.</span></span>

<span data-ttu-id="cdd2a-170">Ein Abfrageausdruck enthält möglicherweise mehrere `from`-Klauseln.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-170">A query expression may contain multiple `from` clauses.</span></span> <span data-ttu-id="cdd2a-171">Verwenden Sie zusätzliche `from`-Klauseln, wenn jedes Element in der Quellsequenz selbst eine Auflistung ist oder eine Auflistung enthält.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-171">Use additional `from` clauses when each element in the source sequence is itself a collection or contains a collection.</span></span> <span data-ttu-id="cdd2a-172">Nehmen wir beispielsweise an, dass Sie über eine Auflistung von `Country`-Objekten verfügen, von der jedes eine Auflistung von `City`-Objekten mit dem Namen `Cities` enthält.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-172">For example, assume that you have a collection of `Country` objects, each of which contains a collection of `City` objects named `Cities`.</span></span> <span data-ttu-id="cdd2a-173">Verwenden Sie zwei `from`-Klauseln, um die `City`-Objekte in jedem `Country` abzufragen, wie hier gezeigt:</span><span class="sxs-lookup"><span data-stu-id="cdd2a-173">To query the `City` objects in each `Country`, use two `from` clauses as shown here:</span></span>

[!code-csharp[csrefQueryExpBasics#54](~/samples/snippets/csharp/concepts/linq/query-expression-basics_10.cs)]

<span data-ttu-id="cdd2a-174">Weitere Informationen finden Sie unter [from-Klausel](../language-reference/keywords/from-clause.md).</span><span class="sxs-lookup"><span data-stu-id="cdd2a-174">For more information, see [from clause](../language-reference/keywords/from-clause.md).</span></span>

### <a name="ending-a-query-expression"></a><span data-ttu-id="cdd2a-175">Beenden eines Abfrageausdrucks</span><span class="sxs-lookup"><span data-stu-id="cdd2a-175">Ending a query expression</span></span>

<span data-ttu-id="cdd2a-176">Ein Abfrageausdruck muss entweder mit einer `group`- oder einer `select`-Klausel enden.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-176">A query expression must end with either a `group` clause or a `select` clause.</span></span>

#### <a name="group-clause"></a><span data-ttu-id="cdd2a-177">group-Klausel</span><span class="sxs-lookup"><span data-stu-id="cdd2a-177">group clause</span></span>

<span data-ttu-id="cdd2a-178">Verwenden Sie die `group`-Klausel, um eine Sequenz von Gruppen zu erzeugen, die von einem von Ihnen angegebenen Schüssel organisiert wird.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-178">Use the `group` clause to produce a sequence of groups organized by a key that you specify.</span></span> <span data-ttu-id="cdd2a-179">Der Schlüssel kann ein beliebiger Datentyp sein.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-179">The key can be any data type.</span></span> <span data-ttu-id="cdd2a-180">Die folgende Abfrage erstellt z.B. eine Sequenz von Gruppen, die ein oder mehrere `Country`-Objekte enthält und deren Schlüssel ein `char`-Wert ist.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-180">For example, the following query creates a sequence of groups that contains one or more `Country` objects and whose key is a `char` value.</span></span>

[!code-csharp[csrefQueryExpBasics#55](~/samples/snippets/csharp/concepts/linq/query-expression-basics_11.cs)]

<span data-ttu-id="cdd2a-181">Weitere Informationen zum Gruppieren finden Sie unter [group-Klausel](../language-reference/keywords/group-clause.md).</span><span class="sxs-lookup"><span data-stu-id="cdd2a-181">For more information about grouping, see [group clause](../language-reference/keywords/group-clause.md).</span></span>

#### <a name="select-clause"></a><span data-ttu-id="cdd2a-182">select-Klausel</span><span class="sxs-lookup"><span data-stu-id="cdd2a-182">select clause</span></span>

<span data-ttu-id="cdd2a-183">Verwenden Sie die `select`-Klausel, um alle anderen Typen von Sequenzen zu erzeugen.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-183">Use the `select` clause to produce all other types of sequences.</span></span> <span data-ttu-id="cdd2a-184">Eine einfache `select`-Klausel erzeugt nur eine Sequenz von Objekten desselben Typs wie die Objekte, die in der Datenquelle enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-184">A simple `select` clause just produces a sequence of the same type of objects as the objects that are contained in the data source.</span></span> <span data-ttu-id="cdd2a-185">In diesem Beispiel enthält die Datenquelle `Country`-Objekte.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-185">In this example, the data source contains `Country` objects.</span></span> <span data-ttu-id="cdd2a-186">Die `orderby`-Klausel sortiert die Elemente in eine neue Reihenfolge, und die `select`-Klausel erzeugt eine Sequenz der neu angeordneten `Country`-Objekte.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-186">The `orderby` clause just sorts the elements into a new order and the `select` clause produces a sequence of the reordered `Country` objects.</span></span>

[!code-csharp[csrefQueryExpBasics#56](~/samples/snippets/csharp/concepts/linq/query-expression-basics_12.cs)]

<span data-ttu-id="cdd2a-187">Die `select`-Klausel kann zum Transformieren von Quelldaten in Sequenzen neuer Typen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-187">The `select` clause can be used to transform source data into sequences of new types.</span></span> <span data-ttu-id="cdd2a-188">Diese Transformation wird auch als *Projektion* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-188">This transformation is also named a *projection*.</span></span> <span data-ttu-id="cdd2a-189">Im folgenden Beispiel *projiziert`select` die* -Klausel eine Sequenz anonymer Typen, die nur eine Teilmenge der Felder im originalen Element enthalten.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-189">In the following example, the `select` clause *projects* a sequence of anonymous types which contains only a subset of the fields in the original element.</span></span> <span data-ttu-id="cdd2a-190">Beachten Sie, dass die neuen Objekte mit einem Objektinitialisierer initialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-190">Note that the new objects are initialized by using an object initializer.</span></span>

[!code-csharp[csrefQueryExpBasics#57](~/samples/snippets/csharp/concepts/linq/query-expression-basics_13.cs)]

<span data-ttu-id="cdd2a-191">Weitere Informationen zu allen Verfahren, in denen eine `select`-Klausel zum Transformieren von Daten verwendet werden kann, finden Sie unter [select-Klausel](../language-reference/keywords/select-clause.md).</span><span class="sxs-lookup"><span data-stu-id="cdd2a-191">For more information about all the ways that a `select` clause can be used to transform source data, see [select clause](../language-reference/keywords/select-clause.md).</span></span>

#### <a name="continuations-with-into"></a><span data-ttu-id="cdd2a-192">Fortsetzungen mit „into“</span><span class="sxs-lookup"><span data-stu-id="cdd2a-192">Continuations with "into"</span></span>

<span data-ttu-id="cdd2a-193">Sie können das Schlüsselwort `into` in einer `select`- oder `group`-Klausel verwenden, um einen temporären Bezeichner zu erstellen, der eine Abfrage speichert.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-193">You can use the `into` keyword in a `select` or `group` clause to create a temporary identifier that stores a query.</span></span> <span data-ttu-id="cdd2a-194">Dieses Vorgehen ist ratsam, wenn Sie zusätzliche Abfragevorgänge nach einem grouping- oder einem select-Vorgang auf eine Abfrage ausführen müssen.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-194">Do this when you must perform additional query operations on a query after a grouping or select operation.</span></span> <span data-ttu-id="cdd2a-195">Im folgenden Beispiel werden `countries` gemäß der Bevölkerung in Bereiche von 10 Millionen gruppiert.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-195">In the following example `countries` are grouped according to population in ranges of 10 million.</span></span> <span data-ttu-id="cdd2a-196">Nachdem diese Gruppen erstellt wurden, filtern zusätzliche Klauseln einige Gruppen heraus und sortieren die Gruppen dann in aufsteigender Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-196">After these groups are created, additional clauses filter out some groups, and then to sort the groups in ascending order.</span></span> <span data-ttu-id="cdd2a-197">Um diese zusätzlichen Vorgänge durchzuführen, wird die von `countryGroup` dargestellte Fortsetzung benötigt.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-197">To perform those additional operations, the continuation represented by `countryGroup` is required.</span></span>

[!code-csharp[csrefQueryExpBasics#58](~/samples/snippets/csharp/concepts/linq/query-expression-basics_14.cs)]

<span data-ttu-id="cdd2a-198">Weitere Informationen finden Sie unter [into](../language-reference/keywords/into.md).</span><span class="sxs-lookup"><span data-stu-id="cdd2a-198">For more information, see [into](../language-reference/keywords/into.md).</span></span>

### <a name="filtering-ordering-and-joining"></a><span data-ttu-id="cdd2a-199">Filtern, Sortieren und Verknüpfen</span><span class="sxs-lookup"><span data-stu-id="cdd2a-199">Filtering, ordering, and joining</span></span>

<span data-ttu-id="cdd2a-200">Zwischen der `from`-Klausel am Anfang und der `select`- oder `group`-Klausel am Ende sind alle anderen Klauseln (`where`, `join`, `orderby`, `from`, `let`) optional.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-200">Between the starting `from` clause, and the ending `select` or `group` clause, all other clauses (`where`, `join`, `orderby`, `from`, `let`) are optional.</span></span> <span data-ttu-id="cdd2a-201">Eine der optionalen Klauseln kann entweder überhaupt nicht oder mehrfach in einem Abfragetext verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-201">Any of the optional clauses may be used zero times or multiple times in a query body.</span></span>

#### <a name="where-clause"></a><span data-ttu-id="cdd2a-202">where-Klausel</span><span class="sxs-lookup"><span data-stu-id="cdd2a-202">where clause</span></span>

<span data-ttu-id="cdd2a-203">Verwenden Sie die Klausel `where` zum Herausfiltern von Elementen aus den Quelldaten basierend auf einem oder mehreren Prädikatausdrücken.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-203">Use the `where` clause to filter out elements from the source data based on one or more predicate expressions.</span></span> <span data-ttu-id="cdd2a-204">Im folgenden Beispiel verfügt die Klausel `where` über ein Prädikat mit zwei Bedingungen.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-204">The `where` clause in the following example has one predicate with two conditions.</span></span>

[!code-csharp[csrefQueryExpBasics#59](~/samples/snippets/csharp/concepts/linq/query-expression-basics_15.cs)]

<span data-ttu-id="cdd2a-205">Weitere Informationen finden Sie unter [where-Klausel](../language-reference/keywords/where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="cdd2a-205">For more information, see [where clause](../language-reference/keywords/where-clause.md).</span></span>

#### <a name="orderby-clause"></a><span data-ttu-id="cdd2a-206">orderby-Klausel</span><span class="sxs-lookup"><span data-stu-id="cdd2a-206">orderby clause</span></span>

<span data-ttu-id="cdd2a-207">Verwenden Sie die `orderby`-Klausel zum Sortieren der Ergebnisse in auf- oder absteigender Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-207">Use the `orderby` clause to sort the results in either ascending or descending order.</span></span> <span data-ttu-id="cdd2a-208">Sie können auch eine sekundäre Sortierreihenfolge angeben.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-208">You can also specify secondary sort orders.</span></span> <span data-ttu-id="cdd2a-209">Im folgenden Beispiel wird mit der Eigenschaft `Area` eine primäre Sortierung der `country`-Objekte durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-209">The following example performs a primary sort on the `country` objects by using the `Area` property.</span></span> <span data-ttu-id="cdd2a-210">Anschließend wird eine sekundäre Sortierung mit der Eigenschaft `Population` durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-210">It then performs a secondary sort by using the `Population` property.</span></span>

[!code-csharp[csrefQueryExpBasics#60](~/samples/snippets/csharp/concepts/linq/query-expression-basics_16.cs)]

<span data-ttu-id="cdd2a-211">Das Schlüsselwort `ascending` ist optional; wenn keine andere Reihenfolge angegeben ist, ist dies die Standardreihenfolge.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-211">The `ascending` keyword is optional; it is the default sort order if no order is specified.</span></span> <span data-ttu-id="cdd2a-212">Weitere Informationen finden Sie unter [orderby-Klausel](../language-reference/keywords/orderby-clause.md).</span><span class="sxs-lookup"><span data-stu-id="cdd2a-212">For more information, see [orderby clause](../language-reference/keywords/orderby-clause.md).</span></span>

#### <a name="join-clause"></a><span data-ttu-id="cdd2a-213">join-Klausel</span><span class="sxs-lookup"><span data-stu-id="cdd2a-213">join clause</span></span>

<span data-ttu-id="cdd2a-214">Verwenden Sie die `join`-Klausel zum Zuordnen und/oder Kombinieren von Elementen aus einer Datenquelle mit Elementen aus einer anderen Datenquelle basierend auf einem Gleichheitsvergleich zwischen angegebenen Schlüsseln in jedem Element.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-214">Use the `join` clause to associate and/or combine elements from one data source with elements from another data source based on an equality comparison between specified keys in each element.</span></span> <span data-ttu-id="cdd2a-215">In LINQ werden Verknüpfungsvorgänge für Sequenzen von Objekten ausgeführt, deren Elemente unterschiedliche Typen haben.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-215">In LINQ, join operations are performed on sequences of objects whose elements are different types.</span></span> <span data-ttu-id="cdd2a-216">Nachdem Sie zwei Segmente verknüpft haben, müssen Sie eine `select`- oder `group`-Anweisung verwenden, um anzugeben, welches Element in der Ausgabesequenz gespeichert werden soll.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-216">After you have joined two sequences, you must use a `select` or `group` statement to specify which element to store in the output sequence.</span></span> <span data-ttu-id="cdd2a-217">Sie können auch einen anonymen Typ verwenden, um Eigenschaften aus jedem Satz der zugewiesenen Elemente in einem neuen Typ für die Ausgabesequenz zu kombinieren.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-217">You can also use an anonymous type to combine properties from each set of associated elements into a new type for the output sequence.</span></span> <span data-ttu-id="cdd2a-218">Im folgenden Beispiel werden `prod`-Objekte, deren `Category`-Eigenschaft einer der Kategorien im `categories`-Zeichenfolgearray entspricht, zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-218">The following example associates `prod` objects whose `Category` property matches one of the categories in the `categories` string array.</span></span> <span data-ttu-id="cdd2a-219">Produkte, deren `Category` keiner Zeichenfolge in `categories` entspricht, werden herausgefiltert. Die `select`-Anweisung projiziert einen neuen Typ, dessen Eigenschaften aus `cat` und `prod` stammen.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-219">Products whose `Category` does not match any string in `categories` are filtered out. The `select` statement projects a new type whose properties are taken from both `cat` and `prod`.</span></span>

[!code-csharp[csrefQueryExpBasics#61](~/samples/snippets/csharp/concepts/linq/query-expression-basics_17.cs)]

<span data-ttu-id="cdd2a-220">Sie können auch eine Gruppenverknüpfung durchführen, indem Sie die Ergebnisse des `join`-Vorgangs mithilfe des Schlüsselworts [into](../language-reference/keywords/into.md) in eine temporäre Variable speichern.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-220">You can also perform a group join by storing the results of the `join` operation into a temporary variable by using the [into](../language-reference/keywords/into.md) keyword.</span></span> <span data-ttu-id="cdd2a-221">Weitere Informationen finden Sie unter [join-Klausel](../language-reference/keywords/join-clause.md).</span><span class="sxs-lookup"><span data-stu-id="cdd2a-221">For more information, see [join clause](../language-reference/keywords/join-clause.md).</span></span>

#### <a name="let-clause"></a><span data-ttu-id="cdd2a-222">let-Klausel</span><span class="sxs-lookup"><span data-stu-id="cdd2a-222">let clause</span></span>

<span data-ttu-id="cdd2a-223">Verwenden Sie die `let`-Klausel zum Speichern der Ergebnisse eines Ausdrucks, z.B. eines Methodenaufrufs, in einer neuen Bereichsvariable.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-223">Use the `let` clause to store the result of an expression, such as a method call, in a new range variable.</span></span> <span data-ttu-id="cdd2a-224">Im folgenden Beispiel speichert die Bereichsvariable `firstName` das erste Elemente eines Arrays von Zeichenfolgen, das von `Split` zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-224">In the following example, the range variable `firstName` stores the first element of the array of strings that is returned by `Split`.</span></span>

[!code-csharp[csrefQueryExpBasics#62](~/samples/snippets/csharp/concepts/linq/query-expression-basics_18.cs)]

<span data-ttu-id="cdd2a-225">Weitere Informationen finden Sie unter [let-Klausel](../language-reference/keywords/let-clause.md).</span><span class="sxs-lookup"><span data-stu-id="cdd2a-225">For more information, see [let clause](../language-reference/keywords/let-clause.md).</span></span>

### <a name="subqueries-in-a-query-expression"></a><span data-ttu-id="cdd2a-226">Unterabfragen in einem Abfrageausdruck</span><span class="sxs-lookup"><span data-stu-id="cdd2a-226">Subqueries in a query expression</span></span>

<span data-ttu-id="cdd2a-227">Ein Abfrageausdruck selbst kann eine Abfrageklausel enthalten, die manchmal als *Unterabfrage* bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-227">A query clause may itself contain a query expression, which is sometimes referred to as a *subquery*.</span></span> <span data-ttu-id="cdd2a-228">Jede Unterabfrage beginnt mit ihrer eigenen `from`-Klausel, die nicht unbedingt auf die gleiche Datenquelle in der ersten `from`-Klausel zeigt.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-228">Each subquery starts with its own `from` clause that does not necessarily point to the same data source in the first `from` clause.</span></span> <span data-ttu-id="cdd2a-229">Die folgende Abfrage zeigt z.B. einen Abfrageausdruck, der in der Select-Anweisung zum Abrufen der Ergebnisse eines Gruppierungsvorganges verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="cdd2a-229">For example, the following query shows a query expression that is used in the select statement to retrieve the results of a grouping operation.</span></span>

[!code-csharp[csrefQueryExpBasics#63](~/samples/snippets/csharp/concepts/linq/query-expression-basics_19.cs)]

<span data-ttu-id="cdd2a-230">Weitere Informationen finden Sie unter [Ausführen einer Unterabfrage für einen Gruppierungsvorgang](perform-a-subquery-on-a-grouping-operation.md).</span><span class="sxs-lookup"><span data-stu-id="cdd2a-230">For more information, see [Perform a subquery on a grouping operation](perform-a-subquery-on-a-grouping-operation.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="cdd2a-231">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="cdd2a-231">See also</span></span>

- [<span data-ttu-id="cdd2a-232">C#-Programmierhandbuch</span><span class="sxs-lookup"><span data-stu-id="cdd2a-232">C# programming guide</span></span>](../programming-guide/index.md)
- [<span data-ttu-id="cdd2a-233">Language-Integrated Query (LINQ)</span><span class="sxs-lookup"><span data-stu-id="cdd2a-233">Language Integrated Query (LINQ)</span></span>](index.md)
- [<span data-ttu-id="cdd2a-234">Abfrageschlüsselwörter (LINQ)</span><span class="sxs-lookup"><span data-stu-id="cdd2a-234">Query keywords (LINQ)</span></span>](../language-reference/keywords/query-keywords.md)
- [<span data-ttu-id="cdd2a-235">Standard query operators overview (Übersicht über Standardabfrageoperatoren)</span><span class="sxs-lookup"><span data-stu-id="cdd2a-235">Standard query operators overview</span></span>](../programming-guide/concepts/linq/standard-query-operators-overview.md)
