---
title: Schreiben von sicherem und effizientem C#-Code
description: Durch Verbesserungen, die kürzlich an C# vorgenommen wurden, können Sie nun überprüfbaren sicheren Code schreiben, dessen Leistung vorher nur mit unsicherem Code zu erzielen war.
ms.date: 10/23/2018
ms.technology: csharp-advanced-concepts
ms.custom: mvc
ms.openlocfilehash: f590a338d35966e2cd3a507164057a49b8a5f6f8
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 12/25/2019
ms.locfileid: "75346704"
---
# <a name="write-safe-and-efficient-c-code"></a><span data-ttu-id="1938a-103">Schreiben von sicherem und effizientem C#-Code</span><span class="sxs-lookup"><span data-stu-id="1938a-103">Write safe and efficient C# code</span></span>

<span data-ttu-id="1938a-104">Dank neuer C#-Features können Sie nun überprüfbaren sicheren Code schreiben, der eine höhere Leistung ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="1938a-104">New features in C# enable you to write verifiable safe code with better performance.</span></span> <span data-ttu-id="1938a-105">Wenn Sie diese Techniken mit Bedacht einsetzen, sind weniger Szenarios mit unsicherem Code erforderlich.</span><span class="sxs-lookup"><span data-stu-id="1938a-105">If you carefully apply these techniques, fewer scenarios require unsafe code.</span></span> <span data-ttu-id="1938a-106">Mit den neuen Features können Verweise auf Werttypen als Methodenargumente und auf Rückgabewerte von Methoden leichter verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-106">These features make it easier to use references to value types as method arguments and method returns.</span></span> <span data-ttu-id="1938a-107">Wenn diese Strategien sicher angewendet werden, müssen weniger Werttypen kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-107">When done safely, these techniques minimize copying value types.</span></span> <span data-ttu-id="1938a-108">Durch die Verwendung von Werttypen können Sie die Anzahl der Speicherbelegungen und Garbage Collection-Vorgänge minimieren.</span><span class="sxs-lookup"><span data-stu-id="1938a-108">By using value types, you can minimize the number of allocations and garbage collection passes.</span></span>

<span data-ttu-id="1938a-109">In vielen Codebeispielen in diesem Artikel werden die neuen Features von C# 7.2 verwendet.</span><span class="sxs-lookup"><span data-stu-id="1938a-109">Much of the sample code in this article uses features added in C# 7.2.</span></span> <span data-ttu-id="1938a-110">Um diese nutzen zu können, müssen Sie Ihr Projekt für die Verwendung von C# 7.2 oder höher konfigurieren.</span><span class="sxs-lookup"><span data-stu-id="1938a-110">To use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="1938a-111">Weitere Informationen zum Festlegen der Sprachversion finden Sie unter [Konfigurieren der Sprachversion](language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="1938a-111">For more information on setting the language version, see [configure the language version](language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="1938a-112">In diesem Artikel stehen Vorgehensweisen für die effiziente Ressourcenverwaltung im Vordergrund.</span><span class="sxs-lookup"><span data-stu-id="1938a-112">This article focuses on techniques for efficient resource management.</span></span> <span data-ttu-id="1938a-113">Ein Vorteil bei der Nutzung von Werttypen besteht darin, dass häufig eine Heapspeicherbelegung vermieden wird.</span><span class="sxs-lookup"><span data-stu-id="1938a-113">One advantage to using value types is that they often avoid heap allocations.</span></span> <span data-ttu-id="1938a-114">Der Nachteil ist, dass sie als Wert kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-114">The disadvantage is that they're copied by value.</span></span> <span data-ttu-id="1938a-115">Dies macht es schwieriger, Algorithmen zu optimieren, die mit großen Datenmengen arbeiten.</span><span class="sxs-lookup"><span data-stu-id="1938a-115">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="1938a-116">Neue Sprachfeatures in C# 7.2 stellen Mechanismen bereit, die Verweise auf Werttypen nutzen und sicheren sowie effizienten Code ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="1938a-116">New language features in C# 7.2 provide mechanisms that enable safe efficient code using references to value types.</span></span> <span data-ttu-id="1938a-117">Wenn Sie diese Features geschickt einsetzen, können Sie sowohl Speicherbelegungen als auch Kopiervorgänge minimieren.</span><span class="sxs-lookup"><span data-stu-id="1938a-117">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="1938a-118">In diesem Artikel werden diese neuen Features untersucht.</span><span class="sxs-lookup"><span data-stu-id="1938a-118">This article explores those new features.</span></span>

<span data-ttu-id="1938a-119">Folgende Empfehlungen zur Ressourcenverwaltung werden behandelt:</span><span class="sxs-lookup"><span data-stu-id="1938a-119">This article focuses on the following resource management techniques:</span></span>

- <span data-ttu-id="1938a-120">Deklarieren Sie einen [`readonly struct`](language-reference/keywords/readonly.md#readonly-struct-example)-Typ, um einen Typ als **unveränderlich** festzulegen. Dadurch muss der Compiler weniger Kopien erstellen, wenn [`in`](language-reference/keywords/in-parameter-modifier.md)-Parameter verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-120">Declare a [`readonly struct`](language-reference/keywords/readonly.md#readonly-struct-example) to express that a type is **immutable** and enables the compiler to save copies when using [`in`](language-reference/keywords/in-parameter-modifier.md) parameters.</span></span>
- <span data-ttu-id="1938a-121">Wenn ein Typ nicht so festgelegt werden kann, dass er nicht veränderbar ist, deklarieren Sie `struct`-Member als `readonly`, um anzuzeigen, dass der Member den Zustand nicht ändert.</span><span class="sxs-lookup"><span data-stu-id="1938a-121">If a type can't be immutable, declare `struct` members `readonly` to indicate that the member doesn't modify state.</span></span>
- <span data-ttu-id="1938a-122">Verwenden Sie einen [`ref readonly`](language-reference/keywords/ref.md#reference-return-values)-Verweisrückgabewert, wenn der Rückgabewert ein `struct`-Typ und größer als <xref:System.IntPtr.Size?displayProperty=nameWithType> ist und die Speicherlebensdauer die der Methode überschreitet, die den Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="1938a-122">Use a [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return when the return value is a `struct` larger than <xref:System.IntPtr.Size?displayProperty=nameWithType> and the storage lifetime is greater than the method returning the value.</span></span>
- <span data-ttu-id="1938a-123">Übergeben Sie aus Leistungsgründen einen `readonly struct`-Typ als `in`-Parameter, wenn die Größe des Typs <xref:System.IntPtr.Size?displayProperty=nameWithType> überschreitet.</span><span class="sxs-lookup"><span data-stu-id="1938a-123">When the size of a `readonly struct` is bigger than <xref:System.IntPtr.Size?displayProperty=nameWithType>, you should pass it as an `in` parameter for performance reasons.</span></span>
- <span data-ttu-id="1938a-124">Übergeben Sie niemals einen `struct`-Member als einen `in`-Parameter, es sei denn, er ist mit dem `readonly`-Modifikator deklariert, oder die Methode ruft nur `readonly`-Member der Struktur auf.</span><span class="sxs-lookup"><span data-stu-id="1938a-124">Never pass a `struct` as an `in` parameter unless it's declared with the `readonly` modifier or the method calls only `readonly` members of the struct.</span></span> <span data-ttu-id="1938a-125">Ein Verstoß gegen diese Anleitung kann die Leistung negativ beeinflussen und zu einem unklaren Verhalten führen.</span><span class="sxs-lookup"><span data-stu-id="1938a-125">Violating this guidance may negatively affect performance and could lead to an obscure behavior.</span></span>
- <span data-ttu-id="1938a-126">Verwenden Sie einen [`ref struct`](language-reference/keywords/ref.md#ref-struct-types)- oder `readonly ref struct`-Typ wie <xref:System.Span%601> oder <xref:System.ReadOnlySpan%601>, um mit Speicher als Bytesequenz zu arbeiten.</span><span class="sxs-lookup"><span data-stu-id="1938a-126">Use a [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), or a `readonly ref struct` such as <xref:System.Span%601> or <xref:System.ReadOnlySpan%601> to work with memory as a sequence of bytes.</span></span>

<span data-ttu-id="1938a-127">Durch diese Techniken müssen Sie im Hinblick auf **Verweise** und **Werte** zwei konkurrierende Ziele abwägen.</span><span class="sxs-lookup"><span data-stu-id="1938a-127">These techniques force you to balance two competing goals with regard to **references** and **values**.</span></span> <span data-ttu-id="1938a-128">Variablen, die [Verweistypen](programming-guide/types/index.md#reference-types) sind, enthalten einen Verweis auf den Speicherort.</span><span class="sxs-lookup"><span data-stu-id="1938a-128">Variables that are [reference types](programming-guide/types/index.md#reference-types) hold a reference to the location in memory.</span></span> <span data-ttu-id="1938a-129">Variablen, die [Werttypen](programming-guide/types/index.md#value-types) sind, enthalten den tatsächlichen Wert.</span><span class="sxs-lookup"><span data-stu-id="1938a-129">Variables that are [value types](programming-guide/types/index.md#value-types) directly contain their value.</span></span> <span data-ttu-id="1938a-130">Diese Unterschiede sind für die Verwaltung von Speicherressourcen entscheidend.</span><span class="sxs-lookup"><span data-stu-id="1938a-130">These differences highlight the key differences that are important for managing memory resources.</span></span> <span data-ttu-id="1938a-131">**Werttypen** werden üblicherweise kopiert, wenn sie einer Methode übergeben oder von dieser zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-131">**Value types** are typically copied when passed to a method or returned from a method.</span></span> <span data-ttu-id="1938a-132">Bei diesem Verhalten wird der Wert von `this` kopiert, wenn Member eines Werttyps aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-132">This behavior includes copying the value of `this` when calling members of a value type.</span></span> <span data-ttu-id="1938a-133">Der Kopieraufwand steht im Zusammenhang mit der Größe des Typs.</span><span class="sxs-lookup"><span data-stu-id="1938a-133">The cost of the copy is related to the size of the type.</span></span> <span data-ttu-id="1938a-134">Für **Verweistypen** wird auf dem verwalteten Heap Speicher belegt.</span><span class="sxs-lookup"><span data-stu-id="1938a-134">**Reference types** are allocated on the managed heap.</span></span> <span data-ttu-id="1938a-135">Für jedes neue Objekt ist eine erneute Speicherbelegung erforderlich. Anschließend muss für dieses der Speicher wieder freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-135">Each new object requires a new allocation, and subsequently must be reclaimed.</span></span> <span data-ttu-id="1938a-136">Beide Vorgänge nehmen Zeit in Anspruch.</span><span class="sxs-lookup"><span data-stu-id="1938a-136">Both these operations take time.</span></span> <span data-ttu-id="1938a-137">Der Verweis wird kopiert, wenn ein Verweistyp als Argument einer Methode übergeben oder von dieser zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="1938a-137">The reference is copied when a reference type is passed as an argument to a method or returned from a method.</span></span>

<span data-ttu-id="1938a-138">In diesem Artikel wird im Folgenden beispielhaft eine Struktur für einen Punkt im dreidimensionalen Raum verwendet, um die Empfehlungen zu erläutern:</span><span class="sxs-lookup"><span data-stu-id="1938a-138">This article uses the following example concept of the 3D-point structure to explain these recommendations:</span></span>

```csharp
public struct Point3D
{
    public double X;
    public double Y;
    public double Z;
}
```

<span data-ttu-id="1938a-139">In verschiedenen Beispielen werden unterschiedliche Implementierungen vorgestellt.</span><span class="sxs-lookup"><span data-stu-id="1938a-139">Different examples use different implementations of this concept.</span></span>

## <a name="declare-readonly-structs-for-immutable-value-types"></a><span data-ttu-id="1938a-140">Deklarieren von schreibgeschützten Strukturen für unveränderliche Werttypen</span><span class="sxs-lookup"><span data-stu-id="1938a-140">Declare readonly structs for immutable value types</span></span>

<span data-ttu-id="1938a-141">Wenn Sie einen `struct`-Typ mit dem `readonly`-Modifizierer deklarieren, wird dem Compiler signalisiert, dass ein unveränderlicher Typ erstellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="1938a-141">Declaring a `struct` using the `readonly` modifier informs the compiler that your intent is to create an immutable type.</span></span> <span data-ttu-id="1938a-142">Der Compiler erzwingt diese Entwurfsentscheidung mit den folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1938a-142">The compiler enforces that design decision with the following rules:</span></span>

- <span data-ttu-id="1938a-143">Alle Feldmember müssen `readonly` sein.</span><span class="sxs-lookup"><span data-stu-id="1938a-143">All field members must be `readonly`</span></span>
- <span data-ttu-id="1938a-144">Alle Eigenschaften, also auch automatisch implementierte, müssen schreibgeschützt sein.</span><span class="sxs-lookup"><span data-stu-id="1938a-144">All properties must be read-only, including auto-implemented properties.</span></span>

<span data-ttu-id="1938a-145">Mit diesen beiden Regeln wird sichergestellt, dass kein Member von `readonly struct` den Zustand dieser Struktur verändert.</span><span class="sxs-lookup"><span data-stu-id="1938a-145">These two rules are sufficient to ensure that no member of a `readonly struct` modifies the state of that struct.</span></span> <span data-ttu-id="1938a-146">Der `struct`-Typ ist unveränderlich.</span><span class="sxs-lookup"><span data-stu-id="1938a-146">The `struct` is immutable.</span></span> <span data-ttu-id="1938a-147">Die `Point3D`-Struktur kann wie im folgenden Beispiel gezeigt als unveränderlich definiert werden:</span><span class="sxs-lookup"><span data-stu-id="1938a-147">The `Point3D` structure could be defined as an immutable struct as shown in the following example:</span></span>

```csharp
readonly public struct ReadonlyPoint3D
{
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    public double X { get; }
    public double Y { get; }
    public double Z { get; }
}
```

<span data-ttu-id="1938a-148">Sie sollten sich immer dann an diese Empfehlung halten, wenn die Entwurfsabsicht darin besteht, einen unveränderlichen Werttyp zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="1938a-148">Follow this recommendation whenever your design intent is to create an immutable value type.</span></span> <span data-ttu-id="1938a-149">Ein weiterer Vorteil ergibt sich aus eventuellen Leistungsverbesserungen.</span><span class="sxs-lookup"><span data-stu-id="1938a-149">Any performance improvements are an added benefit.</span></span> <span data-ttu-id="1938a-150">Mit `readonly struct` bringen Sie Ihre Entwurfsabsicht deutlich zum Ausdruck.</span><span class="sxs-lookup"><span data-stu-id="1938a-150">The `readonly struct` clearly expresses your design intent.</span></span>

## <a name="declare-readonly-members-when-a-struct-cant-be-immutable"></a><span data-ttu-id="1938a-151">Deklarieren von schreibgeschützten Member, wenn eine Struktur nicht so festgelegt werden kann, dass sie nicht veränderbar ist</span><span class="sxs-lookup"><span data-stu-id="1938a-151">Declare readonly members when a struct can't be immutable</span></span>

<span data-ttu-id="1938a-152">Wenn ein Strukturtyp in C# 8.0 und höher veränderbar ist, sollten Sie Member, die nicht verändert werden können, mit `readonly` deklarieren.</span><span class="sxs-lookup"><span data-stu-id="1938a-152">In C# 8.0 and later, when a struct type is mutable, you should declare members that don't cause mutation to be `readonly`.</span></span> <span data-ttu-id="1938a-153">Im Folgenden finden Sie beispielsweise eine veränderbare Variation der 3D-Punktstruktur:</span><span class="sxs-lookup"><span data-stu-id="1938a-153">For example, the following is a mutable variation of the 3D point structure:</span></span>

```csharp
public struct Point3D
{
    public Point3D(double x, double y, double z)
    {
        _x = x;
        _y = y;
        _z = z;
    }

    private double _x;
    public double X
    {
        readonly get => _x;
        set => _x = value;
    }

    private double _y;
    public double Y
    {
        readonly get => _y;
        set => _y = value;
    }

    private double _z;
    public double Z
    {
        readonly get => _z;
        set => _z = value;
    }

    public readonly double Distance => Math.Sqrt(X * X + Y * Y + Z * Z);

    public readonly override string ToString() => $"{X}, {Y}, {Z}";
}
```

<span data-ttu-id="1938a-154">Das vorhergehende Beispiel zeigt viele der Stellen, an denen Sie den `readonly`-Modifizierer anwenden können: Methoden, Eigenschaften und Eigenschaftenaccessoren.</span><span class="sxs-lookup"><span data-stu-id="1938a-154">The preceding sample shows many of the locations where you can apply the `readonly` modifier: methods, properties, and property accessors.</span></span> <span data-ttu-id="1938a-155">Wenn Sie automatisch implementierte Eigenschaften verwenden, fügt der Compiler dem `get`-Zugriff den `readonly`-Modifizierer für Lese- und Schreibeigenschaften hinzu.</span><span class="sxs-lookup"><span data-stu-id="1938a-155">If you use auto-implemented properties, the compiler adds the `readonly` modifier to the `get` accessor for read-write properties.</span></span> <span data-ttu-id="1938a-156">Der Compiler fügt den `readonly`-Modifizierer zu den automatisch implementierten Eigenschaftendeklarationen für Eigenschaften mit nur einem `get`-Zugriff hinzu.</span><span class="sxs-lookup"><span data-stu-id="1938a-156">The compiler adds the `readonly` modifier to the auto-implemented property declarations for properties with only a `get` accessor.</span></span>

<span data-ttu-id="1938a-157">Das Hinzufügen des `readonly`-Modifizierers zu Membern, die den Zustand nicht verändern, bietet zwei damit verbundene Vorteile:</span><span class="sxs-lookup"><span data-stu-id="1938a-157">Adding the `readonly` modifier to members that don't mutate state provides two related benefits.</span></span> <span data-ttu-id="1938a-158">Der erste Vorteil ist, dass Sie mithilfe des Compilers die Umsetzung Ihrer Absicht erzwingen können.</span><span class="sxs-lookup"><span data-stu-id="1938a-158">First, the compiler enforces your intent.</span></span> <span data-ttu-id="1938a-159">Dieser Member kann weder den Zustand der Struktur verändern, noch kann er auf ein Member zugreifen, der nicht ebenfalls mit `readonly` markiert ist.</span><span class="sxs-lookup"><span data-stu-id="1938a-159">That member can't mutate the struct's state, nor can it access a member that isn't also marked `readonly`.</span></span> <span data-ttu-id="1938a-160">Der zweite Vorteil ist, dass der Compiler beim Zugriff auf einen `readonly`-Member keine defensiven Kopien von `in`-Parametern erstellt.</span><span class="sxs-lookup"><span data-stu-id="1938a-160">Second, the compiler won't create defensive copies of `in` parameters when accessing a `readonly` member.</span></span> <span data-ttu-id="1938a-161">Der Compiler kann diese Optimierung sicher durchführen, da er garantiert, dass der `struct`-Member nicht von einem `readonly`-Member verändert wird.</span><span class="sxs-lookup"><span data-stu-id="1938a-161">The compiler can make this optimization safely because it guarantees that the `struct` is not modified by a `readonly` member.</span></span>

## <a name="use-ref-readonly-return-statements-for-large-structures-when-possible"></a><span data-ttu-id="1938a-162">Verwenden von `ref readonly return`-Anweisungen für große Strukturen (wo möglich)</span><span class="sxs-lookup"><span data-stu-id="1938a-162">Use `ref readonly return` statements for large structures when possible</span></span>

<span data-ttu-id="1938a-163">Sie können Werte als Verweis zurückgeben, wenn diese in der Rückgabemethode nicht lokal verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-163">You can return values by reference when the value being returned isn't local to the returning method.</span></span> <span data-ttu-id="1938a-164">Bei dieser Vorgehensweise wird nur der Verweis und nicht die Struktur kopiert.</span><span class="sxs-lookup"><span data-stu-id="1938a-164">Returning by reference means that only the reference is copied, not the structure.</span></span> <span data-ttu-id="1938a-165">Im folgenden Beispiel kann für die `Origin`-Eigenschaft kein `ref`-Verweisrückgabewert verwendet werden, da der Rückgabewert eine lokale Variable ist:</span><span class="sxs-lookup"><span data-stu-id="1938a-165">In the following example, the `Origin` property can't use a `ref` return because the value being returned is a local variable:</span></span>

```csharp
public Point3D Origin => new Point3D(0,0,0);
```

<span data-ttu-id="1938a-166">Die folgende Eigenschaftendefinition kann hingegen durchaus als Verweis zurückgegeben werden, weil der Rückgabewert ein statischer Member ist:</span><span class="sxs-lookup"><span data-stu-id="1938a-166">However, the following property definition can be returned by reference because the returned value is a static member:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    // Dangerous! returning a mutable reference to internal storage
    public ref Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="1938a-167">Damit aufrufende Funktionen nicht den Ursprung verändern, sollten Sie den Wert als `ref readonly` zurückgeben:</span><span class="sxs-lookup"><span data-stu-id="1938a-167">You don't want callers modifying the origin, so you should return the value by `ref readonly`:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    public static ref readonly Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="1938a-168">Durch die Rückgabe von `ref readonly` vermeiden Sie, dass größere Strukturen kopiert werden. Zusätzlich wird die Unveränderlichkeit interner Datenmember beibehalten.</span><span class="sxs-lookup"><span data-stu-id="1938a-168">Returning `ref readonly` enables you to save copying larger structures and preserve the immutability of your internal data members.</span></span>

<span data-ttu-id="1938a-169">An der Aufrufstelle können die aufrufenden Funktionen die `Origin`-Eigenschaft entweder als `ref readonly` oder als Wert verwenden:</span><span class="sxs-lookup"><span data-stu-id="1938a-169">At the call site, callers make the choice to use the `Origin` property as a `ref readonly` or as a value:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="1938a-170">Die erste Zuweisung im vorhergehenden Code erstellt eine Kopie der Konstanten `Origin` und weist diese Kopie zu.</span><span class="sxs-lookup"><span data-stu-id="1938a-170">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="1938a-171">Die zweite weist einen Verweis zu.</span><span class="sxs-lookup"><span data-stu-id="1938a-171">The second assigns a reference.</span></span> <span data-ttu-id="1938a-172">Beachten Sie, dass der Modifizierer `readonly` Teil der Variablendeklaration sein muss.</span><span class="sxs-lookup"><span data-stu-id="1938a-172">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="1938a-173">Der referenzierte Verweis kann nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-173">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="1938a-174">Derartige Versuche führen zu einem Kompilierzeitfehler.</span><span class="sxs-lookup"><span data-stu-id="1938a-174">Attempts to do so result in a compile-time error.</span></span>

<span data-ttu-id="1938a-175">Der `readonly`-Modifizierer ist für die Deklaration von `originReference` erforderlich.</span><span class="sxs-lookup"><span data-stu-id="1938a-175">The `readonly` modifier is required on the declaration of `originReference`.</span></span>

<span data-ttu-id="1938a-176">Der Compiler erzwingt, dass die aufrufende Funktion den Verweis nicht ändern kann.</span><span class="sxs-lookup"><span data-stu-id="1938a-176">The compiler enforces that the caller can't modify the reference.</span></span> <span data-ttu-id="1938a-177">Versuche einer direkten Wertzuweisung führen zu einem Kompilierzeitfehler.</span><span class="sxs-lookup"><span data-stu-id="1938a-177">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="1938a-178">Der Compiler kann jedoch nicht wissen, ob eine Membermethode den Zustand der Struktur ändert.</span><span class="sxs-lookup"><span data-stu-id="1938a-178">However, the compiler can't know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="1938a-179">Um sicherzustellen, dass das Objekt nicht geändert wird, erstellt der Compiler eine Kopie und ruft Memberverweise mit dieser auf.</span><span class="sxs-lookup"><span data-stu-id="1938a-179">To ensure that the object isn't modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="1938a-180">Alle Änderungen werden an der Defensivkopie vorgenommen.</span><span class="sxs-lookup"><span data-stu-id="1938a-180">Any modifications are to that defensive copy.</span></span>

## <a name="apply-the-in-modifier-to-readonly-struct-parameters-larger-than-systemintptrsize"></a><span data-ttu-id="1938a-181">Anwenden des `in`-Modifizierer auf einen `readonly struct`-Parameter, der größer als `System.IntPtr.Size` ist</span><span class="sxs-lookup"><span data-stu-id="1938a-181">Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`</span></span>

<span data-ttu-id="1938a-182">Das `in`-Schlüsselwort ergänzt die vorhandenen Schlüsselwörter `ref` und `out` zum Übergeben von Argumenten als Verweis.</span><span class="sxs-lookup"><span data-stu-id="1938a-182">The `in` keyword complements the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="1938a-183">Durch das `in`-Schlüsselwort wird festgelegt, dass das Argument als Verweis übergeben wird, die aufgerufene Methode aber nicht den Wert ändert.</span><span class="sxs-lookup"><span data-stu-id="1938a-183">The `in` keyword specifies passing the argument by reference, but the called method doesn't modify the value.</span></span>

<span data-ttu-id="1938a-184">Dieser Zusatz bietet zahlreiche Möglichkeiten, Ihre Entwurfsabsicht auszudrücken.</span><span class="sxs-lookup"><span data-stu-id="1938a-184">This addition provides a full vocabulary to express your design intent.</span></span>
<span data-ttu-id="1938a-185">Werttypen werden bei der Übergabe an eine aufgerufene Methode kopiert, wenn Sie keinen der folgenden Modifizierer in den Methodensignaturen angeben.</span><span class="sxs-lookup"><span data-stu-id="1938a-185">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="1938a-186">Jeder dieser Modifizierer legt fest, dass eine Variable als Verweis übergeben wird, wodurch ein Kopieren vermieden wird.</span><span class="sxs-lookup"><span data-stu-id="1938a-186">Each of these modifiers specifies that a variable is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="1938a-187">Jeder Modifizierer drückt eine andere Absicht aus:</span><span class="sxs-lookup"><span data-stu-id="1938a-187">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="1938a-188">`out`: Diese Methode legt den Wert des Arguments fest, das als dieser Parameter verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="1938a-188">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="1938a-189">`ref`: Diese Methode kann den Wert des Arguments festlegen, das als dieser Parameter verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="1938a-189">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="1938a-190">`in`: Diese Methode ändert den Wert des Arguments nicht, das als dieser Parameter verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="1938a-190">`in`: This method doesn't modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="1938a-191">Wenn Sie den Modifizierer `in` zur Übergabe eines Arguments als Verweis hinzufügen, legen Sie als Entwurfsabsicht fest, dass Argumente als Verweis übergeben werden sollen, um unnötiges Kopieren zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="1938a-191">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="1938a-192">Das als Argument verwendete Objekt soll nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-192">You don't intend to modify the object used as that argument.</span></span>

<span data-ttu-id="1938a-193">Diese Vorgehensweise führt oft zu Leistungsverbesserungen für schreibgeschützte Werttypen, die größer als <xref:System.IntPtr.Size?displayProperty=nameWithType> sind.</span><span class="sxs-lookup"><span data-stu-id="1938a-193">This practice often improves performance for readonly value types that are larger than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1938a-194">Bei einfachen Typen (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` und `bool` sowie `enum`) fallen potenzielle Leistungssteigerungen hingegen minimal aus.</span><span class="sxs-lookup"><span data-stu-id="1938a-194">For simple types (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` and `bool`, and `enum` types), any potential performance gains are minimal.</span></span> <span data-ttu-id="1938a-195">Wenn für Typen, die kleiner als <xref:System.IntPtr.Size?displayProperty=nameWithType> sind, Werte als Verweis übergeben werden, kann dies sogar zu Leistungseinbußen führen.</span><span class="sxs-lookup"><span data-stu-id="1938a-195">In fact, performance may degrade by using pass-by-reference for types smaller than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="1938a-196">Der folgende Code zeigt als Beispiel eine Methode, die den Abstand zwischen Punkten in einem 3D-Raum berechnet.</span><span class="sxs-lookup"><span data-stu-id="1938a-196">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span>

[!code-csharp[InArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="1938a-197">Die Argumente sind zwei Strukturen, die jeweils drei double-Werte enthalten.</span><span class="sxs-lookup"><span data-stu-id="1938a-197">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="1938a-198">Ein double-Wert ist 8 Byte groß, also umfasst jedes Argument 24 Byte.</span><span class="sxs-lookup"><span data-stu-id="1938a-198">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="1938a-199">Durch Angabe des Modifizierers `in` übergeben Sie abhängig von der Architektur des Computers einen 4-Byte- oder 8-Byte-Verweis an diese Argumente.</span><span class="sxs-lookup"><span data-stu-id="1938a-199">By specifying the `in` modifier, you pass a 4 byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="1938a-200">Der Größenunterschied ist zwar gering, doch er summiert sich, wenn Ihre Anwendung diese Methode in einer kurzen Schleife mit vielen unterschiedlichen Werten aufruft.</span><span class="sxs-lookup"><span data-stu-id="1938a-200">The difference in size is small, but it adds up when your application calls this method in a tight loop using many different values.</span></span>

<span data-ttu-id="1938a-201">Der Modifizierer `in` ergänzt `out` und `ref` auch in anderer Weise.</span><span class="sxs-lookup"><span data-stu-id="1938a-201">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="1938a-202">Sie können keine überladenen Methoden erstellen, die sich nur durch das Vorhandensein von `in`, `out` oder `ref` unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="1938a-202">You can't create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="1938a-203">Diese neuen Regeln erweitern dasselbe Verhalten, das stets für `out`- und `ref`-Parameter definiert wurde.</span><span class="sxs-lookup"><span data-stu-id="1938a-203">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span> <span data-ttu-id="1938a-204">Für Werttypen kann ebenso wie für die Modifizierer `out` und `ref` kein Boxing durchgeführt werden, da der `in`-Modifizierer angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="1938a-204">Like the `out` and `ref` modifiers, value types aren't boxed because the `in` modifier is applied.</span></span>

<span data-ttu-id="1938a-205">Der Modifizierer `in` kann auf einen beliebigen Member angewendet werden, der Parameter akzeptiert: Methoden, Delegaten, Lambdas, lokale Funktionen, Indexer, Operatoren.</span><span class="sxs-lookup"><span data-stu-id="1938a-205">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="1938a-206">Von `in`-Parametern wird ein weiteres Feature bereitgestellt, durch das Sie Literalwerte oder Konstanten als Argument für einen `in`-Parameter verwenden können.</span><span class="sxs-lookup"><span data-stu-id="1938a-206">Another feature of `in` parameters is that you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="1938a-207">Außerdem müssen Sie im Gegensatz zu einem `ref`- oder `out`-Parameter den Modifizierer `in` nicht an der Aufrufsite anwenden.</span><span class="sxs-lookup"><span data-stu-id="1938a-207">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="1938a-208">Der folgende Code zeigt zwei Beispiele zum Aufruf der `CalculateDistance`-Methode.</span><span class="sxs-lookup"><span data-stu-id="1938a-208">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="1938a-209">Im ersten Beispiel werden zwei lokale Variablen als Verweis übergeben.</span><span class="sxs-lookup"><span data-stu-id="1938a-209">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="1938a-210">Im zweiten Beispiel wird als Teil des Methodenaufrufs eine temporäre Variable erstellt.</span><span class="sxs-lookup"><span data-stu-id="1938a-210">The second includes a temporary variable created as part of the method call.</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="1938a-211">Der Compiler kann auf verschiedene Weise den Schreibschutz eines `in`-Arguments erzwingen.</span><span class="sxs-lookup"><span data-stu-id="1938a-211">There are several ways in which the compiler enforces the read-only nature of an `in` argument.</span></span>  <span data-ttu-id="1938a-212">Zunächst kann die aufgerufene Methode nicht direkt einem `in`-Parameter zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-212">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="1938a-213">Eine direkte Zuweisung zu einem Feld eines `in`-Parameters ist nicht möglich, wenn dieser Wert vom Typ `struct` ist.</span><span class="sxs-lookup"><span data-stu-id="1938a-213">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="1938a-214">Außerdem können Sie keinen `in`-Parameter an eine Methode übergeben, die den Modifizierer `ref` oder `out` verwendet.</span><span class="sxs-lookup"><span data-stu-id="1938a-214">In addition, you can't pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="1938a-215">Diese Regeln gelten für jedes Feld eines `in`-Parameters, falls das Feld vom Typ `struct` und auch der Parameter vom Typ `struct` ist.</span><span class="sxs-lookup"><span data-stu-id="1938a-215">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="1938a-216">Tatsächlich gelten diese Regeln für mehrere Memberzugriffsebenen, falls die Typen auf allen Ebenen `structs` sind.</span><span class="sxs-lookup"><span data-stu-id="1938a-216">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span>
<span data-ttu-id="1938a-217">Der Compiler erzwingt, dass `struct`-Typen als `in`-Argumente übergeben werden und deren `struct`-Member schreibgeschützte Variablen sind, wenn sie als Argumente an anderen Methoden übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-217">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="1938a-218">Durch die Verwendung von `in`-Parametern können potenzielle Leistungseinbußen vermieden werden, die durch Kopiervorgänge entstehen.</span><span class="sxs-lookup"><span data-stu-id="1938a-218">The use of `in` parameters can avoid the potential performance costs of making copies.</span></span> <span data-ttu-id="1938a-219">Die Semantik eines Methodenaufrufs ändert sich hierdurch nicht.</span><span class="sxs-lookup"><span data-stu-id="1938a-219">It doesn't change the semantics of any method call.</span></span> <span data-ttu-id="1938a-220">Aus diesem Grund müssen Sie nicht den `in`-Modifizierer an der Aufrufstelle angeben.</span><span class="sxs-lookup"><span data-stu-id="1938a-220">Therefore, you don't need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="1938a-221">Wenn Sie den `in`-Modifizierer an der Aufrufstelle weglassen, wird dem Compiler mitgeteilt, dass es aus folgenden Gründen zulässig ist, eine Kopie des Arguments zu erstellen:</span><span class="sxs-lookup"><span data-stu-id="1938a-221">Omitting the `in` modifier at the call site informs the compiler that it's allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="1938a-222">Ein Argumenttyp wird implizit in einen Parametertyp konvertiert; eine Identitätskonvertierung findet jedoch nicht statt.</span><span class="sxs-lookup"><span data-stu-id="1938a-222">There exists an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="1938a-223">Das Argument ist ein Ausdruck, verfügt jedoch nicht über eine bekannte Speichervariable.</span><span class="sxs-lookup"><span data-stu-id="1938a-223">The argument is an expression but doesn't have a known storage variable.</span></span>
- <span data-ttu-id="1938a-224">Eine überladene Methode unterscheidet sich nur durch die (fehlende) Angabe von `in`.</span><span class="sxs-lookup"><span data-stu-id="1938a-224">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="1938a-225">In diesem Fall wird die überladene Methode verwendet, für die Argumente als Wert übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-225">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="1938a-226">Diese Regeln sind nützlich, wenn Sie vorhandenen Code anpassen und schreibgeschützte Verweisargumente verwenden.</span><span class="sxs-lookup"><span data-stu-id="1938a-226">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="1938a-227">In der aufgerufenen Methode können Sie alle Instanzmethoden aufrufen, die als Wert übergebene Parameter verwendet.</span><span class="sxs-lookup"><span data-stu-id="1938a-227">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="1938a-228">In diesen Instanzen wird eine Kopie des `in`-Parameters erstellt.</span><span class="sxs-lookup"><span data-stu-id="1938a-228">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="1938a-229">Da der Compiler eine temporäre Variable für jeden `in`-Parameter erstellen kann, können Sie auch Standardwerte für jeden `in`-Parameter angeben.</span><span class="sxs-lookup"><span data-stu-id="1938a-229">Because the compiler may create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="1938a-230">Im folgenden Codebeispiel wird der Ursprung (Punkt 0,0) als Standardwert für den zweiten Punkt verwendet:</span><span class="sxs-lookup"><span data-stu-id="1938a-230">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="1938a-231">Wenn der Compiler dazu gezwungen werden soll, schreibgeschützte Argumente als Verweis zu übergeben, müssen Sie wie im folgenden Beispiel gezeigt den `in`-Modifizierer für Argumente an der Aufrufstelle angeben:</span><span class="sxs-lookup"><span data-stu-id="1938a-231">To force the compiler to pass read-only arguments by reference, specify the `in` modifier on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="1938a-232">Durch dieses Verhalten können `in`-Parameter leichter über einen gewissen Zeitraum in große Codebasen, in denen Leistungssteigerungen möglich sind, eingeführt werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-232">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="1938a-233">Zuerst fügen Sie den `in`-Modifizierer den Methodensignaturen hinzu.</span><span class="sxs-lookup"><span data-stu-id="1938a-233">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="1938a-234">Anschließend ergänzen Sie die Aufrufstellen um den `in`-Modifizierer und erstellen `readonly struct`-Typen, damit der Compiler keine defensive Kopien von `in`-Parametern an mehreren Speicherorten erstellt.</span><span class="sxs-lookup"><span data-stu-id="1938a-234">Then, you can add the `in` modifier at call sites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="1938a-235">Der Parameter `in` kann auch mit Verweistypen oder numerischen Werten verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-235">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="1938a-236">Allerdings sind die Vorteile in beiden Fällen – wenn überhaupt – nur minimal.</span><span class="sxs-lookup"><span data-stu-id="1938a-236">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="never-use-mutable-structs-as-in-in-argument"></a><span data-ttu-id="1938a-237">Vermeiden von veränderlichen Strukturen als `in`-Argumente</span><span class="sxs-lookup"><span data-stu-id="1938a-237">Never use mutable structs as in `in` argument</span></span>

<span data-ttu-id="1938a-238">In den bisher beschriebenen Strategien wurde erläutert, wie sich Kopien durch die Rückgabe von Verweisen und die Übergabe von Werten als Verweis vermeiden lassen.</span><span class="sxs-lookup"><span data-stu-id="1938a-238">The techniques described above explain how to avoid copies by returning references and passing values by reference.</span></span> <span data-ttu-id="1938a-239">Diese Vorgehensweisen sind ideal für Argumenttypen, die mit `readonly struct` deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-239">These techniques work best when the argument types are declared as `readonly struct` types.</span></span> <span data-ttu-id="1938a-240">Wenn dies nicht der Fall ist, muss der Compiler in vielen Situationen **defensive Kopien** erstellen, um den Schreibschutz von Argumenten zu erzwingen.</span><span class="sxs-lookup"><span data-stu-id="1938a-240">Otherwise, the compiler must create **defensive copies** in many situations to enforce the readonly-ness of any arguments.</span></span> <span data-ttu-id="1938a-241">Betrachten Sie das folgende Beispiel, in dem im dreidimensionalen Raum der Abstand eines Punkts vom Ursprung berechnet wird:</span><span class="sxs-lookup"><span data-stu-id="1938a-241">Consider the following example that calculates the distance of a 3D point from the origin:</span></span>

[!code-csharp[InArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="1938a-242">Die `Point3D`-Struktur ist *keine* schreibgeschützte Struktur.</span><span class="sxs-lookup"><span data-stu-id="1938a-242">The `Point3D` structure is *not* a readonly struct.</span></span> <span data-ttu-id="1938a-243">Im Methodenkörper werden sechs Aufrufe zum Zugriff auf die Eigenschaften ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="1938a-243">There are six different property access calls in the body of this method.</span></span> <span data-ttu-id="1938a-244">Diese Zugriffe erscheinen möglicherweise auf den ersten Blick sicher.</span><span class="sxs-lookup"><span data-stu-id="1938a-244">On first examination, you may have thought these accesses were safe.</span></span> <span data-ttu-id="1938a-245">Die `get`-Zugriffsmethode sollte schließlich nicht den Zustand eines Objekts ändern.</span><span class="sxs-lookup"><span data-stu-id="1938a-245">After all, a `get` accessor shouldn't modify the state of the object.</span></span> <span data-ttu-id="1938a-246">Dies wird jedoch von keiner Programmiersprachregel erzwungen.</span><span class="sxs-lookup"><span data-stu-id="1938a-246">But there's no language rule that enforces that.</span></span> <span data-ttu-id="1938a-247">Es handelt sich nur um eine Konvention.</span><span class="sxs-lookup"><span data-stu-id="1938a-247">It's only a common convention.</span></span> <span data-ttu-id="1938a-248">Jeder Typ könnte eine `get`-Zugriffsmethode implementieren, die den internen Zustand ändert.</span><span class="sxs-lookup"><span data-stu-id="1938a-248">Any type could implement a `get` accessor that modified the internal state.</span></span> <span data-ttu-id="1938a-249">Ohne eine Garantie der Programmiersprache muss der Compiler eine temporäre Kopie des Arguments erstellen, bevor er einen Member aufruft.</span><span class="sxs-lookup"><span data-stu-id="1938a-249">Without some language guarantee, the compiler must create a temporary copy of the argument before calling any member.</span></span> <span data-ttu-id="1938a-250">Der temporäre Speicher wird auf dem Stapel erstellt, die Werte des Arguments werden in den temporären Speicher kopiert, und der Wert wird bei jedem Memberzugriff als `this`-Argument in den Stapel kopiert.</span><span class="sxs-lookup"><span data-stu-id="1938a-250">The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the `this` argument.</span></span> <span data-ttu-id="1938a-251">In vielen Situationen beeinträchtigen die Kopien die Leistung so, dass die Übergabe als Wert schneller als die Übergabe als schreibgeschützter Verweis ist, wenn der Argumenttyp nicht `readonly struct` ist.</span><span class="sxs-lookup"><span data-stu-id="1938a-251">In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a `readonly struct`.</span></span>

<span data-ttu-id="1938a-252">Wenn stattdessen zur Abstandsberechnung die unveränderliche Struktur `ReadonlyPoint3D` verwendet wird, werden temporäre Objekte nicht benötigt:</span><span class="sxs-lookup"><span data-stu-id="1938a-252">Instead, if the distance calculation uses the immutable struct, `ReadonlyPoint3D`, temporary objects aren't needed:</span></span>

[!code-csharp[readonlyInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ReadOnlyInArgument "Specifying a readonly in argument")]

<span data-ttu-id="1938a-253">Der Compiler generiert effizienteren Code, wenn Member vom Typ `readonly struct` aufgerufen werden: Im Gegensatz zur Kopie des Empfängers ist der `this`-Verweis immer ein `in`-Parameter, der als Verweis der Membermethode übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="1938a-253">The compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="1938a-254">Durch diese Optimierung werden Kopien vermieden, wenn Sie `readonly struct` als `in`-Argument verwenden.</span><span class="sxs-lookup"><span data-stu-id="1938a-254">This optimization saves copying when you use a `readonly struct` as an `in` argument.</span></span>

<span data-ttu-id="1938a-255">Übergeben Sie keinen Nullwerte zulassenden Typ als ein `in`-Argument.</span><span class="sxs-lookup"><span data-stu-id="1938a-255">You shouldn't pass a nullable value type as an `in` argument.</span></span> <span data-ttu-id="1938a-256">Der Typ <xref:System.Nullable%601> ist nicht als schreibgeschützte Struktur deklariert.</span><span class="sxs-lookup"><span data-stu-id="1938a-256">The <xref:System.Nullable%601> type isn't declared as a read-only struct.</span></span> <span data-ttu-id="1938a-257">Dies bedeutet, dass der Compiler defensive Kopien für jedes Nullwerte zulassende Typargument generieren muss, das einer Methode mit dem `in`-Modifizierer in der Parameterdeklaration übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="1938a-257">That means the compiler must generate defensive copies for any nullable value type argument passed to a method using the `in` modifier on the parameter declaration.</span></span>

<span data-ttu-id="1938a-258">Im [Beispielrepository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) auf GitHub finden Sie ein Beispielprogramm, das die Leistungsunterschiede mithilfe von [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1938a-258">You can see an example program that demonstrates the performance differences using [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub.</span></span> <span data-ttu-id="1938a-259">Dabei wird die Übergabe einer veränderlichen Struktur als Wert und Verweis mit der Übergabe einer unveränderlichen Struktur als Wert und Verweis verglichen.</span><span class="sxs-lookup"><span data-stu-id="1938a-259">It compares passing a mutable struct by value and by reference with passing an immutable struct by value and by reference.</span></span> <span data-ttu-id="1938a-260">Am schnellsten ist die Übergabe einer unveränderlichen Struktur als Verweis.</span><span class="sxs-lookup"><span data-stu-id="1938a-260">The use of the immutable struct and pass by reference is fastest.</span></span>

## <a name="use-ref-struct-types-to-work-with-blocks-or-memory-on-a-single-stack-frame"></a><span data-ttu-id="1938a-261">Verwenden von `ref struct`-Typen als Speicherblöcke für einzelne Stapelrahmen</span><span class="sxs-lookup"><span data-stu-id="1938a-261">Use `ref struct` types to work with blocks or memory on a single stack frame</span></span>

<span data-ttu-id="1938a-262">Ein zugehöriges Sprachfeature ist die Möglichkeit, einen Werttyp zu deklarieren, der auf einen einzelnen Stapelrahmen beschränkt ist.</span><span class="sxs-lookup"><span data-stu-id="1938a-262">A related language feature is the ability to declare a value type that must be constrained to a single stack frame.</span></span> <span data-ttu-id="1938a-263">Durch die Einschränkung kann der Compiler mehrere Optimierungen vornehmen.</span><span class="sxs-lookup"><span data-stu-id="1938a-263">This restriction enables the compiler to make several optimizations.</span></span> <span data-ttu-id="1938a-264">Der primäre Beweggrund für dieses Feature waren <xref:System.Span%601> und zugehörige Strukturen.</span><span class="sxs-lookup"><span data-stu-id="1938a-264">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="1938a-265">Wenn Sie die neuen und aktualisierten .NET-APIs verwenden, in denen der <xref:System.Span%601>-Typ verwendet wird, werden Sie Leistungsverbesserungen erzielen, die diese Optimierungen mit sich bringen.</span><span class="sxs-lookup"><span data-stu-id="1938a-265">You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <xref:System.Span%601> type.</span></span>

<span data-ttu-id="1938a-266">Möglicherweise haben Sie ähnliche Anforderungen, wenn Sie mit Speicher arbeiten, der mit [`stackalloc`](language-reference/operators/stackalloc.md) erstellt wurde, oder wenn Sie Speicher aus Interop-APIs verwenden.</span><span class="sxs-lookup"><span data-stu-id="1938a-266">You may have similar requirements working with memory created using [`stackalloc`](language-reference/operators/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="1938a-267">Sie können für diese Anforderungen eigene `ref struct`-Typen definieren.</span><span class="sxs-lookup"><span data-stu-id="1938a-267">You can define your own `ref struct` types for those needs.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="1938a-268">`readonly ref struct`-Typ</span><span class="sxs-lookup"><span data-stu-id="1938a-268">`readonly ref struct` type</span></span>

<span data-ttu-id="1938a-269">Das Deklarieren einer Struktur als `readonly ref` vereint die Vorteile und Einschränkungen der `ref struct`- und `readonly struct`-Deklarationen.</span><span class="sxs-lookup"><span data-stu-id="1938a-269">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> <span data-ttu-id="1938a-270">Der von der schreibgeschützten Span-Struktur verwendete Speicher ist auf einen einzelnen Stapelrahmen beschränkt und kann nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="1938a-270">The memory used by the readonly span is restricted to a single stack frame, and the memory used by the readonly span can't be modified.</span></span>

## <a name="conclusions"></a><span data-ttu-id="1938a-271">Zusammenfassung</span><span class="sxs-lookup"><span data-stu-id="1938a-271">Conclusions</span></span>

<span data-ttu-id="1938a-272">Durch das Verwenden von Werttypen wird die Anzahl der Speicherbelegungen minimiert:</span><span class="sxs-lookup"><span data-stu-id="1938a-272">Using value types minimizes the number of allocation operations:</span></span>

- <span data-ttu-id="1938a-273">Speicher für Werttypen wird für lokale Variablen und Methodenargumente auf dem Stapel belegt.</span><span class="sxs-lookup"><span data-stu-id="1938a-273">Storage for value types is stack allocated for local variables and method arguments.</span></span>
- <span data-ttu-id="1938a-274">Speicher für Werttypen, die Member von anderen Objekten sind, wird als Teil dieses Objekts belegt. Eine separate Speicherbelegung findet nicht statt.</span><span class="sxs-lookup"><span data-stu-id="1938a-274">Storage for value types that are members of other objects is allocated as part of that object, not as a separate allocation.</span></span>
- <span data-ttu-id="1938a-275">Speicher für Rückgabewerte des Werttyps wird auf dem Stapel belegt.</span><span class="sxs-lookup"><span data-stu-id="1938a-275">Storage for value type return values is stack allocated.</span></span>

<span data-ttu-id="1938a-276">Für Verweistypen ist in denselben Situationen ein anderes Verhalten zu beobachten:</span><span class="sxs-lookup"><span data-stu-id="1938a-276">Contrast that with reference types in those same situations:</span></span>

- <span data-ttu-id="1938a-277">Speicher für Verweistypen wird für lokale Variablen und Argumente auf dem Heap belegt.</span><span class="sxs-lookup"><span data-stu-id="1938a-277">Storage for reference types are heap allocated for local variables and method arguments.</span></span> <span data-ttu-id="1938a-278">Der Verweis wird auf dem Stapel gespeichert.</span><span class="sxs-lookup"><span data-stu-id="1938a-278">The reference is stored on the stack.</span></span>
- <span data-ttu-id="1938a-279">Speicher für Werttypen, die Member von anderen Objekten sind, wird separat belegt.</span><span class="sxs-lookup"><span data-stu-id="1938a-279">Storage for reference types that are members of other objects are separately allocated on the heap.</span></span> <span data-ttu-id="1938a-280">Das enthaltende Objekt speichert den Verweis.</span><span class="sxs-lookup"><span data-stu-id="1938a-280">The containing object stores the reference.</span></span>
- <span data-ttu-id="1938a-281">Speicher für Rückgabewerte des Verweistyps wird auf dem Heap belegt.</span><span class="sxs-lookup"><span data-stu-id="1938a-281">Storage for reference type return values is heap allocated.</span></span> <span data-ttu-id="1938a-282">Der Verweis auf den Speicher wird auf dem Stapel gespeichert.</span><span class="sxs-lookup"><span data-stu-id="1938a-282">The reference to that storage is stored on the stack.</span></span>

<span data-ttu-id="1938a-283">Das Minimieren von Speicherbelegungen hat auch Nachteile.</span><span class="sxs-lookup"><span data-stu-id="1938a-283">Minimizing allocations comes with tradeoffs.</span></span> <span data-ttu-id="1938a-284">Wenn die Größe des `struct`-Typs die des Verweises übersteigt, wird mehr Speicher kopiert.</span><span class="sxs-lookup"><span data-stu-id="1938a-284">You copy more memory when the size of the `struct` is larger than the size of a reference.</span></span> <span data-ttu-id="1938a-285">Ein Verweis ist in der Regel 64 Bit oder 32 Bit lang und von der CPU des Zielcomputers abhängig.</span><span class="sxs-lookup"><span data-stu-id="1938a-285">A reference is typically 64 bits or 32 bits, and depends on the target machine CPU.</span></span>

<span data-ttu-id="1938a-286">Diese Nachteile wirken sich in der Regel nur minimal auf die Leistung aus.</span><span class="sxs-lookup"><span data-stu-id="1938a-286">These tradeoffs generally have minimal performance impact.</span></span> <span data-ttu-id="1938a-287">Bei größeren Strukturen oder Sammlungen können jedoch höhere Leistungseinbußen auftreten.</span><span class="sxs-lookup"><span data-stu-id="1938a-287">However, for large structs or larger collections, the performance impact increases.</span></span> <span data-ttu-id="1938a-288">In Programmen können die Auswirkungen bei kurzen Schleifen und langsamen Pfaden gravierend sein.</span><span class="sxs-lookup"><span data-stu-id="1938a-288">The impact can be large in tight loops and hot paths for programs.</span></span>

<span data-ttu-id="1938a-289">Diese Erweiterungen von C# wurden für leistungskritische Algorithmen entwickelt, bei denen die Minimierung von Speicherbelegungen entscheidend ist, um die erforderliche Leistung zu erzielen.</span><span class="sxs-lookup"><span data-stu-id="1938a-289">These enhancements to the C# language are designed for performance critical algorithms where minimizing memory allocations is a major factor in achieving the necessary performance.</span></span> <span data-ttu-id="1938a-290">Sie werden feststellen, dass Sie diese Features möglicherweise nicht oft in dem Code verwenden, den Sie schreiben.</span><span class="sxs-lookup"><span data-stu-id="1938a-290">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="1938a-291">Die Verbesserungen wurden jedoch global in .NET umgesetzt.</span><span class="sxs-lookup"><span data-stu-id="1938a-291">However, these enhancements have been adopted throughout .NET.</span></span> <span data-ttu-id="1938a-292">Da immer mehr APIs diese Features nutzen, werden Sie feststellen, dass sich die Leistung Ihrer Anwendungen verbessert.</span><span class="sxs-lookup"><span data-stu-id="1938a-292">As more and more APIs make use of these features, you'll see the performance of your applications improve.</span></span>

## <a name="see-also"></a><span data-ttu-id="1938a-293">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="1938a-293">See also</span></span>

- [<span data-ttu-id="1938a-294">ref (C#-Referenz)</span><span class="sxs-lookup"><span data-stu-id="1938a-294">ref keyword</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="1938a-295">Ref-Rückgabetypen und lokale ref-Variablen</span><span class="sxs-lookup"><span data-stu-id="1938a-295">Ref returns and ref locals</span></span>](programming-guide/classes-and-structs/ref-returns.md)
