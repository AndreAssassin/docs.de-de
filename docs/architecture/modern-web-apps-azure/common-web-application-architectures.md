---
title: Häufig verwendete Webanwendungsarchitekturen
description: Entwerfen moderner Webanwendungen mit ASP.NET Core und Azure | Häufig verwendete Webanwendungsarchitekturen
author: ardalis
ms.author: wiwagn
ms.date: 01/30/2019
ms.openlocfilehash: 22cb673f09faf7b0eabcfa5b3f6700d33242d84b
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 07/30/2019
ms.locfileid: "68675377"
---
# <a name="common-web-application-architectures"></a><span data-ttu-id="eda45-103">Häufig verwendete Webanwendungsarchitekturen</span><span class="sxs-lookup"><span data-stu-id="eda45-103">Common web application architectures</span></span>

> <span data-ttu-id="eda45-104">„Wenn Sie denken, dass eine gute Architektur viel Geld kostet, dann haben Sie noch nicht mit einer schlechten gearbeitet.“</span><span class="sxs-lookup"><span data-stu-id="eda45-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="eda45-105">_– Brian Foote und Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="eda45-105">_- Brian Foote and Joseph Yoder_</span></span>

<span data-ttu-id="eda45-106">Die meisten herkömmlichen .NET-Anwendungen werden als einzelne Einheiten bereitgestellt, die einer ausführbaren Datei oder einer Webanwendung entsprechen, die innerhalb einer IIS-Anwendungsdomäne ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="eda45-106">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="eda45-107">Dabei handelt es sich um das wohl einfachste Bereitstellungsmodell, das sich gut für interne und kleinere öffentliche Anwendungen eignet.</span><span class="sxs-lookup"><span data-stu-id="eda45-107">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="eda45-108">Allerdings eignet sich für die meisten wichtigen Geschäftsanwendungen sogar mit dieser einzelnen Bereitstellungseinheit die logische Unterteilung in mehrere Schichten.</span><span class="sxs-lookup"><span data-stu-id="eda45-108">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="eda45-109">Was sind monolithische Anwendungen?</span><span class="sxs-lookup"><span data-stu-id="eda45-109">What is a monolithic application?</span></span>

<span data-ttu-id="eda45-110">Monolithische Anwendungen sind in Bezug auf ihr Verhalten vollkommen unabhängig.</span><span class="sxs-lookup"><span data-stu-id="eda45-110">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="eda45-111">Sie interagieren zwar möglichweise mit anderen Diensten oder Datenspeichern, während sie Vorgänge ausführen, aber der Hauptbestandteil ihres Verhaltens liegt in ihren eigenen Prozessen, und die gesamte Anwendung wird in der Regel als einzelne Einheit bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="eda45-111">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="eda45-112">Wenn eine solche Anwendung eine horizontale Skalierung vornehmen muss, wird in der Regel die gesamte Anwendung auf mehreren Servern oder virtuellen Computern dupliziert.</span><span class="sxs-lookup"><span data-stu-id="eda45-112">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="eda45-113">All-in-One-Anwendungen</span><span class="sxs-lookup"><span data-stu-id="eda45-113">All-in-one applications</span></span>

<span data-ttu-id="eda45-114">Jede Anwendungsarchitektur muss mindestens ein Projekt umfassen.</span><span class="sxs-lookup"><span data-stu-id="eda45-114">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="eda45-115">In dieser Architektur ist die gesamte Logik der Anwendung in nur einem Projekt enthalten. Außerdem wird sie in nur eine Assembly kompiliert und als einzelne Einheit bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="eda45-115">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="eda45-116">Wenn ein neues ASP.NET Core-Projekt erstellt wird, stellt dieses anfangs immer einen All-in-One-Monolith dar. Dabei macht es keinen Unterschied, ob es über Visual Studio oder die Befehlszeile erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="eda45-116">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="eda45-117">Dieser Monolith enthält das gesamte Verhalten der Anwendung, einschließlich der Darstellungs-, Geschäfts- und Datenzugriffslogik.</span><span class="sxs-lookup"><span data-stu-id="eda45-117">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="eda45-118">In Abbildung 5-1 wird die Dateistruktur einer App dargestellt, die aus einem Projekt besteht.</span><span class="sxs-lookup"><span data-stu-id="eda45-118">Figure 5-1 shows the file structure of a single-project app.</span></span>

![](./media/image5-1.png)

<span data-ttu-id="eda45-119">**Abbildung 5-1.**</span><span class="sxs-lookup"><span data-stu-id="eda45-119">**Figure 5-1.**</span></span> <span data-ttu-id="eda45-120">Eine ASP.NET Core-App, die nur aus einem Projekt besteht.</span><span class="sxs-lookup"><span data-stu-id="eda45-120">A single project ASP.NET Core app.</span></span>

<span data-ttu-id="eda45-121">Wenn eine App nur aus einem Projekt besteht, wird das Prinzip „Separation of Concerns“ durch die Verwendung von Ordnern unterstützt.</span><span class="sxs-lookup"><span data-stu-id="eda45-121">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="eda45-122">Die Standardvorlage enthält separate Ordner für Verantwortlichkeiten von MVC-Mustern für Modelle, Ansichten und Controller sowie zusätzliche Ordner für Daten und Dienste.</span><span class="sxs-lookup"><span data-stu-id="eda45-122">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="eda45-123">Wenn Sie diese Vorlage verwenden, sollten Darstellunsgdetails weitestgehend auf den Ansichtenordner (Views) beschränkt sein, und Implementierungsdetails zum Datenzugriff sollten auf Klassen beschränkt sein, die im Datenordner (Data) gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-123">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="eda45-124">Die Geschäftslogik sollte in Diensten und Klassen gespeichert sein, die im Modellordner (Models) enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="eda45-124">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="eda45-125">Diese monolithische Projektmappe, die aus nur einem Projekt besteht, ist zwar sehr einfach strukturiert, weist aber auch einige Nachteile auf.</span><span class="sxs-lookup"><span data-stu-id="eda45-125">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="eda45-126">Wenn der Umfang des Projekts ausgeweitet wird, entstehen auch immer mehr Dateien und Ordner.</span><span class="sxs-lookup"><span data-stu-id="eda45-126">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="eda45-127">Elemente, die die Benutzeroberfläche (UI) betreffen (z.B. Modelle, Ansichten und Controller), sind in unterschiedlichen Ordnern gespeichert, die nicht gemeinsam in alphabetischer Reihenfolge sortiert sind.</span><span class="sxs-lookup"><span data-stu-id="eda45-127">User interface (UI) concerns (models, views, controllers) reside in multiple folders, which aren't grouped together alphabetically.</span></span> <span data-ttu-id="eda45-128">Dieses Problem wird noch größer, wenn zusätzliche Konstrukte auf Benutzeroberflächenebene wie Filter oder ModelBinders-Elemente zu ihren jeweiligen Ordnern hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-128">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="eda45-129">Die Geschäftslogik ist auf die Ordner „Models“ und „Services“ aufgeteilt, und es gibt keinen Anhaltspunkt dafür, welche Klassen in welchen Ordnern von welchen anderen Elementen abhängig sein sollen.</span><span class="sxs-lookup"><span data-stu-id="eda45-129">Business logic is scattered between the Models and Services folders, and there's no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="eda45-130">Dadurch, dass auf Projektebene keine Sortierung vorgenommen wird, wird der Code häufig unübersichtlich, und es entsteht sogenannter [Spaghetticode](https://deviq.com/spaghetti-code/).</span><span class="sxs-lookup"><span data-stu-id="eda45-130">This lack of organization at the project level frequently leads to [spaghetti code](https://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="eda45-131">Um diese Probleme zu umgehen, greifen Entwickler häufig auf die Möglichkeit zurück, Anwendungen in Projektmappen mit mehreren Projekten auszuweiten. In diesen Projektmappen ist dann jedes Projekt auf einer bestimmten _Schicht_ einer Anwendung gespeichert.</span><span class="sxs-lookup"><span data-stu-id="eda45-131">To address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular _layer_ of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="eda45-132">Was sind Schichten?</span><span class="sxs-lookup"><span data-stu-id="eda45-132">What are layers?</span></span>

<span data-ttu-id="eda45-133">Wenn eine Anwendung immer komplexer wird, können Sie dagegen vorgehen, indem Sie sie anhand ihrer Zuständigkeiten und Aufgaben aufteilen.</span><span class="sxs-lookup"><span data-stu-id="eda45-133">As applications grow in complexity, one way to manage that complexity is to break up the application according to its responsibilities or concerns.</span></span> <span data-ttu-id="eda45-134">Dieses Prinzip wird als „Separation of Concerns“ (Trennung von Belangen“ bezeichnet und hilft Ihnen dabei, die Codebasis zu ordnen, damit Sie problemlos feststellen können, an welcher Stelle bestimmte Funktionen implementiert wurden.</span><span class="sxs-lookup"><span data-stu-id="eda45-134">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="eda45-135">Die Strukturierung Ihres Codes ist aber nicht der einzige Vorteil einer aus Schichten bestehenden Architektur.</span><span class="sxs-lookup"><span data-stu-id="eda45-135">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="eda45-136">Wenn Sie Code in Schichten unterteilen, können häufig verwendete grundlegende Funktionen in der gesamten Anwendung wiederverwendet werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-136">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="eda45-137">Dies hat den Vorteil, dass Sie weniger Code schreiben müssen und die Anwendung für eine Implementierung standardisiert wird, was dem [Don‘t Repeat Yourself-Prinzip](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) entspricht.</span><span class="sxs-lookup"><span data-stu-id="eda45-137">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the [don't repeat yourself (DRY)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle.</span></span>

<span data-ttu-id="eda45-138">Wenn eine Architektur aus Schichten besteht, können Anwendungen Einschränkungen für die Kommunikation zwischen den einzelnen Schichten erzwingen.</span><span class="sxs-lookup"><span data-stu-id="eda45-138">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="eda45-139">Dies erleichtert die Kapselung.</span><span class="sxs-lookup"><span data-stu-id="eda45-139">This helps to achieve encapsulation.</span></span> <span data-ttu-id="eda45-140">Wenn eine Schicht geändert oder ersetzt wird, sollten nur die Schichten betroffen sein, die mit dieser zusammenarbeiten.</span><span class="sxs-lookup"><span data-stu-id="eda45-140">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="eda45-141">Wenn Sie einschränken, welche Schichten voneinander abhängig sind, können die Auswirkungen von Änderungen verringert werden, sodass eine einzige Änderung nicht die gesamte Anwendung betrifft.</span><span class="sxs-lookup"><span data-stu-id="eda45-141">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="eda45-142">Schichten (und die Kapselung) vereinfachen das Ersetzen von Funktionen innerhalb der Anwendung.</span><span class="sxs-lookup"><span data-stu-id="eda45-142">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="eda45-143">Möglicherweise verwendet z.B. eine Anwendung anfangs ihre eigene SQL Server-Datenbank als Persistenzspeicher. Sie können sich dann später aber immer noch dafür entscheiden, eine cloudbasierte Persistenzstrategie oder eine Web-API zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="eda45-143">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="eda45-144">Wenn die Anwendungen ihre Persistenzimplementierungen innerhalb einer logischen Schicht kapseln, kann diese SQL Server-spezifische Schicht durch eine neue Implementierung derselben öffentlichen Schnittstelle ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-144">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="eda45-145">Neben der Möglichkeit, Implementierungen auszutauschen, um möglichen zukünftigen Änderungen von Anforderungen vorzubeugen, können diese mithilfe von Anwendungsschichten auch zu Testzwecken ausgetauscht werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-145">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="eda45-146">Die Schichten können während der Tests durch falsche Implementierungen ersetzt werden, die bekannte Antworten auf Anforderungen bereitstellen, sodass Sie keine Tests mehr schreiben müssen, die mit der echten Daten- oder Benutzeroberflächenschicht der Anwendung arbeiten.</span><span class="sxs-lookup"><span data-stu-id="eda45-146">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="eda45-147">Dadurch können Tests einfacher geschrieben und im Vergleich zu Tests der echten Infrastruktur der Anwendung schneller ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-147">This typically makes tests much easier to write and much faster to run when compared to running tests against the application's real infrastructure.</span></span>

<span data-ttu-id="eda45-148">Das Erstellen logischer Schichten ist eine häufig verwendete Technik zum Verbessern der Strukturierung von Code in Unternehmensanwendungen. Es gibt mehrere Möglichkeiten, Code in Schichten zu strukturieren.</span><span class="sxs-lookup"><span data-stu-id="eda45-148">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
 > <span data-ttu-id="eda45-149">_Schichten_ stellen eine logische Unterteilung aller Bestandteile einer App dar.</span><span class="sxs-lookup"><span data-stu-id="eda45-149">_Layers_ represent logical separation within the application.</span></span> <span data-ttu-id="eda45-150">Wenn die Anwendungslogik physisch auf separate Server oder Prozesse verteilt wird, werden diese separaten Bereitstellunsgsziele als _Ebenen_ bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="eda45-150">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as _tiers_.</span></span> <span data-ttu-id="eda45-151">Die Verwendung einer Anwendung mit mehreren Schichten, die für eine einzelne Schicht bereitgestellt wird, ist möglich und wird häufig angewandt.</span><span class="sxs-lookup"><span data-stu-id="eda45-151">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="eda45-152">Traditionelle Architektur einer Anwendung mit mehreren Schichten</span><span class="sxs-lookup"><span data-stu-id="eda45-152">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="eda45-153">In Abbildung 5-2 wird die am häufigsten verwendete Unterteilung einer Anwendungslogik in Schichten dargestellt.</span><span class="sxs-lookup"><span data-stu-id="eda45-153">The most common organization of application logic into layers is shown in Figure 5-2.</span></span>

![](./media/image5-2.png)

<span data-ttu-id="eda45-154">**Abbildung 5-2.**</span><span class="sxs-lookup"><span data-stu-id="eda45-154">**Figure 5-2.**</span></span> <span data-ttu-id="eda45-155">Typische Anwendungsschichten</span><span class="sxs-lookup"><span data-stu-id="eda45-155">Typical application layers.</span></span>

<span data-ttu-id="eda45-156">Diese Schichten werden häufig mit den englischen Abkürzungen UI für User Interface (Benutzeroberfläche), BLL für Business Logic Layer (Schicht der Geschäftslogik) und DAL für Data Access Layer (Schicht für den Datenzugriff) bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="eda45-156">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="eda45-157">Wenn diese Architektur verwendet wird, senden Benutzer Anforderungen über die Benutzeroberflächenschicht, die nur mit der BLL interagiert.</span><span class="sxs-lookup"><span data-stu-id="eda45-157">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="eda45-158">Die BLL kann wiederum die DAL für Anforderungen hinsichtlich des Datenzugriffs aufrufen.</span><span class="sxs-lookup"><span data-stu-id="eda45-158">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="eda45-159">Die UI-Schicht sollte keine direkten Anforderungen an die DAL senden oder direkt mithilfe anderer Methoden mit der Persistenz interagieren.</span><span class="sxs-lookup"><span data-stu-id="eda45-159">The UI layer shouldn't make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="eda45-160">Gleichzeitig sollte die BLL nur über die DAL mit der Persistenz interagieren.</span><span class="sxs-lookup"><span data-stu-id="eda45-160">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="eda45-161">Auf diese Weise wird jeder Schicht eine individuelle bekannte Verantwortlichkeit zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="eda45-161">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="eda45-162">Dieser traditionelle Ansatz zum Erstellen von Schichten hat allerdings den Nachteil, dass Abhängigkeiten zur Kompilierzeit von oben nach unten ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-162">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="eda45-163">Das heißt, die UI-Schicht ist von der BLL abhängig, die wiederum von der DAL abhängig ist.</span><span class="sxs-lookup"><span data-stu-id="eda45-163">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="eda45-164">Das wiederum bedeutet, dass die BLL, die in der Regel die wichtigste Logik innerhalb der Anwendung aufweist, von den Implementierungsdetails zum Datenzugriff abhängig ist (und dadurch häufig auch eine Datenbank benötigt).</span><span class="sxs-lookup"><span data-stu-id="eda45-164">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="eda45-165">Das Testen einer Geschäftslogik in einer Architektur wie dieser gestaltet sich häufig als schwierig und erfordert eine Testdatenbank.</span><span class="sxs-lookup"><span data-stu-id="eda45-165">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="eda45-166">Sie können dieses Problem wie im nächsten Abschnitt beschrieben mit dem Dependency Inversion-Prinzip angehen.</span><span class="sxs-lookup"><span data-stu-id="eda45-166">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="eda45-167">In Abbildung 5-3 wird eine Projektmappe als Beispiel dargestellt, in der die Anwendung anhand von Zuständigkeiten bzw. Schichten in drei Projekte unterteilt wird.</span><span class="sxs-lookup"><span data-stu-id="eda45-167">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

![](./media/image5-3.png)

<span data-ttu-id="eda45-168">**Abbildung 5-3.**</span><span class="sxs-lookup"><span data-stu-id="eda45-168">**Figure 5-3.**</span></span> <span data-ttu-id="eda45-169">Eine einfache monolithische Anwendung mit drei Projekten</span><span class="sxs-lookup"><span data-stu-id="eda45-169">A simple monolithic application with three projects.</span></span>

<span data-ttu-id="eda45-170">Obwohl diese Anwendung aus Strukturierungsgründen mehrere Projekte verwendet, wird sie als einzelne Einheit bereitgestellt, und ihre Clients interagieren mit ihr wie mit einer einzelnen Web-App.</span><span class="sxs-lookup"><span data-stu-id="eda45-170">Although this application uses several projects for organizational purposes, it's still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="eda45-171">Dies vereinfacht die Bereitstellung.</span><span class="sxs-lookup"><span data-stu-id="eda45-171">This allows for very simple deployment process.</span></span> <span data-ttu-id="eda45-172">In Abbildung 5-4 wird dargestellt, wie eine solche App unter Verwendung von Azure gehostet werden kann.</span><span class="sxs-lookup"><span data-stu-id="eda45-172">Figure 5-4 shows how such an app might be hosted using Azure.</span></span>

![](./media/image5-4.png)

<span data-ttu-id="eda45-173">**Abbildung 5-4.**</span><span class="sxs-lookup"><span data-stu-id="eda45-173">**Figure 5-4.**</span></span> <span data-ttu-id="eda45-174">Einfache Bereitstellung einer Azure-Web-App</span><span class="sxs-lookup"><span data-stu-id="eda45-174">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="eda45-175">Wenn die Anforderungen an eine App höher werden, ist möglicherweise eine komplexere und robustere Bereitstellungslösung erforderlich.</span><span class="sxs-lookup"><span data-stu-id="eda45-175">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="eda45-176">In Abbildung 5-5 ist ein Beispiel einer komplexeren Bereitstellung dargestellt, die mehrere zusätzliche Funktionen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="eda45-176">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

<span data-ttu-id="eda45-177">**Abbildung 5-5.**</span><span class="sxs-lookup"><span data-stu-id="eda45-177">**Figure 5-5.**</span></span> <span data-ttu-id="eda45-178">Bereitstellen einer Web-App in Azure App Service</span><span class="sxs-lookup"><span data-stu-id="eda45-178">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="eda45-179">Innerhalb der Anwendung verbessert diese Unterteilung in mehrere Projekte anhand von Zuständigkeiten deren Verwaltbarkeit.</span><span class="sxs-lookup"><span data-stu-id="eda45-179">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="eda45-180">Diese Einheit kann zentral oder horizontal hochskaliert werden, um die cloudbasierte bedarfsgesteuerte Skalierbarkeit zu nutzen.</span><span class="sxs-lookup"><span data-stu-id="eda45-180">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="eda45-181">Beim zentralen Hochskalieren werden zusätzliche CPU, zusätzlicher Arbeitsspeicher, zusätzlicher Speicherplatz auf dem Datenträger oder andere Ressourcen zu dem Server bzw. den Servern hinzugefügt, der bzw. die Ihre App hosten.</span><span class="sxs-lookup"><span data-stu-id="eda45-181">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="eda45-182">Beim horizontalen Hochskalieren werden zusätzliche Instanzen solcher Server hinzugefügt. Dabei macht es keinen Unterschied, ob es sich um physische Server, virtuelle Computer oder Container handelt.</span><span class="sxs-lookup"><span data-stu-id="eda45-182">Scaling out means adding additional instances of such servers, whether these are physical servers, virtual machines, or containers.</span></span> <span data-ttu-id="eda45-183">Wenn Ihre App auf mehreren Instanzen gehostet wird, wird ein Lastenausgleich vorgenommen, um individuellen App-Instanzen Anforderungen zuzuweisen.</span><span class="sxs-lookup"><span data-stu-id="eda45-183">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="eda45-184">Der einfachste Ansatz zum Skalieren einer Webanwendung in Azure ist das manuelle Konfigurieren einer Skalierung im App Service-Plan der Anwendung.</span><span class="sxs-lookup"><span data-stu-id="eda45-184">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="eda45-185">In Abbildung 5-6 wird die Anzeige des Azure-Dashboards dargestellt, über die Sie konfigurieren können, wie viele Instanzen einer App zugrunde liegen.</span><span class="sxs-lookup"><span data-stu-id="eda45-185">Figure 5-6 shows the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

<span data-ttu-id="eda45-186">**Abbildung 5-6.**</span><span class="sxs-lookup"><span data-stu-id="eda45-186">**Figure 5-6.**</span></span> <span data-ttu-id="eda45-187">Skalieren des App Service-Plans in Azure</span><span class="sxs-lookup"><span data-stu-id="eda45-187">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="eda45-188">Clean Architecture</span><span class="sxs-lookup"><span data-stu-id="eda45-188">Clean architecture</span></span>

<span data-ttu-id="eda45-189">Anwendungen, die den Prinzipien der Abhängigkeitsumkehr und des domänengesteuerten Entwurfs (DDD) folgen, weisen alle eine ähnliche Architektur auf.</span><span class="sxs-lookup"><span data-stu-id="eda45-189">Applications that follow the Dependency Inversion Principle as well as the Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="eda45-190">Diese Architektur wurde in den vergangenen Jahren unterschiedlich benannt.</span><span class="sxs-lookup"><span data-stu-id="eda45-190">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="eda45-191">Zuerst wurde diese Architektur als „Hexagonal Architecture“ bezeichnet. Darauf folgte der Begriff „Ports-and-Adapters“.</span><span class="sxs-lookup"><span data-stu-id="eda45-191">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="eda45-192">Heutzutage spricht man aber eher von [Onion Architecture](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) bzw. [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="eda45-192">More recently, it's been cited as the [Onion Architecture](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="eda45-193">Der zweite Name, „Clean Architecture“, wird in diesem E-Book als Name dieser Architektur verwendet.</span><span class="sxs-lookup"><span data-stu-id="eda45-193">The latter name, Clean Architecture, is used as the name for this architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="eda45-194">Die Clean Architecture kann sowohl für Anwendungen erstellt werden, die dem DDD-Prinzip folgen, als auch für Anwendungen, die diesem nicht entsprechen.</span><span class="sxs-lookup"><span data-stu-id="eda45-194">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="eda45-195">Wenn das DDD-Prinzip angewendet wird, kann die Architektur als „Clean DDD Architecture“ bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-195">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="eda45-196">In der Clean Architecture sind die Geschäftslogik und das Anwendungsmodell im Kern der Anwendung enthalten.</span><span class="sxs-lookup"><span data-stu-id="eda45-196">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="eda45-197">Es wird dann das Prinzip Dependency Inversion angewendet, bei dem die Geschäftslogik nicht mehr vom Datenzugriff oder anderen Aufgaben, die die Infrastruktur betreffen, abhängig ist. Stattdessen sind die Informationen zur Infrastruktur und Implementierung vom Anwendungskern abhängig.</span><span class="sxs-lookup"><span data-stu-id="eda45-197">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="eda45-198">Dafür werden Abstraktionen oder Schnittstellen im Anwendungskern definiert und anschließend anhand von Typen implementiert, die in der Infrastrukturschicht definiert werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-198">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="eda45-199">Diese Architektur wird häufig in Kreisringen dargestellt, die dem Aufbau einer Zwiebel ähneln.</span><span class="sxs-lookup"><span data-stu-id="eda45-199">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="eda45-200">In Abbildung 5-7 ist ein Beispiel für die Darstellung der Architektur enthalten.</span><span class="sxs-lookup"><span data-stu-id="eda45-200">Figure 5-7 shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

<span data-ttu-id="eda45-201">**Abbildung 5-7.**</span><span class="sxs-lookup"><span data-stu-id="eda45-201">**Figure 5-7.**</span></span> <span data-ttu-id="eda45-202">Clean Architecture: „Zwiebelansicht“</span><span class="sxs-lookup"><span data-stu-id="eda45-202">Clean Architecture; onion view</span></span>

<span data-ttu-id="eda45-203">In diesem Diagramm beziehen sich alle Abhängigkeiten auf den inneren Kreisring, also auf den Anwendungskern.</span><span class="sxs-lookup"><span data-stu-id="eda45-203">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="eda45-204">Der Anwendungskern erhält seinen Namen aufgrund seiner Position im Zentrum des Diagramms.</span><span class="sxs-lookup"><span data-stu-id="eda45-204">The Application Core takes its name from its position at the core of this diagram.</span></span> <span data-ttu-id="eda45-205">Auf dem Diagramm können Sie auch sehen, dass der Anwendungskern über keine Abhängigkeiten von anderen Anwendungsschichten verfügt.</span><span class="sxs-lookup"><span data-stu-id="eda45-205">And you can see on the diagram that the Application Core has no dependencies on other application layers.</span></span> <span data-ttu-id="eda45-206">Die Entitäten und Schnittstellen der Anwendung stehen im Mittelpunkt.</span><span class="sxs-lookup"><span data-stu-id="eda45-206">The application's entities and interfaces are at the very center.</span></span> <span data-ttu-id="eda45-207">Domänendienste, die in der Regel Schnittstellen implementieren, die im inneren Kreisring definiert sind, befinden sich am äußeren Rand des Anwendungskerns.</span><span class="sxs-lookup"><span data-stu-id="eda45-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="eda45-208">Außerhalb des Anwendungskerns sind sowohl die Benutzeroberfläche als auch die Infrastrukturebenen zwar vom Anwendungskern, aber nicht (unbedingt) voneinander abhängig.</span><span class="sxs-lookup"><span data-stu-id="eda45-208">Outside of the Application Core, both the UI and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="eda45-209">In Abbildung 5-8 wird ein herkömmlicheres horizontales Schichtendiagramm dargestellt, das die Abhängigkeit zwischen Benutzeroberfläche und anderen Schichten besser darstellt.</span><span class="sxs-lookup"><span data-stu-id="eda45-209">Figure 5-8 shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

<span data-ttu-id="eda45-210">**Abbildung 5-8.**</span><span class="sxs-lookup"><span data-stu-id="eda45-210">**Figure 5-8.**</span></span> <span data-ttu-id="eda45-211">Clean Architecture: Ansicht mit horizontalen Schichten</span><span class="sxs-lookup"><span data-stu-id="eda45-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="eda45-212">Beachten Sie, dass die Pfeile mit durchgezogener Linie Abhängigkeiten zur Kompilierzeit darstellen. Die Pfeile mit gestrichelten Linien stellen Abhängigkeiten dar, die nur zur Laufzeit bestehen.</span><span class="sxs-lookup"><span data-stu-id="eda45-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="eda45-213">Unter Verwendung von Clean Architecture funktioniert die UI-Schicht nur mit Schnittstellen, die zur Kompilierzeit im Anwendungskern definiert werden. Im Idealfall sollten diese außerdem nicht über Informationen zu den in der Infrastrukturebene definierten Implementierungstypen verfügen.</span><span class="sxs-lookup"><span data-stu-id="eda45-213">With the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally shouldn't know about the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="eda45-214">Zur Laufzeit sind diese Implementierungstypen jedoch erforderlich, damit die App ausgeführt werden kann. Daher müssen sie definiert und über Dependency Injection mit den Schnittstellen des Anwendungskerns verbunden sein.</span><span class="sxs-lookup"><span data-stu-id="eda45-214">At run time, however, these implementation types are required for the app to execute, so they need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="eda45-215">In Abbildung 5-9 wird eine detailliertere Ansicht der Architektur einer ASP.NET Core-Anwendung dargestellt, die anhand dieser Empfehlungen erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="eda45-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![ASP.NET Core-Architektur](./media/image5-9.png)

<span data-ttu-id="eda45-217">**Abbildung 5-9.**</span><span class="sxs-lookup"><span data-stu-id="eda45-217">**Figure 5-9.**</span></span> <span data-ttu-id="eda45-218">Diagramm der ASP.NET Core-Architektur, die dem Prinzip der Clean Architecture folgt</span><span class="sxs-lookup"><span data-stu-id="eda45-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="eda45-219">Da der Anwendungskern nicht von der Infrastrukturebene abhängig ist, ist es leicht, automatisierte Komponententests für diese Schicht zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="eda45-219">Because the Application Core doesn't depend on Infrastructure, it's very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="eda45-220">In den Abbildungen 5-10 und 5-11 wird dargestellt, wie Tests mit dieser Architektur in Einklang gebracht werden können.</span><span class="sxs-lookup"><span data-stu-id="eda45-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="eda45-222">**Abbildung 5-10.**</span><span class="sxs-lookup"><span data-stu-id="eda45-222">**Figure 5-10.**</span></span> <span data-ttu-id="eda45-223">Isolierter Komponententest des Anwendungskerns</span><span class="sxs-lookup"><span data-stu-id="eda45-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="eda45-225">**Abbildung 5-11.**</span><span class="sxs-lookup"><span data-stu-id="eda45-225">**Figure 5-11.**</span></span> <span data-ttu-id="eda45-226">Integrationstest von Infrastrukturimplementierungen mit externen Abhängigkeiten</span><span class="sxs-lookup"><span data-stu-id="eda45-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="eda45-227">Da die UI-Schicht nicht über direkte Abhängigkeiten von im Infrastrukturprojekt definierten Typen verfügt, können Implementierungen leicht ausgetauscht werden. Dadurch kann das Testen vereinfacht werden, oder sich ändernde Anwendungsanforderungen lassen sich leichter umsetzen.</span><span class="sxs-lookup"><span data-stu-id="eda45-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it's likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="eda45-228">Durch die in ASP.NET Core integrierte Verwendung von und Unterstützung für Dependency Injection eignet sich diese Architektur besonders gut zum Strukturieren wichtiger monolithischer Anwendungen.</span><span class="sxs-lookup"><span data-stu-id="eda45-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="eda45-229">Bei monolithischen Anwendungen werden Projekte für den Anwendungskern, die Infrastruktur und die Benutzeroberfläche als einzelne Anwendung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="eda45-229">For monolithic applications the Application Core, Infrastructure, and UI projects are all run as a single application.</span></span> <span data-ttu-id="eda45-230">Die Anwendungsarchitektur zur Laufzeit sieht in etwa wie in Abbildung 5-12 dargestellt aus.</span><span class="sxs-lookup"><span data-stu-id="eda45-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASP.NET Core-Architektur 2](./media/image5-12.png)

<span data-ttu-id="eda45-232">**Abbildung 5-12.**</span><span class="sxs-lookup"><span data-stu-id="eda45-232">**Figure 5-12.**</span></span> <span data-ttu-id="eda45-233">Beispiel für die Laufzeitarchitektur einer ASP.NET Core-App</span><span class="sxs-lookup"><span data-stu-id="eda45-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="eda45-234">Strukturieren von Code anhand des Clean Architecture-Prinzips</span><span class="sxs-lookup"><span data-stu-id="eda45-234">Organizing code in Clean Architecture</span></span>

<span data-ttu-id="eda45-235">In einer gemäß der Clean Architecture erstellten Projektmappe verfügt jedes Projekt über klare Zuständigkeiten.</span><span class="sxs-lookup"><span data-stu-id="eda45-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="eda45-236">Daher gehören zu jedem Projekt bestimmte Typen, und häufig entsprechen Ordner im jeweiligen Projekt diesen Typen.</span><span class="sxs-lookup"><span data-stu-id="eda45-236">As such, certain types belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="eda45-237">Der Anwendungskern enthält das Geschäftsmodell, das wiederum Entitäten, Dienste und Schnittstellen umfasst.</span><span class="sxs-lookup"><span data-stu-id="eda45-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="eda45-238">Diese Schnittstellen umfassen Abstraktionen für Vorgänge, die unter Verwendung der Infrastruktur ausgeführt werden. Damit sind z.B. der Datenzugriff, der Zugriff auf Dateisysteme und Netzwerkaufrufe gemeint. Gelegentlich müssen für diese Schicht installierte Dienste und Schnittstellen mit Typen zusammenarbeiten, bei denen es sich nicht um Entitäten handelt und die nicht von der Benutzeroberfläche oder der Infrastruktur abhängig sind.</span><span class="sxs-lookup"><span data-stu-id="eda45-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="eda45-239">Diese Dienste und Schnittstellen können als einfache Datentransferobjekte (Data Transfer Objects, DTOs) definiert sein.</span><span class="sxs-lookup"><span data-stu-id="eda45-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

### <a name="application-core-types"></a><span data-ttu-id="eda45-240">Typen des Anwendungskerns</span><span class="sxs-lookup"><span data-stu-id="eda45-240">Application Core types</span></span>

- <span data-ttu-id="eda45-241">Entitäten (Klassen von Geschäftsmodellen, die dauerhaft gespeichert werden)</span><span class="sxs-lookup"><span data-stu-id="eda45-241">Entities (business model classes that are persisted)</span></span>
- <span data-ttu-id="eda45-242">Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="eda45-242">Interfaces</span></span>
- <span data-ttu-id="eda45-243">Dienste</span><span class="sxs-lookup"><span data-stu-id="eda45-243">Services</span></span>
- <span data-ttu-id="eda45-244">DTOs</span><span class="sxs-lookup"><span data-stu-id="eda45-244">DTOs</span></span>

<span data-ttu-id="eda45-245">Das Infrastrukturprojekt umfasst in der Regel Implementierungen für den Datenzugriff.</span><span class="sxs-lookup"><span data-stu-id="eda45-245">The Infrastructure project typically includes data access implementations.</span></span> <span data-ttu-id="eda45-246">In einer herkömmlichen ASP.NET Core-Webanwendung umfassen diese Implementierungen die Entity Framework-Klasse „DbContext“, jegliche `Migration`-Objekte von EF Core, die definiert wurden, und Klassen für die Implementierungen des Datenzugriffs.</span><span class="sxs-lookup"><span data-stu-id="eda45-246">In a typical ASP.NET Core web application, these implementations include the Entity Framework (EF) DbContext, any EF Core `Migration` objects that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="eda45-247">Die beste Möglichkeit, Implementierungscode für den Datenzugriff zu implementieren, stellt das [Entwurfsmuster Repository](https://deviq.com/repository-pattern/) dar.</span><span class="sxs-lookup"><span data-stu-id="eda45-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](https://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="eda45-248">Das Infrastrukturprojekt sollte neben Implementierungen für den Datenzugriff Implementierungen von Diensten enthalten, die mit verschiedenen Bestandteilen der Infrastruktur interagieren.</span><span class="sxs-lookup"><span data-stu-id="eda45-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="eda45-249">Diese Dienste sollten im Anwendungskern definierte Schnittstellen implementierten. Daher sollte im Infrastrukturprojekt ein Verweis auf das Anwendungskernprojekt enthalten sein.</span><span class="sxs-lookup"><span data-stu-id="eda45-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

### <a name="infrastructure-types"></a><span data-ttu-id="eda45-250">Typen der Infrastruktur</span><span class="sxs-lookup"><span data-stu-id="eda45-250">Infrastructure types</span></span>

- <span data-ttu-id="eda45-251">EF Core-Typen (`DbContext`, `Migration`)</span><span class="sxs-lookup"><span data-stu-id="eda45-251">EF Core types (`DbContext`, `Migration`)</span></span>
- <span data-ttu-id="eda45-252">Implementierungstypen für den Datenzugriff (Repositorys)</span><span class="sxs-lookup"><span data-stu-id="eda45-252">Data access implementation types (Repositories)</span></span>
- <span data-ttu-id="eda45-253">Infrastrukturspezifische Dienste (z.B. `FileLogger` oder `SmtpNotifier`)</span><span class="sxs-lookup"><span data-stu-id="eda45-253">Infrastructure-specific services (for example, `FileLogger` or `SmtpNotifier`)</span></span>

<span data-ttu-id="eda45-254">Die UI-Schicht in einer ASP.NET Core MVC-Anwendung stellt den Einstiegspunkt für die Anwendung dar.</span><span class="sxs-lookup"><span data-stu-id="eda45-254">The user interface layer in an ASP.NET Core MVC application is the entry point for the application.</span></span> <span data-ttu-id="eda45-255">Dieses Projekt sollte auf das Anwendungskernprojekt verweisen, und dessen Typen sollten ausschließlich über im Anwendungskern definierte Schnittstellen mit der Infrastruktur interagieren.</span><span class="sxs-lookup"><span data-stu-id="eda45-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="eda45-256">In der UI-Schicht sollten keine direkte Instanziierung oder statische Aufrufe von Typen von Infrastrukturebenen zugelassen werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-256">No direct instantiation of or static calls to the Infrastructure layer types should be allowed in the UI layer.</span></span>

### <a name="ui-layer-types"></a><span data-ttu-id="eda45-257">Typen der UI-Schicht</span><span class="sxs-lookup"><span data-stu-id="eda45-257">UI layer types</span></span>

- <span data-ttu-id="eda45-258">Controller</span><span class="sxs-lookup"><span data-stu-id="eda45-258">Controllers</span></span>
- <span data-ttu-id="eda45-259">Filter</span><span class="sxs-lookup"><span data-stu-id="eda45-259">Filters</span></span>
- <span data-ttu-id="eda45-260">Ansichten</span><span class="sxs-lookup"><span data-stu-id="eda45-260">Views</span></span>
- <span data-ttu-id="eda45-261">ViewModels</span><span class="sxs-lookup"><span data-stu-id="eda45-261">ViewModels</span></span>
- <span data-ttu-id="eda45-262">Start</span><span class="sxs-lookup"><span data-stu-id="eda45-262">Startup</span></span>

<span data-ttu-id="eda45-263">Die Startup-Klasse ist für das Konfigurieren von Anwendungen und für das Verknüpfen von Implementierungstypen mit Schnittstellen zuständig. Dadurch kann zur Laufzeit erfolgreich Dependency Injection angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="eda45-264">Wenn Sie Dependency Injection in ConfigureServices in der Startup.cs-Datei des UI-Projekts durchführen möchten, muss das Projekt möglicherweise auf das Infrastrukturprojekt verweisen.</span><span class="sxs-lookup"><span data-stu-id="eda45-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="eda45-265">Diese Abhängigkeit kann problemlos mithilfe eines benutzerdefinierten Dependency Injection-Containers entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="eda45-266">Im Hinblick auf das hier aufgeführte Beispiel ist es die einfachste Lösung, wenn Sie zulassen, dass das UI-Projekt auf das Infrastrukturprojekt verweist.</span><span class="sxs-lookup"><span data-stu-id="eda45-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="eda45-267">Monolithische Anwendungen und Container</span><span class="sxs-lookup"><span data-stu-id="eda45-267">Monolithic applications and containers</span></span>

<span data-ttu-id="eda45-268">Sie können eine einzelne, monolithisch bereitgestellte Webanwendung oder einen Webdienst erstellen und als Container bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="eda45-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="eda45-269">Die Anwendung ist in ihrem Inneren möglicherweise nicht monolithisch strukturiert, sondern in mehrere Bibliotheken, Komponenten oder Schichten unterteilt.</span><span class="sxs-lookup"><span data-stu-id="eda45-269">Within the application, it might not be monolithic but organized into several libraries, components, or layers.</span></span> <span data-ttu-id="eda45-270">Extern ist sie ein einzelner Container, z.B. ein einzelner Prozess, eine einzelne Webanwendung oder ein einzelner Dienst.</span><span class="sxs-lookup"><span data-stu-id="eda45-270">Externally, it's a single container like a single process, single web application, or single service.</span></span>

<span data-ttu-id="eda45-271">Stellen Sie einen einzelnen Container bereit, der diese Anwendung darstellt, um dieses Modell zu verwalten.</span><span class="sxs-lookup"><span data-stu-id="eda45-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="eda45-272">Fügen Sie zum Skalieren einfach weitere Kopien mit einem vorangestellten Lastenausgleich hinzu.</span><span class="sxs-lookup"><span data-stu-id="eda45-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="eda45-273">Die Einfachheit stammt aus der Verwaltung einer einzelnen Bereitstellung in einem einzelnen Container oder virtuellen Computer.</span><span class="sxs-lookup"><span data-stu-id="eda45-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="eda45-274">Sie können, wie in Abbildung 5-13 veranschaulicht, mehrere Komponenten, Bibliotheken oder interne Schichten in jeden Container einschließen.</span><span class="sxs-lookup"><span data-stu-id="eda45-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-13.</span></span> <span data-ttu-id="eda45-275">Allerdings kann dieses monolithische Muster zu einem Konflikt mit dem Containerprinzip _Jeder Container hat nur eine Aufgabe, die er in einem Prozess ausführt_ führen.</span><span class="sxs-lookup"><span data-stu-id="eda45-275">But, following the container principle of _"a container does one thing, and does it in one process_", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="eda45-276">Der Nachteil dieses Ansatzes wird offensichtlich, wenn die Anwendung wächst und skaliert werden muss.</span><span class="sxs-lookup"><span data-stu-id="eda45-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="eda45-277">Wenn die gesamte Anwendung skaliert werden kann, ist dies kein Problem.</span><span class="sxs-lookup"><span data-stu-id="eda45-277">If the entire application scales, it's not really a problem.</span></span> <span data-ttu-id="eda45-278">In den meisten Fällen stellen jedoch nur einige Teile der Anwendung Engpässe dar, die eine Skalierung erfordern, während andere Komponente weniger häufig verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="eda45-279">Wenn Sie das gewöhnliche eCommerce-Beispiel verwenden, müssen Sie sehr wahrscheinlich die Komponente für die Produktinformationen skalieren.</span><span class="sxs-lookup"><span data-stu-id="eda45-279">Using the typical eCommerce example, what you likely need to scale is the product information component.</span></span> <span data-ttu-id="eda45-280">Viele Kunden suchen Produkte erst und kaufen sie anschließend.</span><span class="sxs-lookup"><span data-stu-id="eda45-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="eda45-281">Mehr Kunden verwenden Ihren Warenkorb als die Zahlungspipeline.</span><span class="sxs-lookup"><span data-stu-id="eda45-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="eda45-282">Weniger Kunden fügen Kommentare hinzu oder zeigen ihren Bestellungsverlauf an.</span><span class="sxs-lookup"><span data-stu-id="eda45-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="eda45-283">Und Sie haben möglicherweise nur eine Handvoll Mitarbeiter in einer bestimmten Region, die den Inhalt und die Marketingkampagnen verwalten müssen.</span><span class="sxs-lookup"><span data-stu-id="eda45-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="eda45-284">Wenn der monolithische Entwurf skaliert wird, wird der gesamte Code mehrmals bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="eda45-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="eda45-285">Zusätzlich zu dem Problem, dass „alle Komponenten skaliert werden müssen“, erfordern Änderungen einer einzelnen Komponente einen erneuten Test der gesamten Anwendung und eine vollständige erneute Bereitstellung aller Instanzen.</span><span class="sxs-lookup"><span data-stu-id="eda45-285">In addition to the "scale everything" problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="eda45-286">Der monolithische Ansatz wird häufig verwendet, und viele Organisationen arbeiten mit dieser Architektur.</span><span class="sxs-lookup"><span data-stu-id="eda45-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="eda45-287">Viele von ihnen erzielen damit akzeptable Ergebnisse, aber andere stoßen an ihre Grenzen.</span><span class="sxs-lookup"><span data-stu-id="eda45-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="eda45-288">Viele Unternehmen haben ihre Anwendungen unter Verwendung dieses Modells entworfen, da Tools und Infrastruktur schon seit Jahren zu komplex für die Erstellung einer dienstorientierten Architektur (SOA) sind. Sie haben die Notwendigkeit nicht erkannt, etwas zu ändern, bis die Anwendung gewachsen ist.</span><span class="sxs-lookup"><span data-stu-id="eda45-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service-oriented architectures (SOA), and they didn't see the need until the app grew.</span></span> <span data-ttu-id="eda45-289">Wenn Sie an die Grenzen des monolithischen Ansatzes stoßen, ist der nächste logische Schritt das Aufteilen der App, damit diese Container und Microservices besser nutzen kann.</span><span class="sxs-lookup"><span data-stu-id="eda45-289">If you find you're hitting the limits of the monolithic approach, breaking up the app to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="eda45-290">Monolithische Anwendungen in Microsoft Azure können mithilfe von dedizierten VMs für jede Instanz bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="eda45-291">Sie können die VMs problemlos skalieren, wenn Sie [Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/) verwenden.</span><span class="sxs-lookup"><span data-stu-id="eda45-291">Using [Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="eda45-292">[Azure App Service](https://azure.microsoft.com/services/app-service/) kann auch monolithische Anwendungen ausführen und Instanzen problemlos skalieren, ohne dass die VMs verwaltet werden müssen.</span><span class="sxs-lookup"><span data-stu-id="eda45-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="eda45-293">Azure App Services kann ebenfalls einzelne Instanzen von Docker-Containern ausführen, was die Bereitstellung vereinfacht.</span><span class="sxs-lookup"><span data-stu-id="eda45-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="eda45-294">Wenn Sie Docker verwenden, können Sie eine einzelne VM als Docker-Host bereitstellen und mehrere Instanzen ausführen.</span><span class="sxs-lookup"><span data-stu-id="eda45-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="eda45-295">Wenn Sie wie in Abbildung 5-14 dargestellt den Azure Balancer verwenden, können Sie die Skalierung verwalten.</span><span class="sxs-lookup"><span data-stu-id="eda45-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="eda45-296">Die Bereitstellung auf den verschiedenen Hosts kann mit herkömmlichen Bereitstellungsverfahren verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="eda45-297">Docker-Hosts können manuell mit Befehlen wie **docker run** oder durch Automatisierung, z.B. Pipelines für Continuous Delivery (CD), verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="eda45-298">Monolithische Anwendung, die als Container bereitgestellt wird</span><span class="sxs-lookup"><span data-stu-id="eda45-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="eda45-299">Das Verwenden von Containern zur Verwaltung monolithischer Anwendungsbereitstellungen hat einige Vorteile.</span><span class="sxs-lookup"><span data-stu-id="eda45-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="eda45-300">Das Skalieren von Containerinstanzen ist wesentlich schneller und einfacher als die Bereitstellung zusätzlicher VMs.</span><span class="sxs-lookup"><span data-stu-id="eda45-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="eda45-301">Auch wenn Virtual Machine Scale Sets verwendet wird, um VMs zu skalieren, nimmt deren Instanziierung viel Zeit in Anspruch.</span><span class="sxs-lookup"><span data-stu-id="eda45-301">Even when using virtual machine scale sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="eda45-302">Wenn die App-Konfiguration als App-Instanz bereitgestellt wird, wird diese als Teil der VM verwaltet.</span><span class="sxs-lookup"><span data-stu-id="eda45-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="eda45-303">Die Bereitstellung von Updates, wie Docker-Images, ist wesentlich schneller und effizienter im Netzwerk.</span><span class="sxs-lookup"><span data-stu-id="eda45-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="eda45-304">Docker-Images starten in der Regel in Sekunden, wodurch Rollouts beschleunigt werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="eda45-305">Das Löschen einer Docker-Instanz ist genauso einfach wie das Ausführen eines `docker stop`-Befehls und in der Regel in weniger als einer Sekunde abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="eda45-305">Tearing down a Docker instance is as easy as issuing a `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="eda45-306">Da Container unveränderlich sind, müssen Sie sich keine Gedanken über beschädigte VMs machen. Es kann allerdings vorkommen, das Updateskripts bestimmte Konfigurationen oder restliche Dateien auf einem Datenträger erfassen.</span><span class="sxs-lookup"><span data-stu-id="eda45-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="eda45-307">Sie können Docker-Container für die monolithische Bereitstellung einfacherer Webanwendungen verwenden.</span><span class="sxs-lookup"><span data-stu-id="eda45-307">You can use Docker containers for monolithic deployment of simpler web applications.</span></span> <span data-ttu-id="eda45-308">Dies verbessert die fortlaufende Integration und die fortlaufenden Bereitstellungspipelines und unterstützt Sie bei der erfolgreichen Bereitstellung in der Produktion.</span><span class="sxs-lookup"><span data-stu-id="eda45-308">This improves continuous integration and continuous deployment pipelines and helps achieve deployment-to-production success.</span></span> <span data-ttu-id="eda45-309">Sie müssen sich nie wieder fragen, warum die Anwendung auf Ihrem Computer, aber nicht in der Produktion funktioniert.</span><span class="sxs-lookup"><span data-stu-id="eda45-309">No more “It works in my machine, why does it not work in production?”</span></span>

<span data-ttu-id="eda45-310">Eine auf Microservices basierende Architektur hat viele Vorteile, die jedoch eine erhöhte Komplexität mit sich bringen.</span><span class="sxs-lookup"><span data-stu-id="eda45-310">A microservices-based architecture has many benefits, but those benefits come at a cost of increased complexity.</span></span> <span data-ttu-id="eda45-311">In manchen Fällen überwiegen die Kosten die Vorteile. Dann ist die monolithische Bereitstellung einer Anwendung, die in einem einzigen oder in wenigen Containern ausgeführt wird, besser geeignet.</span><span class="sxs-lookup"><span data-stu-id="eda45-311">In some cases, the costs outweigh the benefits, so a monolithic deployment application running in a single container or in just a few containers is a better option.</span></span>

<span data-ttu-id="eda45-312">Eine monolithische Anwendung in gut getrennte Microservices zu zerteilen, ist nicht einfach.</span><span class="sxs-lookup"><span data-stu-id="eda45-312">A monolithic application might not be easily decomposable into well-separated microservices.</span></span> <span data-ttu-id="eda45-313">Microservices sollten unabhängig voneinander funktionieren, um eine widerstandsfähigere Anwendung bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="eda45-313">Microservices should work independently of each other to provide a more resilient application.</span></span> <span data-ttu-id="eda45-314">Wenn Sie keine unabhängigen Feature-Slices der Anwendung bereitstellen können, führt das Trennen derselben nur zu erhöhter Komplexität.</span><span class="sxs-lookup"><span data-stu-id="eda45-314">If you can't deliver independent feature slices of the application, separating it only adds complexity.</span></span>

<span data-ttu-id="eda45-315">Eine Anwendung muss möglicherweise noch keine Features unabhängig voneinander skalieren.</span><span class="sxs-lookup"><span data-stu-id="eda45-315">An application might not yet need to scale features independently.</span></span> <span data-ttu-id="eda45-316">Viele Anwendungen können dies mithilfe eines relativ einfachen Prozesses zum Klonen der gesamten Instanz durchführen, wenn sie über eine einzelne Instanz hinaus skaliert werden müssen.</span><span class="sxs-lookup"><span data-stu-id="eda45-316">Many applications, when they need to scale beyond a single instance, can do so through the relatively simple process of cloning that entire instance.</span></span> <span data-ttu-id="eda45-317">Die zusätzliche Arbeit zum Trennen der Anwendung in diskrete Dienste bietet minimale Vorteile, wenn die Skalierung von vollständigen Instanzen der Anwendung einfach und kosteneffizient ist.</span><span class="sxs-lookup"><span data-stu-id="eda45-317">The additional work to separate the application into discrete services provides minimal benefit when scaling full instances of the application is simple and cost-effective.</span></span>

<span data-ttu-id="eda45-318">Zu einem frühen Zeitpunkt während der Entwicklung einer Anwendung haben Sie möglicherweise noch keine Vorstellung davon, wo die natürlichen funktionalen Grenzen liegen.</span><span class="sxs-lookup"><span data-stu-id="eda45-318">Early in the development of an application, you might not have a clear idea where the natural functional boundaries are.</span></span> <span data-ttu-id="eda45-319">Beim Entwickeln eines mindestens anwendungsfähigen Produkts könnte die natürliche Trennung noch nicht verfügbar sein.</span><span class="sxs-lookup"><span data-stu-id="eda45-319">As you develop a minimum viable product, the natural separation might not yet have emerged.</span></span> <span data-ttu-id="eda45-320">Einige dieser Bedingungen können temporär sein.</span><span class="sxs-lookup"><span data-stu-id="eda45-320">Some of these conditions might be temporary.</span></span> <span data-ttu-id="eda45-321">Sie können mit dem Erstellen einer monolithischen Anwendung beginnen und später einige Features trennen, damit diese als Microservices entwickelt und bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-321">You might start by creating a monolithic application, and later separate some features to be developed and deployed as microservices.</span></span> <span data-ttu-id="eda45-322">Andere Bedingungen können entscheidend für den Problembereich der Anwendung sein. Das bedeutet, dass die Anwendung möglicherweise nicht in mehrere Microservices unterteilt werden kann.</span><span class="sxs-lookup"><span data-stu-id="eda45-322">Other conditions might be essential to the application’s problem space, meaning that the application might never be broken into multiple microservices.</span></span>

<span data-ttu-id="eda45-323">Das Trennen einer Anwendung in viele diskrete Prozesse führt außerdem zu Mehraufwand.</span><span class="sxs-lookup"><span data-stu-id="eda45-323">Separating an application into many discrete processes also introduces overhead.</span></span> <span data-ttu-id="eda45-324">Durch das Teilen der Features in verschiedene Prozesse wird die Komplexität erhöht.</span><span class="sxs-lookup"><span data-stu-id="eda45-324">There's more complexity in separating features into different processes.</span></span> <span data-ttu-id="eda45-325">Die Kommunikationsprotokolle werden komplexer.</span><span class="sxs-lookup"><span data-stu-id="eda45-325">The communication protocols become more complex.</span></span> <span data-ttu-id="eda45-326">Anstelle von Methodenaufrufen müssen Sie asynchrone Kommunikationen zwischen den Diensten verwenden.</span><span class="sxs-lookup"><span data-stu-id="eda45-326">Instead of method calls, you must use asynchronous communications between services.</span></span> <span data-ttu-id="eda45-327">Wenn Sie eine Microservices-Architektur verschieben, müssen Sie viele der Bausteine hinzufügen, die in die Microservices-Version der eShopOnContainers-Anwendung implementiert sind: Eventbusbehandlung, Meldungsstabilität und -wiederholungen, Eventual Consistency usw.</span><span class="sxs-lookup"><span data-stu-id="eda45-327">As you move to a microservices architecture, you need to add many of the building blocks implemented in the microservices version of the eShopOnContainers application: event bus handling, message resiliency and retries, eventual consistency, and more.</span></span>

<span data-ttu-id="eda45-328">Die deutlich einfachere [Referenzanwendung eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb) unterstützt die Verwendung einzelner monolithischer Container.</span><span class="sxs-lookup"><span data-stu-id="eda45-328">The much simpler [eShopOnWeb reference application](https://github.com/dotnet-architecture/eShopOnWeb) supports single-container monolithic container usage.</span></span> <span data-ttu-id="eda45-329">Die Anwendung umfasst eine Webanwendung, die herkömmliche MVC-Ansichten, Web-APIs und Razor Pages enthält.</span><span class="sxs-lookup"><span data-stu-id="eda45-329">The application includes one web application that includes traditional MVC views, web APIs, and Razor Pages.</span></span> <span data-ttu-id="eda45-330">Diese Anwendung kann über den Projektmappenstamm mithilfe der Befehle `docker-compose build` und `docker-compose up` gestartet werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-330">This application can be launched from the solution root using the `docker-compose build` and `docker-compose up` commands.</span></span> <span data-ttu-id="eda45-331">Dieser Befehl konfiguriert mithilfe der `Dockerfile` aus dem Webprojektstamm einen Container für die Webinstanz und führt den Container auf einem angegebenen Port aus.</span><span class="sxs-lookup"><span data-stu-id="eda45-331">This command configures a container for the web instance, using the `Dockerfile` found in the web project's root, and runs the container on a specified port.</span></span> <span data-ttu-id="eda45-332">Sie können die Quelle für diese Anwendung von GitHub herunterladen und diese lokal ausführen.</span><span class="sxs-lookup"><span data-stu-id="eda45-332">You can download the source for this application from GitHub and run it locally.</span></span> <span data-ttu-id="eda45-333">Auch die monolithische Anwendung profitiert von der Bereitstellung in einer Containerumgebung.</span><span class="sxs-lookup"><span data-stu-id="eda45-333">Even this monolithic application benefits from being deployed in a container environment.</span></span>

<span data-ttu-id="eda45-334">Durch die Containerumgebung wird jede Instanz der Anwendung in derselben Umgebung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="eda45-334">For one, the containerized deployment means that every instance of the application runs in the same environment.</span></span> <span data-ttu-id="eda45-335">Dies schließt die Entwicklungsumgebung ein, in der das frühe Testen und die Entwicklung stattfinden.</span><span class="sxs-lookup"><span data-stu-id="eda45-335">This includes the developer environment where early testing and development take place.</span></span> <span data-ttu-id="eda45-336">Das Entwicklungsteam kann die Anwendung in einer Containerumgebung ausführen, die der Produktionsumgebung entspricht.</span><span class="sxs-lookup"><span data-stu-id="eda45-336">The development team can run the application in a containerized environment that matches the production environment.</span></span>

<span data-ttu-id="eda45-337">Zusätzlich können Containeranwendungen zu geringeren Kosten skaliert werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-337">In addition, containerized applications scale out at lower cost.</span></span> <span data-ttu-id="eda45-338">Die Verwendung einer Containerumgebung ermöglicht eine größere Ressourcenfreigabe als herkömmliche VM-Umgebungen.</span><span class="sxs-lookup"><span data-stu-id="eda45-338">Using a container environment enables greater resource sharing than traditional VM environments.</span></span>

<span data-ttu-id="eda45-339">Schließlich erzwingt das Containerisieren einer Anwendung eine Trennung zwischen der Geschäftslogik und dem Speicherserver.</span><span class="sxs-lookup"><span data-stu-id="eda45-339">Finally, containerizing the application forces a separation between the business logic and the storage server.</span></span> <span data-ttu-id="eda45-340">Wenn die Anwendung skaliert wird, verwenden alle Container ein einziges physisches Speichermedium.</span><span class="sxs-lookup"><span data-stu-id="eda45-340">As the application scales out, the multiple containers will all rely on a single physical storage medium.</span></span> <span data-ttu-id="eda45-341">In der Regel ist dieses Speichermedium ein Hochverfügbarkeitsserver, der eine SQL Server-Datenbank ausführt.</span><span class="sxs-lookup"><span data-stu-id="eda45-341">This storage medium would typically be a high-availability server running a SQL Server database.</span></span>

## <a name="docker-support"></a><span data-ttu-id="eda45-342">Docker-Unterstützung</span><span class="sxs-lookup"><span data-stu-id="eda45-342">Docker support</span></span>

<span data-ttu-id="eda45-343">Das `eShopOnWeb`-Projekt wird auf .NET Core ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="eda45-343">The `eShopOnWeb` project runs on .NET Core.</span></span> <span data-ttu-id="eda45-344">Darum kann es entweder auf Linux- oder auf Windows-basierten Containern ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-344">Therefore, it can run in either Linux-based or Windows-based containers.</span></span> <span data-ttu-id="eda45-345">Beachten Sie, dass Sie für die Docker-Bereitstellung den gleichen Hosttyp für SQL Server verwenden sollten.</span><span class="sxs-lookup"><span data-stu-id="eda45-345">Note that for Docker deployment, you want to use the same host type for SQL Server.</span></span> <span data-ttu-id="eda45-346">Linux-basierte Container haben einen geringeren Speicherbedarf und werden bevorzugt.</span><span class="sxs-lookup"><span data-stu-id="eda45-346">Linux-based containers allow a smaller footprint and are preferred.</span></span>

<span data-ttu-id="eda45-347">Sie können Visual Studio 2017 (oder höher) verwenden, um einer vorhandenen Anwendung Docker-Unterstützung hinzuzufügen, indem Sie mit der rechten Maustaste auf ein Projekt im **Projektmappen-Explorer** und dann auf **Hinzufügen** > **Docker-Unterstützung** klicken.</span><span class="sxs-lookup"><span data-stu-id="eda45-347">You can use Visual Studio 2017 or later to add Docker support to an existing application by right-clicking on a project in **Solution Explorer** and choosing **Add** > **Docker Support**.</span></span> <span data-ttu-id="eda45-348">Dadurch werden die erforderlichen Dateien hinzugefügt, und das Projekt wird so geändert, dass es diese verwendet.</span><span class="sxs-lookup"><span data-stu-id="eda45-348">This adds the files required and modifies the project to use them.</span></span> <span data-ttu-id="eda45-349">Das aktuelle `eShopOnWeb`-Beispiel enthält diese Dateien bereits.</span><span class="sxs-lookup"><span data-stu-id="eda45-349">The current `eShopOnWeb` sample already has these files in place.</span></span>

<span data-ttu-id="eda45-350">Die Datei auf Projektmappenebene `docker-compose.yml` enthält Informationen darüber, welche Images erstellt und welche Container gestartet werden müssen.</span><span class="sxs-lookup"><span data-stu-id="eda45-350">The solution-level `docker-compose.yml` file contains information about what images to build and what containers to launch.</span></span> <span data-ttu-id="eda45-351">Die Datei ermöglicht Ihnen die Verwendung des `docker-compose`-Befehls zum gleichzeitigen Starten mehrerer Anwendungen.</span><span class="sxs-lookup"><span data-stu-id="eda45-351">The file allows you to use the `docker-compose` command to launch multiple applications at the same time.</span></span> <span data-ttu-id="eda45-352">In diesem Fall wird nur das Webprojekt gestartet.</span><span class="sxs-lookup"><span data-stu-id="eda45-352">In this case, it is only launching the Web project.</span></span> <span data-ttu-id="eda45-353">Sie können sie ebenfalls zum Konfigurieren von Abhängigkeiten verwenden, z.B. für einen separaten Datenbankcontainer.</span><span class="sxs-lookup"><span data-stu-id="eda45-353">You can also use it to configure dependencies, such as a separate database container.</span></span>

```yml
version: '3'

services:
  eshopwebmvc:
    image: eshopwebmvc
    build:
      context: .
      dockerfile: src/Web/Dockerfile
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - "5106:5106"

networks:
  default:
    external:
      name: nat
```

<span data-ttu-id="eda45-354">Die `docker-compose.yml`-Datei verweist auf die `Dockerfile` im `Web`-Projekt.</span><span class="sxs-lookup"><span data-stu-id="eda45-354">The `docker-compose.yml` file references the `Dockerfile` in the `Web` project.</span></span> <span data-ttu-id="eda45-355">Die `Dockerfile`-Datei wird verwendet, um anzugeben, welcher Basiscontainer verwendet und wie die Anwendung darauf konfiguriert wird.</span><span class="sxs-lookup"><span data-stu-id="eda45-355">The `Dockerfile` is used to specify which base container will be used and how the application will be configured on it.</span></span> <span data-ttu-id="eda45-356">Die `Dockerfile`-Datei von `Web`:</span><span class="sxs-lookup"><span data-stu-id="eda45-356">The `Web`' `Dockerfile`:</span></span>

```
FROM mcr.microsoft.com/dotnet/core/sdk:2.2 AS build
WORKDIR /app

COPY *.sln .
COPY . .
WORKDIR /app/src/Web
RUN dotnet restore

RUN dotnet publish -c Release -o out

FROM mcr.microsoft.com/dotnet/core/aspnet:2.2 AS runtime
WORKDIR /app
COPY --from=build /app/src/Web/out ./

# Optional: Set this here if not setting it from docker-compose.yml
# ENV ASPNETCORE_ENVIRONMENT Development

ENTRYPOINT ["dotnet", "Web.dll"]
```

### <a name="troubleshooting-docker-problems"></a><span data-ttu-id="eda45-357">Problembehandlung bei Docker</span><span class="sxs-lookup"><span data-stu-id="eda45-357">Troubleshooting Docker problems</span></span>

<span data-ttu-id="eda45-358">Wenn Sie die Containeranwendung ausführen, wird diese ausgeführt, bis Sie sie beenden.</span><span class="sxs-lookup"><span data-stu-id="eda45-358">Once you run the containerized application, it continues to run until you stop it.</span></span> <span data-ttu-id="eda45-359">Mit dem Befehl `docker ps` können Sie anzeigen, welche Container ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="eda45-359">You can view which containers are running with the `docker ps` command.</span></span> <span data-ttu-id="eda45-360">Sie können einen aktiven Container beenden, indem Sie den Befehl `docker stop` verwenden und die Container-ID angeben.</span><span class="sxs-lookup"><span data-stu-id="eda45-360">You can stop a running container by using the `docker stop` command and specifying the container ID.</span></span>

<span data-ttu-id="eda45-361">Beachten Sie, dass ausgeführte Docker-Container an Ports gebunden sein können, die Sie möglicherweise andernfalls in Ihrer Entwicklungsumgebung verwenden.</span><span class="sxs-lookup"><span data-stu-id="eda45-361">Note that running Docker containers may be bound to ports you might otherwise try to use in your development environment.</span></span> <span data-ttu-id="eda45-362">Wenn Sie versuchen, eine Anwendung mit dem gleichen Port auszuführen oder zu debuggen, den ein aktiver Docker-Container verwendet, erhalten Sie eine Fehlermeldung, die angibt, dass der Server nicht an diesen Port gebunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="eda45-362">If you try to run or debug an application using the same port as a running Docker container, you'll get an error stating that the server can't bind to that port.</span></span> <span data-ttu-id="eda45-363">Auch hier sollte das Beenden des Containers das Problem beheben.</span><span class="sxs-lookup"><span data-stu-id="eda45-363">Once again, stopping the container should resolve the issue.</span></span>

<span data-ttu-id="eda45-364">Wenn Sie Ihrer Anwendung mithilfe von Visual Studio Docker-Unterstützung hinzufügen möchten, stellen Sie sicher, dass Docker Desktop ausgeführt wird, während Sie dies tun.</span><span class="sxs-lookup"><span data-stu-id="eda45-364">If you want to add Docker support to your application using Visual Studio, make sure Docker Desktop is running when you do so.</span></span> <span data-ttu-id="eda45-365">Der Assistent wird nicht ordnungsgemäß ausgeführt, wenn Docker Desktop beim Starten des Assistenten nicht ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="eda45-365">The wizard won't run correctly if Docker Desktop isn't running when you start the wizard.</span></span> <span data-ttu-id="eda45-366">Darüber hinaus überprüft der Assistent Ihre aktuelle Containerwahl, um die richtige Docker-Unterstützung hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="eda45-366">In addition, the wizard examines your current container choice to add the correct Docker support.</span></span> <span data-ttu-id="eda45-367">Wenn Sie Unterstützung für Windows-Container hinzufügen möchten, führen Sie den Assistenten aus, während Docker Desktop mit der Konfiguration für Windows-Container ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="eda45-367">If you want to add support for Windows Containers, you need to run the wizard while you have Docker Desktop running with Windows Containers configured.</span></span> <span data-ttu-id="eda45-368">Wenn Sie Unterstützung für Linux-Container hinzufügen möchten, führen Sie den Assistenten aus, während Docker mit der Konfiguration für Linux-Container ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="eda45-368">If you want to add support for Linux containers, run the wizard while you have Docker running with Linux containers configured.</span></span>

### <a name="references--common-web-architectures"></a><span data-ttu-id="eda45-369">Ressourcen: Häufig verwendete Webarchitekturen</span><span class="sxs-lookup"><span data-stu-id="eda45-369">References – Common web architectures</span></span>
> - <span data-ttu-id="eda45-370">**Clean Architecture**</span><span class="sxs-lookup"><span data-stu-id="eda45-370">**The Clean Architecture**</span></span>  
>   <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
> - <span data-ttu-id="eda45-371">**Onion Architecture**</span><span class="sxs-lookup"><span data-stu-id="eda45-371">**The Onion Architecture**</span></span>  
>   <https://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
> - <span data-ttu-id="eda45-372">**The Repository Pattern (Das Muster „Repository“)**</span><span class="sxs-lookup"><span data-stu-id="eda45-372">**The Repository Pattern**</span></span>  
>   <https://deviq.com/repository-pattern/>
> - <span data-ttu-id="eda45-373">**Clean Architecture Solution Sample (Projektmappenbeispiel unter Verwendung von Clean Architecture)**</span><span class="sxs-lookup"><span data-stu-id="eda45-373">**Clean Architecture Solution Sample**</span></span>  
>   <https://github.com/ardalis/cleanarchitecture>
> - <span data-ttu-id="eda45-374">**E-Book „Architecting Microservices“ (E-Book zur Architektur von Microservices)**</span><span class="sxs-lookup"><span data-stu-id="eda45-374">**Architecting Microservices e-book**</span></span>  
>   <https://aka.ms/MicroservicesEbook>

>[!div class="step-by-step"]
><span data-ttu-id="eda45-375">[Zurück](architectural-principles.md)
>[Weiter](common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="eda45-375">[Previous](architectural-principles.md)
[Next](common-client-side-web-technologies.md)</span></span>
