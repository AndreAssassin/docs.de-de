---
title: Database-per-Microservice
description: Kontrastdatenspeicherung in monolithischen und Cloud-nativen Anwendungen.
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: c0c5611fa866d70f155e4bdad2eee1181b13c065
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141444"
---
# <a name="database-per-microservice"></a><span data-ttu-id="a0de7-103">Database-per-Microservice</span><span class="sxs-lookup"><span data-stu-id="a0de7-103">Database-per-microservice</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="a0de7-104">Wie wir in diesem Buch gesehen haben, ändert ein cloudnativer Ansatz die Art und Weise, wie Sie Anwendungen entwerfen, bereitstellen und verwalten.</span><span class="sxs-lookup"><span data-stu-id="a0de7-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="a0de7-105">Außerdem wird die Art und Weise, wie Sie Daten verwalten und speichern, geändert.</span><span class="sxs-lookup"><span data-stu-id="a0de7-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="a0de7-106">Abbildung 5-1 stellt die Unterschiede gegenüber.</span><span class="sxs-lookup"><span data-stu-id="a0de7-106">Figure 5-1 contrasts the differences.</span></span>

![Datenspeicherung in Cloud-nativen Anwendungen](./media/distributed-data.png)

<span data-ttu-id="a0de7-108">**Abbildung 5-1**.</span><span class="sxs-lookup"><span data-stu-id="a0de7-108">**Figure 5-1**.</span></span> <span data-ttu-id="a0de7-109">Datenmanagement in Cloud-nativen Anwendungen</span><span class="sxs-lookup"><span data-stu-id="a0de7-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="a0de7-110">Erfahrene Entwickler werden die Architektur auf der linken Seite der Abbildung 5-1 leicht erkennen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="a0de7-111">In dieser *monolithischen Anwendung*werden Geschäftsdienstkomponenten in einer gemeinsamen Dienstebene zusammengezäutt und Daten aus einer einzelnen relationalen Datenbank gemeinsam genutzt.</span><span class="sxs-lookup"><span data-stu-id="a0de7-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="a0de7-112">In vielerlei Hinsicht vereinfacht eine einzelne Datenbank die Datenverwaltung.</span><span class="sxs-lookup"><span data-stu-id="a0de7-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="a0de7-113">Das Abfragen von Daten über mehrere Tabellen hinweg ist einfach.</span><span class="sxs-lookup"><span data-stu-id="a0de7-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="a0de7-114">Änderungen an Daten werden zusammen aktualisiert, oder sie alle werden zurückgenommen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="a0de7-115">[ACID-Transaktionen](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) garantieren eine starke und sofortige Konsistenz.</span><span class="sxs-lookup"><span data-stu-id="a0de7-115">[ACID transactions](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="a0de7-116">Wir entwerfen für Cloud-native und verfolgen einen anderen Ansatz.</span><span class="sxs-lookup"><span data-stu-id="a0de7-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="a0de7-117">Beachten Sie auf der rechten Seite von Abbildung 5-1, wie sich die Geschäftsfunktionalität in kleine, unabhängige Microservices aufgliedert.</span><span class="sxs-lookup"><span data-stu-id="a0de7-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="a0de7-118">Jeder Microservice kapselt eine bestimmte Geschäftsfähigkeit und eigene Daten.</span><span class="sxs-lookup"><span data-stu-id="a0de7-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="a0de7-119">Die monolithische Datenbank zerfällt in ein verteiltes Datenmodell mit vielen kleineren Datenbanken, die jeweils an einem Microservice ausgerichtet sind.</span><span class="sxs-lookup"><span data-stu-id="a0de7-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="a0de7-120">Wenn sich der Rauch lichte, entstehen wir mit einem Design, das eine *Datenbank pro Microservice*freilegt.</span><span class="sxs-lookup"><span data-stu-id="a0de7-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="why"></a><span data-ttu-id="a0de7-121">Warum?</span><span class="sxs-lookup"><span data-stu-id="a0de7-121">Why?</span></span>

<span data-ttu-id="a0de7-122">Diese Datenbank pro Microservice bietet viele Vorteile, insbesondere für Systeme, die sich schnell weiterentwickeln und einen enormen Umfang unterstützen müssen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="a0de7-123">Mit diesem Modell...</span><span class="sxs-lookup"><span data-stu-id="a0de7-123">With this model...</span></span>

- <span data-ttu-id="a0de7-124">Domänendaten werden im Dienst gekapselt</span><span class="sxs-lookup"><span data-stu-id="a0de7-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="a0de7-125">Datenschema kann sich weiterentwickeln, ohne andere Dienste direkt zu beeinträchtigen</span><span class="sxs-lookup"><span data-stu-id="a0de7-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="a0de7-126">Jeder Datenspeicher kann unabhängig skaliert werden</span><span class="sxs-lookup"><span data-stu-id="a0de7-126">Each data store can independently scale</span></span>
- <span data-ttu-id="a0de7-127">Ein Datenspeicherfehler in einem Dienst wirkt sich nicht direkt auf andere Dienste aus.</span><span class="sxs-lookup"><span data-stu-id="a0de7-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="a0de7-128">Durch das Trennen von Daten kann jeder Microservice auch den Datenspeichertyp implementieren, der am besten für seine Workload, Speicheranforderungen und Lese-/Schreibmuster optimiert ist.</span><span class="sxs-lookup"><span data-stu-id="a0de7-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="a0de7-129">Die Auswahlmöglichkeiten umfassen relationale, Dokument-, Schlüssel- und sogar graphenbasierte Datenspeicher.</span><span class="sxs-lookup"><span data-stu-id="a0de7-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="a0de7-130">Abbildung 5-2 zeigt das Prinzip der Polyglot-Persistenz in einem Cloud-nativen System.</span><span class="sxs-lookup"><span data-stu-id="a0de7-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![Polyglot-Datenpersistenz](./media/polyglot-data-persistence.png)

<span data-ttu-id="a0de7-132">**Abbildung 5-2**.</span><span class="sxs-lookup"><span data-stu-id="a0de7-132">**Figure 5-2**.</span></span> <span data-ttu-id="a0de7-133">Polyglot-Datenpersistenz</span><span class="sxs-lookup"><span data-stu-id="a0de7-133">Polyglot data persistence</span></span>

<span data-ttu-id="a0de7-134">Beachten Sie in der vorherigen Abbildung, wie jeder Microservice einen anderen Datenspeichertyp unterstützt.</span><span class="sxs-lookup"><span data-stu-id="a0de7-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="a0de7-135">Der Produktkatalog microservice verwendet eine relationale Datenbank, um die umfangreiche relationale Struktur der zugrunde liegenden Daten zu berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="a0de7-136">Der Warenkorb microservice verwendet einen verteilten Cache, der seinen einfachen Datenspeicher mit Schlüsselwert unterstützt.</span><span class="sxs-lookup"><span data-stu-id="a0de7-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="a0de7-137">Der ordnende Microservice verwendet sowohl eine NoSql-Dokumentdatenbank für Schreibvorgänge als auch einen stark denormalisierten Schlüssel-/Wertspeicher, um große Mengen an Lesevorgängen zu berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="a0de7-138">Während relationale Datenbanken für Microservices mit komplexen Daten relevant bleiben, haben NoSQL-Datenbanken beträchtliche Popularität gewonnen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="a0de7-139">Sie bieten einen enormen Maßstab und hohe Verfügbarkeit.</span><span class="sxs-lookup"><span data-stu-id="a0de7-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="a0de7-140">Ihre schemalose Natur ermöglicht es Entwicklern, sich von einer Architektur typisierter Datenklassen und ORMs zu entfernen, die Änderungen teuer und zeitaufwändig machen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="a0de7-141">Wir behandeln NoSQL-Datenbanken weiter unten in diesem Kapitel.</span><span class="sxs-lookup"><span data-stu-id="a0de7-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="a0de7-142">Das Einkapseln von Daten in separate Microservices kann zwar die Agilität, Leistung und Skalierbarkeit erhöhen, stellt aber auch viele Herausforderungen dar.</span><span class="sxs-lookup"><span data-stu-id="a0de7-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="a0de7-143">Im nächsten Abschnitt besprechen wir diese Herausforderungen zusammen mit Mustern und Praktiken, die ihnen helfen, sie zu überwinden.</span><span class="sxs-lookup"><span data-stu-id="a0de7-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="a0de7-144">Dienstübergreifende Abfragen</span><span class="sxs-lookup"><span data-stu-id="a0de7-144">Cross-service queries</span></span>

<span data-ttu-id="a0de7-145">Microservices sind unabhängig und konzentrieren sich auf bestimmte funktionale Funktionen wie Inventar, Versand oder Bestellung, erfordern jedoch häufig die Integration mit anderen Microservices.</span><span class="sxs-lookup"><span data-stu-id="a0de7-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="a0de7-146">Häufig umfasst die Integration einen Microservice, der einen anderen nach Daten *abfragt.*</span><span class="sxs-lookup"><span data-stu-id="a0de7-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="a0de7-147">Abbildung 5-3 zeigt das Szenario.</span><span class="sxs-lookup"><span data-stu-id="a0de7-147">Figure 5-3 shows the scenario.</span></span>

![Abfragen über Microservices hinweg](./media/cross-service-query.png)

<span data-ttu-id="a0de7-149">**Abbildung 5-3**.</span><span class="sxs-lookup"><span data-stu-id="a0de7-149">**Figure 5-3**.</span></span> <span data-ttu-id="a0de7-150">Abfragen über Microservices hinweg</span><span class="sxs-lookup"><span data-stu-id="a0de7-150">Querying across microservices</span></span>

<span data-ttu-id="a0de7-151">In der obigen Abbildung sehen wir einen Warenkorb-Microservice, der einen Artikel zum Warenkorb eines Benutzers hinzufügt.</span><span class="sxs-lookup"><span data-stu-id="a0de7-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="a0de7-152">Der Datenspeicher für diesen Microservice enthält zwar Warenkorb- und Positionsdaten, verwaltet jedoch keine Produkt- oder Preisdaten.</span><span class="sxs-lookup"><span data-stu-id="a0de7-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="a0de7-153">Stattdessen sind diese Datenelemente Im Besitz des Katalogs und der Preisgestaltung von Microservices.</span><span class="sxs-lookup"><span data-stu-id="a0de7-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="a0de7-154">Das stellt ein Problem dar.</span><span class="sxs-lookup"><span data-stu-id="a0de7-154">This presents a problem.</span></span> <span data-ttu-id="a0de7-155">Wie kann der Warenkorb microservice ein Produkt zum Warenkorb des Benutzers hinzufügen, wenn er weder Produkt- noch Preisdaten in seiner Datenbank enthält?</span><span class="sxs-lookup"><span data-stu-id="a0de7-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="a0de7-156">Eine in Kapitel 4 beschriebene Option ist ein [direkter HTTP-Aufruf](service-to-service-communication.md#queries) aus dem Warenkorb zum Katalog und die Preisgestaltung von Microservices.</span><span class="sxs-lookup"><span data-stu-id="a0de7-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="a0de7-157">In Kapitel 4 sagten wir jedoch, dass synchrone HTTP-Aufrufe Microservices miteinander *koppeln,* ihre Autonomie verringern und ihre architektonischen Vorteile verringern.</span><span class="sxs-lookup"><span data-stu-id="a0de7-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="a0de7-158">Wir können auch ein Anforderungs-Antwort-Muster mit separaten eingehenden und ausgehenden Warteschlangen für jeden Dienst implementieren.</span><span class="sxs-lookup"><span data-stu-id="a0de7-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="a0de7-159">Dieses Muster ist jedoch kompliziert und erfordert Installationen, um Anforderungs- und Antwortnachrichten zu korrelieren.</span><span class="sxs-lookup"><span data-stu-id="a0de7-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="a0de7-160">Während die Back-End-Microservice-Aufrufe entkoppeln, muss der aufrufende Dienst weiterhin synchron warten, bis der Aufruf abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="a0de7-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="a0de7-161">Netzwerküberlastung, vorübergehende Störungen oder ein überlasteter Microservice können zu lang andauernden und sogar fehlgeschlagenen Vorgängen führen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="a0de7-162">Stattdessen ist ein weithin akzeptiertes Muster zum Entfernen dienstübergreifender Abhängigkeiten das [materialisierte Ansichtsmuster](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), das in Abbildung 5-4 dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="a0de7-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![Materialisiertes Ansichtsmuster](./media/materialized-view-pattern.png)

<span data-ttu-id="a0de7-164">**Abbildung 5-4**.</span><span class="sxs-lookup"><span data-stu-id="a0de7-164">**Figure 5-4**.</span></span> <span data-ttu-id="a0de7-165">Materialisiertes Ansichtsmuster</span><span class="sxs-lookup"><span data-stu-id="a0de7-165">Materialized View Pattern</span></span>

<span data-ttu-id="a0de7-166">Bei diesem Muster platzieren Sie eine lokale Datentabelle (als *Lesemodell*bezeichnet) im Warenkorbservice.</span><span class="sxs-lookup"><span data-stu-id="a0de7-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="a0de7-167">Diese Tabelle enthält eine denormalisierte Kopie der Daten, die aus den Microservices für das Produkt und die Preisgestaltung benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="a0de7-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="a0de7-168">Das direkte Kopieren der Daten in den Warenkorb Microservice macht teure cross-service-Anrufe überflüssig.</span><span class="sxs-lookup"><span data-stu-id="a0de7-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="a0de7-169">Mit den lokalen Daten für den Dienst verbessern Sie die Reaktionszeit und Zuverlässigkeit des Dienstes.</span><span class="sxs-lookup"><span data-stu-id="a0de7-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="a0de7-170">Darüber hinaus macht eine eigene Kopie der Daten den Warenkorbservice widerstandsfähiger.</span><span class="sxs-lookup"><span data-stu-id="a0de7-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="a0de7-171">Wenn der Katalogdienst nicht mehr verfügbar sein sollte, würde er sich nicht direkt auf den Warenkorbservice auswirken.</span><span class="sxs-lookup"><span data-stu-id="a0de7-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="a0de7-172">Der Warenkorb kann mit den Daten aus dem eigenen Shop weiterbetrieben werden.</span><span class="sxs-lookup"><span data-stu-id="a0de7-172">The shopping basket can continue operating with the data from its own store.</span></span>

<span data-ttu-id="a0de7-173">Der Haken an diesem Ansatz ist, dass Sie jetzt doppelte Daten in Ihrem System haben.</span><span class="sxs-lookup"><span data-stu-id="a0de7-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="a0de7-174">Das *strategische* Duplizieren von Daten in Cloud-nativen Systemen ist jedoch eine etablierte Praxis und wird nicht als Anti-Muster oder schlechte Praxis betrachtet.</span><span class="sxs-lookup"><span data-stu-id="a0de7-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="a0de7-175">Beachten Sie, dass *ein und nur ein Dienst* einen Datensatz besitzen und über die Berechtigung verfügen kann.</span><span class="sxs-lookup"><span data-stu-id="a0de7-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="a0de7-176">Sie müssen die Lesemodelle synchronisieren, wenn das Datensatzsystem aktualisiert wird.</span><span class="sxs-lookup"><span data-stu-id="a0de7-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="a0de7-177">Die Synchronisierung wird in der Regel über asynchrones Messaging mit einem [Veröffentlichungs-/Abonnementmuster](service-to-service-communication.md#events)implementiert, wie in Abbildung 5.4 dargestellt.</span><span class="sxs-lookup"><span data-stu-id="a0de7-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="a0de7-178">Verteilte Transaktionen</span><span class="sxs-lookup"><span data-stu-id="a0de7-178">Distributed transactions</span></span>

<span data-ttu-id="a0de7-179">Obwohl das Abfragen von Daten über Microservices hinweg schwierig ist, ist die Implementierung einer Transaktion über mehrere Microservices hinweg noch komplexer.</span><span class="sxs-lookup"><span data-stu-id="a0de7-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="a0de7-180">Die inhärente Herausforderung, die Datenkonsistenz über unabhängige Datenquellen in verschiedenen Microservices hinweg aufrechtzuerhalten, kann nicht unterschätzt werden.</span><span class="sxs-lookup"><span data-stu-id="a0de7-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="a0de7-181">Das Fehlen verteilter Transaktionen in Cloud-nativen Anwendungen bedeutet, dass Sie verteilte Transaktionen programmgesteuert verwalten müssen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="a0de7-182">Sie bewegen sich von einer Welt der *unmittelbaren Konsistenz* zu der Welt der *letztendlichen Konsistenz*.</span><span class="sxs-lookup"><span data-stu-id="a0de7-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="a0de7-183">Abbildung 5-5 zeigt das Problem.</span><span class="sxs-lookup"><span data-stu-id="a0de7-183">Figure 5-5 shows the problem.</span></span>

![Transaktion im Saga-Muster](./media/saga-transaction-operation.png)

<span data-ttu-id="a0de7-185">**Abbildung 5-5**.</span><span class="sxs-lookup"><span data-stu-id="a0de7-185">**Figure 5-5**.</span></span> <span data-ttu-id="a0de7-186">Implementieren einer Transaktion über Microservices hinweg</span><span class="sxs-lookup"><span data-stu-id="a0de7-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="a0de7-187">In der obigen Abbildung nehmen fünf unabhängige Microservices an einer verteilten Transaktion teil, die einen Auftrag erstellt.</span><span class="sxs-lookup"><span data-stu-id="a0de7-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="a0de7-188">Jeder Microservice unterhält einen eigenen Datenspeicher und implementiert eine lokale Transaktion für seinen Speicher.</span><span class="sxs-lookup"><span data-stu-id="a0de7-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="a0de7-189">Um den Auftrag zu erstellen, muss die lokale Transaktion für *jeden* einzelnen Microservice erfolgreich sein, oder *alle* müssen den Vorgang abbrechen und zurücksetzen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="a0de7-190">Obwohl in jedem Microservices integrierte Transaktionsunterstützung verfügbar ist, gibt es keine Unterstützung für eine verteilte Transaktion, die sich über alle fünf Dienste erstrecken würde, um die Daten konsistent zu halten.</span><span class="sxs-lookup"><span data-stu-id="a0de7-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="a0de7-191">Stattdessen müssen Sie diese *verteilte*Transaktion programmgesteuert erstellen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="a0de7-192">Ein beliebtes Muster zum Hinzufügen verteilter Transaktionsunterstützung ist das Saga-Muster.</span><span class="sxs-lookup"><span data-stu-id="a0de7-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="a0de7-193">Es wird implementiert, indem lokale Transaktionen programmgesteuert und sequenziell gruppiert werden.</span><span class="sxs-lookup"><span data-stu-id="a0de7-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="a0de7-194">Wenn eine der lokalen Transaktionen fehlschlägt, bricht die Saga den Vorgang ab und ruft eine Reihe von [kompensierenden Transaktionen](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)auf.</span><span class="sxs-lookup"><span data-stu-id="a0de7-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="a0de7-195">Die kompensierenden Transaktionen machen die Änderungen rückgängig, die von den vorherigen lokalen Transaktionen vorgenommen wurden, und stellen die Datenkonsistenz wieder her.</span><span class="sxs-lookup"><span data-stu-id="a0de7-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="a0de7-196">Abbildung 5-6 zeigt eine fehlgeschlagene Transaktion mit dem Saga-Muster.</span><span class="sxs-lookup"><span data-stu-id="a0de7-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![Roll back in Saga-Muster](./media/saga-rollback-operation.png)

<span data-ttu-id="a0de7-198">**Abbildung 5-6**.</span><span class="sxs-lookup"><span data-stu-id="a0de7-198">**Figure 5-6**.</span></span> <span data-ttu-id="a0de7-199">Ausführen eines Rollbacks für eine Transaktion</span><span class="sxs-lookup"><span data-stu-id="a0de7-199">Rolling back a transaction</span></span>

<span data-ttu-id="a0de7-200">In der vorherigen Abbildung ist der *Vorgang "Lager aktualisieren"* im Inventur-Mikroservice fehlgeschlagen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="a0de7-201">Die Saga ruft eine Reihe von kompensierenden Transaktionen (rot) auf, um die Bestandsanzahlen anzupassen, die Zahlung und den Auftrag zu stornieren und die Daten für jeden Microservice in einen konsistenten Zustand zurückzusenden.</span><span class="sxs-lookup"><span data-stu-id="a0de7-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="a0de7-202">Saga-Muster werden in der Regel als eine Reihe verwandter Ereignisse choreographiert oder als eine Reihe verwandter Befehle orchestriert.</span><span class="sxs-lookup"><span data-stu-id="a0de7-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="a0de7-203">In Kapitel 4 haben wir das Dienstaggregatormuster erläutert, das die Grundlage für eine orchestrierte Saga-Implementierung sein würde.</span><span class="sxs-lookup"><span data-stu-id="a0de7-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="a0de7-204">Wir haben auch die Veranstaltung zusammen mit Azure Service Bus und Azure Event Grid-Themen diskutiert, die eine Grundlage für eine choreografierte Saga-Implementierung sein würden.</span><span class="sxs-lookup"><span data-stu-id="a0de7-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="a0de7-205">Daten mit hohem Volumen</span><span class="sxs-lookup"><span data-stu-id="a0de7-205">High volume data</span></span>

<span data-ttu-id="a0de7-206">Große Cloud-native Anwendungen unterstützen häufig Datenanforderungen mit hohem Volumen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="a0de7-207">In diesen Szenarien können herkömmliche Datenspeichertechniken zu Engpässen führen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="a0de7-208">Bei komplexen Systemen, die in großem Maßstab bereitgestellt werden, können sowohl Die Befehls- als auch die Abfrageverantwortungstrennung (CQRS) und die Ereignisbeschaffung die Anwendungsleistung verbessern.</span><span class="sxs-lookup"><span data-stu-id="a0de7-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="a0de7-209">CQRS-Architektur</span><span class="sxs-lookup"><span data-stu-id="a0de7-209">CQRS</span></span>

<span data-ttu-id="a0de7-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs)ist ein Architekturmuster, das zur Maximierung von Leistung, Skalierbarkeit und Sicherheit beitragen kann.</span><span class="sxs-lookup"><span data-stu-id="a0de7-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="a0de7-211">Das Muster trennt Vorgänge, die Daten von den Vorgängen lesen, die Daten schreiben.</span><span class="sxs-lookup"><span data-stu-id="a0de7-211">The pattern separates operations that read data from those operations that write data.</span></span>

<span data-ttu-id="a0de7-212">Für normale Szenarien werden dasselbe Entitätsmodell und dasselbe Datenrepositoryobjekt sowohl für *Lese- als auch* für Schreibvorgänge verwendet.</span><span class="sxs-lookup"><span data-stu-id="a0de7-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="a0de7-213">Ein Datenszenario mit hohem Volumen kann jedoch von separaten Modellen und Datentabellen für Lese- und Schreibvorgänge profitieren.</span><span class="sxs-lookup"><span data-stu-id="a0de7-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="a0de7-214">Um die Leistung zu verbessern, kann der Lesevorgang eine stark denormalisierte Darstellung der Daten abfragen, um kostspielige wiederholte Tabellenverknüpfungen und Tabellensperren zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="a0de7-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="a0de7-215">Der *Schreibvorgang,* der als *Befehl*bezeichnet wird, wird anhand einer vollständig normalisierten Darstellung der Daten aktualisiert, die Konsistenz gewährleisten würde.</span><span class="sxs-lookup"><span data-stu-id="a0de7-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="a0de7-216">Anschließend müssen Sie einen Mechanismus implementieren, um beide Darstellungen synchron zu halten. Wenn die Schreibtabelle geändert wird, wird in der Regel ein Ereignis veröffentlicht, das die Änderung in die Lesetabelle repliziert.</span><span class="sxs-lookup"><span data-stu-id="a0de7-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="a0de7-217">Abbildung 5-7 zeigt eine Implementierung des CQRS-Musters.</span><span class="sxs-lookup"><span data-stu-id="a0de7-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![Befehls- und Abfrageverantwortungstrennung](./media/cqrs-implementation.png)

<span data-ttu-id="a0de7-219">**Abbildung 5-7**.</span><span class="sxs-lookup"><span data-stu-id="a0de7-219">**Figure 5-7**.</span></span> <span data-ttu-id="a0de7-220">CQRS-Implementierung</span><span class="sxs-lookup"><span data-stu-id="a0de7-220">CQRS implementation</span></span>

<span data-ttu-id="a0de7-221">In der vorherigen Abbildung werden separate Befehls- und Abfragemodelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="a0de7-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="a0de7-222">Jeder Datenschreibvorgang wird im Schreibspeicher gespeichert und dann an den Lesespeicher weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="a0de7-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="a0de7-223">Achten Sie genau darauf, wie der Datenweitergabeprozess nach dem Prinzip der [letztendlichen Konsistenz](http://www.cloudcomputingpatterns.org/eventual_consistency/)funktioniert.</span><span class="sxs-lookup"><span data-stu-id="a0de7-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="a0de7-224">Das Lesemodell wird schließlich mit dem Schreibmodell synchronisiert, aber es kann zu Verzögerungen im Prozess führen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="a0de7-225">Im nächsten Abschnitt wird die eventuelle Konsistenz erläutert.</span><span class="sxs-lookup"><span data-stu-id="a0de7-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="a0de7-226">Durch diese Trennung können Lese- und Schreibvorgänge unabhängig skaliert werden.</span><span class="sxs-lookup"><span data-stu-id="a0de7-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="a0de7-227">Lesevorgänge verwenden ein Schema, das für Abfragen optimiert ist, während die Schreibvorgänge ein Schema verwenden, das für Aktualisierungen optimiert ist.</span><span class="sxs-lookup"><span data-stu-id="a0de7-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="a0de7-228">Leseabfragen gehen gegen denormalisierte Daten, während komplexe Geschäftslogik auf das Schreibmodell angewendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="a0de7-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="a0de7-229">Außerdem können Sie Schreibvorgängen eine strengere Sicherheit auferlegen als die, die Lesevorgänge offenlegen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="a0de7-230">Die Implementierung von CQRS kann die Anwendungsleistung für Cloud-native Dienste verbessern.</span><span class="sxs-lookup"><span data-stu-id="a0de7-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="a0de7-231">Es führt jedoch zu einem komplexeren Design.</span><span class="sxs-lookup"><span data-stu-id="a0de7-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="a0de7-232">Wenden Sie dieses Prinzip sorgfältig und strategisch auf die Abschnitte Ihrer Cloud-native-Anwendung an, die davon profitieren werden.</span><span class="sxs-lookup"><span data-stu-id="a0de7-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="a0de7-233">Weitere Informationen zu CQRS finden Sie im Microsoft-Buch [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span><span class="sxs-lookup"><span data-stu-id="a0de7-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="a0de7-234">Event-Sourcing</span><span class="sxs-lookup"><span data-stu-id="a0de7-234">Event sourcing</span></span>

<span data-ttu-id="a0de7-235">Ein weiterer Ansatz zur Optimierung von Datenszenarien mit hohem Volumen ist [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span><span class="sxs-lookup"><span data-stu-id="a0de7-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="a0de7-236">Ein System speichert in der Regel den aktuellen Status einer Datenentität.</span><span class="sxs-lookup"><span data-stu-id="a0de7-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="a0de7-237">Wenn ein Benutzer z. B. seine Telefonnummer ändert, wird der Kundendatensatz mit der neuen Nummer aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="a0de7-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="a0de7-238">Wir kennen immer den aktuellen Status einer Datenentität, aber jede Aktualisierung überschreibt den vorherigen Status.</span><span class="sxs-lookup"><span data-stu-id="a0de7-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span>

<span data-ttu-id="a0de7-239">In den meisten Fällen funktioniert dieses Modell einwandfrei.</span><span class="sxs-lookup"><span data-stu-id="a0de7-239">In most cases, this model works fine.</span></span> <span data-ttu-id="a0de7-240">In Systemen mit hohem Volumen kann sich der Overhead durch Transaktionssperren und häufige Aktualisierungsvorgänge jedoch auf die Datenbankleistung, Reaktionsfähigkeit und Dieskalierbarkeit auswirken.</span><span class="sxs-lookup"><span data-stu-id="a0de7-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="a0de7-241">Event Sourcing verfolgt einen anderen Ansatz bei der Erfassung von Daten.</span><span class="sxs-lookup"><span data-stu-id="a0de7-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="a0de7-242">Jeder Vorgang, der sich auf Daten auswirkt, wird in einem Ereignisspeicher beibehalten.</span><span class="sxs-lookup"><span data-stu-id="a0de7-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="a0de7-243">Anstatt den Status eines Datensatzes zu aktualisieren, fügen wir jede Änderung an eine sequenzielle Liste vergangener Ereignisse an - ähnlich dem Ledger eines Buchhalters.</span><span class="sxs-lookup"><span data-stu-id="a0de7-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="a0de7-244">Der Ereignisspeicher wird zum Datensatzsystem für die Daten.</span><span class="sxs-lookup"><span data-stu-id="a0de7-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="a0de7-245">Es wird verwendet, um verschiedene materialisierte Ansichten innerhalb des begrenzten Kontexts eines Microservices zu verbreiten.</span><span class="sxs-lookup"><span data-stu-id="a0de7-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="a0de7-246">Abbildung 5.8 zeigt das Muster.</span><span class="sxs-lookup"><span data-stu-id="a0de7-246">Figure 5.8 shows the pattern.</span></span>

![Ereignissourcing](./media/event-sourcing.png)

<span data-ttu-id="a0de7-248">**Abbildung 5-8**.</span><span class="sxs-lookup"><span data-stu-id="a0de7-248">**Figure 5-8**.</span></span> <span data-ttu-id="a0de7-249">Ereignissourcing</span><span class="sxs-lookup"><span data-stu-id="a0de7-249">Event Sourcing</span></span>

<span data-ttu-id="a0de7-250">Beachten Sie in der vorherigen Abbildung, wie jeder Eintrag (in blau) für den Warenkorb eines Benutzers an einen zugrunde liegenden Ereignisspeicher angehängt wird.</span><span class="sxs-lookup"><span data-stu-id="a0de7-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="a0de7-251">In der angrenzenden materialisierten Ansicht projiziert das System den aktuellen Status, indem alle Ereignisse, die jedem Warenkorb zugeordnet sind, wiedergegeben werden.</span><span class="sxs-lookup"><span data-stu-id="a0de7-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="a0de7-252">Diese Ansicht oder das Lesemodell wird dann wieder für die Benutzeroberfläche verfügbar gemacht.</span><span class="sxs-lookup"><span data-stu-id="a0de7-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="a0de7-253">Ereignisse können auch in externe Systeme und Anwendungen integriert oder abgefragt werden, um den aktuellen Status einer Entität zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="a0de7-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="a0de7-254">Mit diesem Ansatz pflegen Sie die Geschichte.</span><span class="sxs-lookup"><span data-stu-id="a0de7-254">With this approach, you maintain history.</span></span> <span data-ttu-id="a0de7-255">Sie kennen nicht nur den aktuellen Status einer Entität, sondern auch, wie Sie diesen Status erreicht haben.</span><span class="sxs-lookup"><span data-stu-id="a0de7-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="a0de7-256">Mechanisch gesehen vereinfacht event sourcing das Schreibmodell.</span><span class="sxs-lookup"><span data-stu-id="a0de7-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="a0de7-257">Es sind keine Aktualisierungen oder Löschungen vorhanden.</span><span class="sxs-lookup"><span data-stu-id="a0de7-257">There are no updates or deletes.</span></span> <span data-ttu-id="a0de7-258">Das Anfügen jedes Dateneintrags als unveränderliches Ereignis minimiert Konflikte, Sperren und Parallelitätskonflikte, die mit relationalen Datenbanken verbunden sind.</span><span class="sxs-lookup"><span data-stu-id="a0de7-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="a0de7-259">Wenn Sie Lesemodelle mit dem materialisierten Ansichtsmuster erstellen, können Sie die Ansicht vom Schreibmodell entkoppeln und den besten Datenspeicher auswählen, um die Anforderungen Der Anwendungsbenutzeroberfläche zu optimieren.</span><span class="sxs-lookup"><span data-stu-id="a0de7-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="a0de7-260">Betrachten Sie für dieses Muster einen Datenspeicher, der die Ereignisbeschaffung direkt unterstützt.</span><span class="sxs-lookup"><span data-stu-id="a0de7-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="a0de7-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB und RavenDB sind gute Kandidaten.</span><span class="sxs-lookup"><span data-stu-id="a0de7-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="a0de7-262">Wie bei allen Mustern und Technologien, strategisch und bei Bedarf implementieren.</span><span class="sxs-lookup"><span data-stu-id="a0de7-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="a0de7-263">Event Sourcing kann zwar eine höhere Leistung und Skalierbarkeit bieten, aber es geht zu Lasten der Komplexität und einer Lernkurve.</span><span class="sxs-lookup"><span data-stu-id="a0de7-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="a0de7-264">[VorherigeS](service-mesh-communication-infrastructure.md)
>[Weiter](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="a0de7-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
