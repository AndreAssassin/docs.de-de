---
title: 'Anhang: GrpC für WCF-Entwickler'
description: Erörterung verteilter Transaktionen und ihrer Implementierung in modernen microservicesarchitekturen.
ms.date: 09/02/2019
ms.openlocfilehash: 061aef016fd0e4303e1bbcbf0e73cec2b0c54f74
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/12/2019
ms.locfileid: "73968222"
---
# <a name="appendix-a---transactions"></a><span data-ttu-id="1a8ff-103">Anhang A-Transaktionen</span><span class="sxs-lookup"><span data-stu-id="1a8ff-103">Appendix A - Transactions</span></span>

<span data-ttu-id="1a8ff-104">Windows Communication Foundation (WCF) unterstützte verteilte Transaktionen, sodass atomarische Vorgänge über mehrere Dienste hinweg durchgeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="1a8ff-104">Windows Communication Foundation (WCF) supported distributed transactions, allowing atomic operations to be performed across multiple services.</span></span> <span data-ttu-id="1a8ff-105">Diese Funktionalität basiert auf der [Microsoft-Distributed Transaction Coordinator](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)).</span><span class="sxs-lookup"><span data-stu-id="1a8ff-105">This functionality was based on the [Microsoft Distributed Transaction Coordinator](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)).</span></span>

<span data-ttu-id="1a8ff-106">In der modernen mikroserviceslandschaft ist diese Art der automatisierten Verarbeitung verteilter Transaktionen nicht möglich.</span><span class="sxs-lookup"><span data-stu-id="1a8ff-106">In the modern microservices landscape, this type of automated distributed transaction processing isn't possible.</span></span> <span data-ttu-id="1a8ff-107">Es gibt zu viele verschiedene Technologien, darunter relationale Datenbanken, nosql-Datenspeicher und Messaging Systeme, und nicht die Mischung aus Betriebssystemen, Programmiersprachen und Frameworks, die in einer einzigen Umgebung verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="1a8ff-107">There are too many different technologies at play, including relational databases, NoSQL data stores, and messaging systems, not to mention the mix of operating systems, programming languages and frameworks that may be used in a single environment.</span></span>

<span data-ttu-id="1a8ff-108">Bei der verteilten WCF-Transaktion handelt es sich um eine Implementierung, die als [Zweiphasencommit (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol)bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="1a8ff-108">The WCF distributed transaction is an implementation of what is known as a [two-phase commit (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol).</span></span> <span data-ttu-id="1a8ff-109">Es ist möglich, 2PC-Transaktionen manuell zu implementieren, indem Sie Nachrichten über Dienste hinweg koordinieren, offene Transaktionen innerhalb jedes Diensts erstellen und Nachrichten vom Typ "Commit" oder "Rollback" abhängig von Erfolg oder Fehler senden.</span><span class="sxs-lookup"><span data-stu-id="1a8ff-109">It's possible to implement 2PC transactions manually by coordinating messages across services, creating open transactions within each service and sending "commit" or "rollback" messages depending upon success or failure.</span></span> <span data-ttu-id="1a8ff-110">Die Komplexität, die bei der Verwaltung von 2PC beteiligt ist, kann sich jedoch exponentiell erhöhen, wenn sich Systeme weiterentwickeln, und offene Transaktionen enthalten Datenbanksperren, die sich negativ auf die Leistung auswirken können, oder eine schlechtere Anzahl von Dienst übergreifenden Deadlocks verursachen.</span><span class="sxs-lookup"><span data-stu-id="1a8ff-110">However, the complexity that is involved in managing 2PC can increase exponentially as systems evolve, and open transactions hold database locks that can negatively impact performance or, worse, cause cross-service deadlocks.</span></span>

<span data-ttu-id="1a8ff-111">Wenn möglich, ist es am besten, verteilte Transaktionen vollständig zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="1a8ff-111">If possible, it's best to avoid distributed transactions altogether.</span></span> <span data-ttu-id="1a8ff-112">Wenn zwei Datenelemente so verknüpft sind, dass atomarische Updates erforderlich sind, sollten Sie in Erwägung gezogen werden, beide mit dem gleichen Dienst zu behandeln und diese atomaren Änderungen mithilfe einer einzelnen Anforderung oder Nachricht an diesen Dienst anzuwenden.</span><span class="sxs-lookup"><span data-stu-id="1a8ff-112">If two items of data are so linked as to require atomic updates, consider handling them both with the same service, and applying those atomic changes using a single request or message to that service.</span></span>

<span data-ttu-id="1a8ff-113">Wenn dies nicht möglich ist, besteht eine Alternative darin, das [Saga-Muster](https://microservices.io/patterns/data/saga.html)zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="1a8ff-113">If that isn't possible, then one alternative is to use the [Saga pattern](https://microservices.io/patterns/data/saga.html).</span></span> <span data-ttu-id="1a8ff-114">In einer Saga werden Updates sequenziell verarbeitet. Wenn jedes Update erfolgreich ausgeführt wird, wird das nächste Update ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1a8ff-114">In a saga, updates are processing sequentially; as each update succeeds the next one is triggered.</span></span> <span data-ttu-id="1a8ff-115">Diese Trigger können von Dienst zu Dienst oder von einem Saga-Koordinator oder "Orchestrator" weitergegeben werden.</span><span class="sxs-lookup"><span data-stu-id="1a8ff-115">These triggers can be propagated from service to service, or managed by a saga coordinator or "orchestrator".</span></span> <span data-ttu-id="1a8ff-116">Wenn ein Update zu einem beliebigen Zeitpunkt während des Prozesses fehlschlägt, wenden die Dienste, die Ihre Updates bereits abgeschlossen haben, bestimmte Logik an, um Sie umzukehren.</span><span class="sxs-lookup"><span data-stu-id="1a8ff-116">If an update fails at any point during the process, the services that have already completed their updates apply specific logic to reverse them.</span></span>

<span data-ttu-id="1a8ff-117">Eine weitere Möglichkeit ist die Verwendung von Domain-gesteuertem Design (DDD) und Command/Query Responsibility Segregation (cqrs), wie im [e-book für .net-mikrodienste](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="1a8ff-117">Another option is to use Domain Driven Design (DDD) and Command/Query Responsibility Segregation (CQRS), as described in the [.NET Microservices e-book](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/).</span></span> <span data-ttu-id="1a8ff-118">Insbesondere kann die Verwendung von Domänen Ereignissen oder der [Ereignis Beschaffung](https://martinfowler.com/eaaDev/EventSourcing.html) dabei helfen, sicherzustellen, dass Updates konsistent&mdash;werden, wenn Sie nicht sofort&mdash;angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="1a8ff-118">In particular, using domain events or [event sourcing](https://martinfowler.com/eaaDev/EventSourcing.html) can help to ensure that updates are consistently&mdash;if not immediately&mdash;applied.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="1a8ff-119">Vorheriges</span><span class="sxs-lookup"><span data-stu-id="1a8ff-119">Previous</span></span>](application-performance-management.md)
