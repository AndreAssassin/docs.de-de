---
title: Einführung in F#
description: Untersuchen Sie in dieser Tour mithilfe von Codebeispielen einige der wichtigsten Funktionen der Programmiersprache F#.
ms.date: 11/06/2018
ms.openlocfilehash: 64394342777003b33dd77028739fb7209b9f3c86
ms.sourcegitcommit: 621a5f6df00152006160987395b93b5b55f7ffcd
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 05/29/2019
ms.locfileid: "66301252"
---
# <a name="tour-of-f"></a><span data-ttu-id="26a98-103">Einführung in F\#</span><span class="sxs-lookup"><span data-stu-id="26a98-103">Tour of F\#</span></span>

<span data-ttu-id="26a98-104">Der beste Weg zum Kennenlernen von F# besteht darin, F#-Code zu lesen und zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="26a98-104">The best way to learn about F# is to read and write F# code.</span></span> <span data-ttu-id="26a98-105">Dieser Artikel bietet eine Tour durch einige der wichtigsten Funktionen der Programmiersprache F# und stellt einige Codebeispiele bereit, die Sie selbst ausführen können.</span><span class="sxs-lookup"><span data-stu-id="26a98-105">This article will act as a tour through some of the key features of the F# language and give you some code snippets that you can execute on your machine.</span></span> <span data-ttu-id="26a98-106">Weitere Informationen zum Einrichten einer Entwicklungsumgebung finden Sie unter [Erste Schritte](tutorials/getting-started/index.md).</span><span class="sxs-lookup"><span data-stu-id="26a98-106">To learn about setting up a development environment, check out [Getting Started](tutorials/getting-started/index.md).</span></span>

<span data-ttu-id="26a98-107">Es gibt zwei primäre Konzepte in F#: Funktionen und Typen. </span><span class="sxs-lookup"><span data-stu-id="26a98-107">There are two primary concepts in F#: functions and types.</span></span>  <span data-ttu-id="26a98-108">In dieser Tour werden Features der Sprache vorgestellt, die unter diese beiden Konzepte fallen.</span><span class="sxs-lookup"><span data-stu-id="26a98-108">This tour will emphasize features of the language which fall into these two concepts.</span></span>

## <a name="executing-the-code-online"></a><span data-ttu-id="26a98-109">Ausführen des Codes online</span><span class="sxs-lookup"><span data-stu-id="26a98-109">Executing the code online</span></span>

<span data-ttu-id="26a98-110">Wenn Ihnen keine F# auf Ihrem Computer installiert ist, können Sie ausführen alle Beispiele in Ihrem Browser mit [versuchen F# auf WebAssembly](https://tryfsharp.fsbolero.io/).</span><span class="sxs-lookup"><span data-stu-id="26a98-110">If you don't have F# installed on your machine, you can execute all of the samples in your browser with [Try F# on WebAssembly](https://tryfsharp.fsbolero.io/).</span></span> <span data-ttu-id="26a98-111">Fable ist ein Dialekt von F# , die direkt in Ihrem Browser ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="26a98-111">Fable is a dialect of F# that executes directly in your browser.</span></span> <span data-ttu-id="26a98-112">Sehen Sie sich zum Anzeigen der Beispiele, in denen führen Sie in der REPL **Beispiele > erfahren Sie mehr > Überblick F#**  in der linken Menüleiste, der die Fable eine Repl</span><span class="sxs-lookup"><span data-stu-id="26a98-112">To view the samples that follow in the REPL, check out **Samples > Learn > Tour of F#** in the left-hand menu bar of the Fable REPL.</span></span>

## <a name="functions-and-modules"></a><span data-ttu-id="26a98-113">Funktionen und Module</span><span class="sxs-lookup"><span data-stu-id="26a98-113">Functions and Modules</span></span>

<span data-ttu-id="26a98-114">Die wesentlichen Bausteine eines F#-Programms sind ***Funktionen***, die in ***Modulen*** organisiert sind.</span><span class="sxs-lookup"><span data-stu-id="26a98-114">The most fundamental pieces of any F# program are ***functions*** organized into ***modules***.</span></span>  <span data-ttu-id="26a98-115">[Funktionen](language-reference/functions/index.md) arbeiten mit Eingaben, um Ausgaben zu erzeugen, und sie werden in [Modulen](language-reference/modules.md) organisiert – der primären Form der Gruppierung in F#.</span><span class="sxs-lookup"><span data-stu-id="26a98-115">[Functions](language-reference/functions/index.md) perform work on inputs to produce outputs, and they are organized under [Modules](language-reference/modules.md), which are the primary way you group things in F#.</span></span>  <span data-ttu-id="26a98-116">Die Module werden mithilfe der [`let`-Bindung](language-reference/functions/let-bindings.md) definiert, die die Funktion benennt und ihre Argumente definiert.</span><span class="sxs-lookup"><span data-stu-id="26a98-116">They are defined using the [`let` binding](language-reference/functions/let-bindings.md), which give the function a name and define its arguments.</span></span>

[!code-fsharp[BasicFunctions](../../samples/snippets/fsharp/tour.fs#L101-L133)]

<span data-ttu-id="26a98-117">`let` Bindungen sind auch an, wie Sie einen Wert in einen Namen, die einer Variablen in anderen Sprachen wie binden.</span><span class="sxs-lookup"><span data-stu-id="26a98-117">`let` bindings are also how you bind a value to a name, similar to a variable in other languages.</span></span>  <span data-ttu-id="26a98-118">`let` Bindungen sind ***unveränderliche*** standardmäßig, d. h., sobald ein Wert oder eine Funktion in einen Namen gebunden wird ist, es nicht geändert werden kann ein direktes.</span><span class="sxs-lookup"><span data-stu-id="26a98-118">`let` bindings are ***immutable*** by default, which means that once a value or function is bound to a name, it cannot be changed in-place.</span></span>  <span data-ttu-id="26a98-119">Dies steht im Gegensatz zu Variablen in anderen Sprachen, die ***änderbare***, d. h. deren Werte kann geändert werden zu einem beliebigen Zeitpunkt in der Zeit.</span><span class="sxs-lookup"><span data-stu-id="26a98-119">This is in contrast to variables in other languages, which are ***mutable***, meaning their values can be changed at any point in time.</span></span>  <span data-ttu-id="26a98-120">Wenn Sie eine Bindung des änderbare benötigen, können Sie `let mutable ...` Syntax.</span><span class="sxs-lookup"><span data-stu-id="26a98-120">If you require a mutable binding, you can use `let mutable ...` syntax.</span></span>

[!code-fsharp[Immutability](../../samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a><span data-ttu-id="26a98-121">Zahlen, Zeichenfolgen und boolesche Werte</span><span class="sxs-lookup"><span data-stu-id="26a98-121">Numbers, Booleans, and Strings</span></span>

<span data-ttu-id="26a98-122">Als eine .NET-Sprache unterstützt F# die gleichen zugrunde liegenden [primitiven Typen](language-reference/primitive-types.md).</span><span class="sxs-lookup"><span data-stu-id="26a98-122">As a .NET language, F# supports the same underlying [primitive types](language-reference/primitive-types.md) that exist in .NET.</span></span>

<span data-ttu-id="26a98-123">So werden die verschiedenen numerischen Datentypen in F# dargestellt:</span><span class="sxs-lookup"><span data-stu-id="26a98-123">Here is how various numeric types are represented in F#:</span></span>

[!code-fsharp[Numbers](../../samples/snippets/fsharp/tour.fs#L49-L68)]

<span data-ttu-id="26a98-124">Und so sehen boolesche Werte und die grundlegende bedingte Logik aus:</span><span class="sxs-lookup"><span data-stu-id="26a98-124">Here's what Boolean values and performing basic conditional logic looks like:</span></span>

[!code-fsharp[Bools](../../samples/snippets/fsharp/tour.fs#L142-L152)]

<span data-ttu-id="26a98-125">Eine grundlegende Manipulation von [Zeichenfolgen](language-reference/strings.md) sieht wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="26a98-125">And here's what basic [string](language-reference/strings.md) manipulation looks like:</span></span>

[!code-fsharp[Strings](../../samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a><span data-ttu-id="26a98-126">Tupel</span><span class="sxs-lookup"><span data-stu-id="26a98-126">Tuples</span></span>

<span data-ttu-id="26a98-127">[Tupel](language-reference/tuples.md) sind ein großes Thema in F#.</span><span class="sxs-lookup"><span data-stu-id="26a98-127">[Tuples](language-reference/tuples.md) are a big deal in F#.</span></span>  <span data-ttu-id="26a98-128">Bei Tupeln handelt sich um eine Gruppe von unbenannten, jedoch sortierten Werten, die als eigenständige Werte betrachten werden können.</span><span class="sxs-lookup"><span data-stu-id="26a98-128">They are a grouping of unnamed, but ordered values, that can be treated as values themselves.</span></span>  <span data-ttu-id="26a98-129">Stellen Sie sich Werte vor, die aus anderen Werten aggregiert werden.</span><span class="sxs-lookup"><span data-stu-id="26a98-129">Think of them as values which are aggregated from other values.</span></span>  <span data-ttu-id="26a98-130">Sie können vielseitig eingesetzt werden, z.B. für ein bequemes Zurückgeben mehrerer Werte aus einer Funktion oder zur Vereinfachung in einer Ad-hoc-Gruppierung.</span><span class="sxs-lookup"><span data-stu-id="26a98-130">They have many uses, such as conveniently returning multiple values from a function, or grouping values for some ad-hoc convenience.</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L186-L203)]

<span data-ttu-id="26a98-131">Ab F# 4.1 können Sie auch `struct`-Tupel erstellen.</span><span class="sxs-lookup"><span data-stu-id="26a98-131">As of F# 4.1, you can also create `struct` tuples.</span></span>  <span data-ttu-id="26a98-132">Diese bieten vollständige Interoperabilität mit Tupeln aus C# 7/Visual Basic 15, bei denen es sich ebenfalls um `struct`-Tupel handelt:</span><span class="sxs-lookup"><span data-stu-id="26a98-132">These also interoperate fully with C#7/Visual Basic 15 tuples, which are also `struct` tuples:</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L205-L218)]

<span data-ttu-id="26a98-133">Folgendes muss jedoch beachtet werden: `struct`-Tupel sind keine Werttypen, deshalb können sie nicht implizit in Referenz-Tupel konvertiert werden oder umgekehrt.</span><span class="sxs-lookup"><span data-stu-id="26a98-133">It's important to note that because `struct` tuples are value types, they cannot be implicitly converted to reference tuples, or vice versa.</span></span>  <span data-ttu-id="26a98-134">Sie müssen eine explizite Konvertierung zwischen Referenz-Tupel und Struktur-Tupel durchführen.</span><span class="sxs-lookup"><span data-stu-id="26a98-134">You must explicitly convert between a reference and struct tuple.</span></span>

## <a name="pipelines-and-composition"></a><span data-ttu-id="26a98-135">Pipelines und Komposition</span><span class="sxs-lookup"><span data-stu-id="26a98-135">Pipelines and Composition</span></span>

<span data-ttu-id="26a98-136">Übergeben Sie Operatoren wie z. B. `|>` werden häufig verwendet, bei der Verarbeitung von Daten in F#.</span><span class="sxs-lookup"><span data-stu-id="26a98-136">Pipe operators such as `|>` are used extensively when processing data in F#.</span></span> <span data-ttu-id="26a98-137">Diese Operatoren sind Funktionen, die Sie zum Herstellen von "Pipelines" von Funktionen auf flexible Weise zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="26a98-137">These operators are functions that allow you to establish "pipelines" of functions in a flexible manner.</span></span> <span data-ttu-id="26a98-138">Im folgenden Beispiel wird erläutert wie Sie diese Operatoren zum Erstellen einer einfachen funktionalen Pipeline nutzen können:</span><span class="sxs-lookup"><span data-stu-id="26a98-138">The following example walks through how you can take advantage of these operators to build a simple functional pipeline:</span></span>

[!code-fsharp[Pipelines](../../samples/snippets/fsharp/tour.fs#L227-L282)]

<span data-ttu-id="26a98-139">Im vorherigen Beispiel vorgenommen verwenden viele der Features von F#, einschließlich der Liste Verarbeitungsfunktionen, Funktionen, und [teilweise Anwendung](language-reference/functions/index.md#partial-application-of-arguments).</span><span class="sxs-lookup"><span data-stu-id="26a98-139">The previous sample made use of many features of F#, including list processing functions, first-class functions, and [partial application](language-reference/functions/index.md#partial-application-of-arguments).</span></span> <span data-ttu-id="26a98-140">Obwohl ein umfassendes Verständnis all dieser Konzepte einer weiterführenden Erläuterung bedarf, sollte klar geworden sein, wie einfach Funktionen beim Erstellen von Pipelines zum Verarbeiten von Daten verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="26a98-140">Although a deep understanding of each of those concepts can become somewhat advanced, it should be clear how easily functions can be used to process data when building pipelines.</span></span>

## <a name="lists-arrays-and-sequences"></a><span data-ttu-id="26a98-141">Listen, Arrays und Sequenzen</span><span class="sxs-lookup"><span data-stu-id="26a98-141">Lists, Arrays, and Sequences</span></span>

<span data-ttu-id="26a98-142">Listen, Arrays und Sequenzen sind drei primäre Auflistungstypen in der F# -Kernbibliothek.</span><span class="sxs-lookup"><span data-stu-id="26a98-142">Lists, Arrays, and Sequences are three primary collection types in the F# core library.</span></span>

<span data-ttu-id="26a98-143">[Listet](language-reference/lists.md) geordnete, unveränderliche Auflistungen von Elementen des gleichen Typs.</span><span class="sxs-lookup"><span data-stu-id="26a98-143">[Lists](language-reference/lists.md) are ordered, immutable collections of elements of the same type.</span></span>  <span data-ttu-id="26a98-144">Sie sind einfach verknüpften Listen, was bedeutet, dass sie für die Enumeration, aber eine schlechte Wahl für wahlfreien Zugriff und Verkettung vorgesehen sind, wenn sie groß sind.</span><span class="sxs-lookup"><span data-stu-id="26a98-144">They are singly-linked lists, which means they are meant for enumeration, but a poor choice for random access and concatenation if they're large.</span></span>  <span data-ttu-id="26a98-145">Dies ist im Gegensatz zu Listen in andere beliebten Sprachen an, die zur Darstellung von Listen in der Regel keine einfach verknüpften Liste verwenden.</span><span class="sxs-lookup"><span data-stu-id="26a98-145">This in contrast to Lists in other popular languages, which typically do not use a singly-linked list to represent Lists.</span></span>

[!code-fsharp[Lists](../../samples/snippets/fsharp/tour.fs#L309-L359)]

<span data-ttu-id="26a98-146">[Arrays](language-reference/arrays.md) sind feste Größe, *änderbare* Auflistungen von Elementen des gleichen Typs.</span><span class="sxs-lookup"><span data-stu-id="26a98-146">[Arrays](language-reference/arrays.md) are fixed-size, *mutable* collections of elements of the same type.</span></span>  <span data-ttu-id="26a98-147">Diese schnellen, wahlfreien Zugriff von Elementen zu unterstützen, und sind schneller als F#-Listen, da sie nur zusammenhängende Speicherblöcke sind.</span><span class="sxs-lookup"><span data-stu-id="26a98-147">They support fast random access of elements, and are faster than F# lists because they are just contiguous blocks of memory.</span></span>

[!code-fsharp[Arrays](../../samples/snippets/fsharp/tour.fs#L368-L407)]

<span data-ttu-id="26a98-148">[Sequenzen](language-reference/sequences.md) eine logische Reihe von Elementen, alle vom selben Typ sind.</span><span class="sxs-lookup"><span data-stu-id="26a98-148">[Sequences](language-reference/sequences.md) are a logical series of elements, all of the same type.</span></span>  <span data-ttu-id="26a98-149">Dies sind es sich um einen allgemeineren Typ als Listen und Arrays, kann Ihre "View" in jeder logische Reihe von Elementen.</span><span class="sxs-lookup"><span data-stu-id="26a98-149">These are a more general type than Lists and Arrays, capable of being your "view" into any logical series of elements.</span></span>  <span data-ttu-id="26a98-150">Auch herausstellen, da sie sein können ***lazy***, was bedeutet, dass die Elemente berechnet werden können, nur, wenn sie benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="26a98-150">They also stand out because they can be ***lazy***, which means that elements can be computed only when they are needed.</span></span>

[!code-fsharp[Sequences](../../samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a><span data-ttu-id="26a98-151">Rekursive Funktionen</span><span class="sxs-lookup"><span data-stu-id="26a98-151">Recursive Functions</span></span>

<span data-ttu-id="26a98-152">Verarbeiten von Auflistungen oder Sequenzen von Elementen erfolgt in der Regel mit [Rekursion](language-reference/functions/index.md#recursive-functions) in F#.</span><span class="sxs-lookup"><span data-stu-id="26a98-152">Processing collections or sequences of elements is typically done with [recursion](language-reference/functions/index.md#recursive-functions) in F#.</span></span>  <span data-ttu-id="26a98-153">Obwohl F# verfügt über Unterstützung für Schleifen und imperative Programmierung, Rekursion wird bevorzugt, da sie einfacher sicherstellen der Korrektheit ist.</span><span class="sxs-lookup"><span data-stu-id="26a98-153">Although F# has support for loops and imperative programming, recursion is preferred because it is easier to guarantee correctness.</span></span>

> [!NOTE]
> <span data-ttu-id="26a98-154">Das folgende Beispiel verwendet den Musterabgleich über die `match` Ausdruck.</span><span class="sxs-lookup"><span data-stu-id="26a98-154">The following example makes use of the pattern matching via the `match` expression.</span></span>  <span data-ttu-id="26a98-155">Diese grundlegenden Konstrukt wird weiter unten in diesem Artikel behandelt.</span><span class="sxs-lookup"><span data-stu-id="26a98-155">This fundamental construct is covered later in this article.</span></span>

[!code-fsharp[RecursiveFunctions](../../samples/snippets/fsharp/tour.fs#L461-L500)]

<span data-ttu-id="26a98-156">F#verfügt außerdem über vollständige Unterstützung für Ende aufrufen, Optimierung, dies ist eine Möglichkeit, rekursive Aufrufe optimieren, damit sie ebenso schnell als eine Schleifenkonstruktion sind.</span><span class="sxs-lookup"><span data-stu-id="26a98-156">F# also has full support for Tail Call Optimization, which is a way to optimize recursive calls so that they are just as fast as a loop construct.</span></span>

## <a name="record-and-discriminated-union-types"></a><span data-ttu-id="26a98-157">Datensatz- und Unterscheidungs-Union-Typen</span><span class="sxs-lookup"><span data-stu-id="26a98-157">Record and Discriminated Union Types</span></span>

<span data-ttu-id="26a98-158">Datensatz- und Union-Typen werden zwei grundlegende Datentypen in verwendet F# code, und sind im Allgemeinen die beste Möglichkeit zum Darstellen der Daten in eine F# Programm.</span><span class="sxs-lookup"><span data-stu-id="26a98-158">Record and Union types are two fundamental data types used in F# code, and are generally the best way to represent data in an F# program.</span></span>  <span data-ttu-id="26a98-159">Auch wenn sie ähneln Klassen in anderen Sprachen dadurch, ist ihre primäre Unterschied, dass sie die strukturelle Gleichheitssemantik aufweisen.</span><span class="sxs-lookup"><span data-stu-id="26a98-159">Although this makes them similar to classes in other languages, one of their primary differences is that they have structural equality semantics.</span></span>  <span data-ttu-id="26a98-160">Dies bedeutet, dass sie "nativ" vergleichbar und Gleichheit einfach ist: nur überprüfen, ob eine gleich dem anderem ist.</span><span class="sxs-lookup"><span data-stu-id="26a98-160">This means that they are "natively" comparable and equality is straightforward - just check if one is equal to the other.</span></span>

<span data-ttu-id="26a98-161">[Datensätze](language-reference/records.md) sind ein Aggregat benannter Werte, mit optionalen Elementen (z. B. Methoden).</span><span class="sxs-lookup"><span data-stu-id="26a98-161">[Records](language-reference/records.md) are an aggregate of named values, with optional members (such as methods).</span></span>  <span data-ttu-id="26a98-162">Wenn Sie mit c# oder Java vertraut sind, sollten klicken Sie dann diese Poco-Klassen oder POJOs - ähnelt nur mit strukturelle Gleichheit und weniger Aufwand können.</span><span class="sxs-lookup"><span data-stu-id="26a98-162">If you're familiar with C# or Java, then these should feel similar to POCOs or POJOs - just with structural equality and less ceremony.</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L507-L559)]

<span data-ttu-id="26a98-163">Ab F# 4.1, können Sie auch Datensätze darstellen `struct`s.</span><span class="sxs-lookup"><span data-stu-id="26a98-163">As of F# 4.1, you can also represent Records as `struct`s.</span></span>  <span data-ttu-id="26a98-164">Dies erfolgt mit der `[<Struct>]` Attribut:</span><span class="sxs-lookup"><span data-stu-id="26a98-164">This is done with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L561-L568)]

<span data-ttu-id="26a98-165">[Unterscheidungs-Unions (Verteilungseinheiten)](language-reference/discriminated-unions.md) sind Werte, die eine Reihe von benannten Formulare oder Fälle werden konnte.</span><span class="sxs-lookup"><span data-stu-id="26a98-165">[Discriminated Unions (DUs)](language-reference/discriminated-unions.md) are values which could be a number of named forms or cases.</span></span>  <span data-ttu-id="26a98-166">In den Typ gespeicherte Daten können es sich um eine von mehreren unterschiedlichen Werten sein.</span><span class="sxs-lookup"><span data-stu-id="26a98-166">Data stored in the type can be one of several distinct values.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L575-L631)]

<span data-ttu-id="26a98-167">Sie können auch die Verteilungseinheiten als *Einzelfall-Unterscheidungs-Unions*, um Unterstützung bei der domänenmodellierung über primitive Typen.</span><span class="sxs-lookup"><span data-stu-id="26a98-167">You can also use DUs as *Single-Case Discriminated Unions*, to help with domain modeling over primitive types.</span></span>  <span data-ttu-id="26a98-168">Oft durchläuft, Zeichenfolgen und anderen primitiven Typen werden verwendet, um etwas darstellen, und erhalten somit eine besondere Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="26a98-168">Often times, strings and other primitive types are used to represent something, and are thus given a particular meaning.</span></span>  <span data-ttu-id="26a98-169">Jedoch kann nur die primitiven Darstellung der Daten führen beim Zuweisen von versehentlich ein falscher Wert.</span><span class="sxs-lookup"><span data-stu-id="26a98-169">However, using only the primitive representation of the data can result in mistakenly assigning an incorrect value!</span></span>  <span data-ttu-id="26a98-170">Jede Art von Informationen wie eine unterschiedliche Einzelfall-Union darstellt, kann Richtigkeit, die in diesem Szenario erzwingen.</span><span class="sxs-lookup"><span data-stu-id="26a98-170">Representing each type of information as a distinct single-case union can enforce correctness in this scenario.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L633-L654)]

<span data-ttu-id="26a98-171">Wie im obige Beispiel wird veranschaulicht, um den zugrunde liegenden Wert in einen Einzelfall-Unterscheidungs-Union zu erhalten, müssen Sie explizit entpacken.</span><span class="sxs-lookup"><span data-stu-id="26a98-171">As the above sample demonstrates, to get the underlying value in a single-case Discriminated Union, you must explicitly unwrap it.</span></span>

<span data-ttu-id="26a98-172">Darüber hinaus unterstützen Verteilungseinheiten auch Definitionen werden rekursive, sodass Sie problemlos die Strukturen und grundsätzlich rekursive Daten darstellen.</span><span class="sxs-lookup"><span data-stu-id="26a98-172">Additionally, DUs also support recursive definitions, allowing you to easily represent trees and inherently recursive data.</span></span>  <span data-ttu-id="26a98-173">Beispielsweise sieht wie Sie einer binären Suchstruktur mit darstellen können `exists` und `insert` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="26a98-173">For example, here's how you can represent a Binary Search Tree with `exists` and `insert` functions.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L656-L683)]

<span data-ttu-id="26a98-174">Da Verteilungseinheiten die rekursive Struktur der Struktur in den Datentyp darstellen können, auf diese rekursive Struktur ist unkompliziert und garantiert auf Richtigkeit.</span><span class="sxs-lookup"><span data-stu-id="26a98-174">Because DUs allow you to represent the recursive structure of the tree in the data type, operating on this recursive structure is straightforward and guarantees correctness.</span></span>  <span data-ttu-id="26a98-175">Es wird auch in einem Mustervergleich unterstützt, wie unten dargestellt.</span><span class="sxs-lookup"><span data-stu-id="26a98-175">It is also supported in pattern matching, as shown below.</span></span>

<span data-ttu-id="26a98-176">Sie können darüber hinaus Verteilungseinheiten als darstellen `struct`mit der `[<Struct>]` Attribut:</span><span class="sxs-lookup"><span data-stu-id="26a98-176">Additionally, you can represent DUs as `struct`s with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L685-L696)]

<span data-ttu-id="26a98-177">Es gibt jedoch zwei wichtige Aspekte zu bedenken, dabei:</span><span class="sxs-lookup"><span data-stu-id="26a98-177">However, there are two key things to keep in mind when doing so:</span></span>

1. <span data-ttu-id="26a98-178">Eine Struktur DU darf nicht rekursiv definiert sein.</span><span class="sxs-lookup"><span data-stu-id="26a98-178">A struct DU cannot be recursively-defined.</span></span>
2. <span data-ttu-id="26a98-179">Eine Struktur DU muss für jeden der Fälle einen eindeutige Namen haben.</span><span class="sxs-lookup"><span data-stu-id="26a98-179">A struct DU must have unique names for each of its cases.</span></span>

<span data-ttu-id="26a98-180">Fehler bei den oben genannten folgen, führt zu einem Kompilierungsfehler.</span><span class="sxs-lookup"><span data-stu-id="26a98-180">Failure to follow the above will result in a compilation error.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="26a98-181">Musterabgleich</span><span class="sxs-lookup"><span data-stu-id="26a98-181">Pattern Matching</span></span>

<span data-ttu-id="26a98-182">[Übereinstimmende Muster](language-reference/pattern-matching.md) ist die F#-Sprache-Funktion die Richtigkeit für Vorgänge für F#-Typen ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="26a98-182">[Pattern Matching](language-reference/pattern-matching.md) is the F# language feature which enables correctness for operating on F# types.</span></span>  <span data-ttu-id="26a98-183">In den obigen Beispielen haben Sie wahrscheinlich bemerkt, dass einiges an `match x with ...` Syntax.</span><span class="sxs-lookup"><span data-stu-id="26a98-183">In the above samples, you probably noticed quite a bit of `match x with ...` syntax.</span></span>  <span data-ttu-id="26a98-184">Dieses Konstrukt kann den Compiler, der verstehen kann, die "Form" Datentypen, um gezwungen, alle möglichen Fälle berücksichtigen, wenn ein Datentyp, durch was bekannt ist als vollständige Musterabgleich mit.</span><span class="sxs-lookup"><span data-stu-id="26a98-184">This construct allows the compiler, which can understand the "shape" of data types, to force you to account for all possible cases when using a data type through what is known as Exhaustive Pattern Matching.</span></span>  <span data-ttu-id="26a98-185">Dies ist unglaublich leistungsfähige auf Richtigkeit, und auf "heben", was normalerweise relevant Runtime in während der Kompilierung wäre clever verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="26a98-185">This is incredibly powerful for correctness, and can be cleverly used to "lift" what would normally be a runtime concern into compile-time.</span></span>

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L705-L742)]

<span data-ttu-id="26a98-186">Sie haben möglicherweise bemerkt wird die Verwendung von der `_` Muster.</span><span class="sxs-lookup"><span data-stu-id="26a98-186">Something you may have noticed is the use of the `_` pattern.</span></span>  <span data-ttu-id="26a98-187">Dies bezeichnet man als den [Platzhaltermuster](language-reference/pattern-matching.md#wildcard-pattern), dies ist eine Möglichkeit, mit dem Text "Keine Rolle, was etwas ist".</span><span class="sxs-lookup"><span data-stu-id="26a98-187">This is known as the [Wildcard Pattern](language-reference/pattern-matching.md#wildcard-pattern), which is a way of saying "I don't care what something is".</span></span>  <span data-ttu-id="26a98-188">Zwar praktisch ist, können Sie versehentlich zu umgehen, vollständig Musterabgleich und nicht mehr während der Kompilierung Gebieten profitieren, wenn man sich mit nicht `_`.</span><span class="sxs-lookup"><span data-stu-id="26a98-188">Although convenient, you can accidentally bypass Exhaustive Pattern Matching and no longer benefit from compile-time enforcements if you aren't careful in using `_`.</span></span>  <span data-ttu-id="26a98-189">Es wird am besten verwendet, wenn Sie bestimmte Teile eines zerlegten Typs nicht relevant ist wenn Muster Abgleich oder die letzte Klausel, wenn Sie alle sinnvolle Fälle in einem musterabgleichsausdruck aufgezählt haben.</span><span class="sxs-lookup"><span data-stu-id="26a98-189">It is best used when you don't care about certain pieces of a decomposed type when pattern matching, or the final clause when you have enumerated all meaningful cases in a pattern matching expression.</span></span>

<span data-ttu-id="26a98-190">[Aktive Muster](language-reference/active-patterns.md) ein anderes leistungsfähiges Konstrukt mit dem Mustervergleich verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="26a98-190">[Active Patterns](language-reference/active-patterns.md) are another powerful construct to use with pattern matching.</span></span>  <span data-ttu-id="26a98-191">Sie können zum Partitionieren der Eingabedaten in benutzerdefinierten Formulare, zerlegt wird sie an der Aufrufsite für Muster übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="26a98-191">They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</span></span>  <span data-ttu-id="26a98-192">Sie können auch parametrisiert werden und somit zur Definition der Partition als Funktion ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="26a98-192">They can also be parameterized, thus allowing to define the partition as a function.</span></span>  <span data-ttu-id="26a98-193">Erweitern im vorherige Beispiel zur Unterstützung von aktive Muster sieht etwa folgendermaßen aus:</span><span class="sxs-lookup"><span data-stu-id="26a98-193">Expanding the previous example to support Active Patterns looks something like this:</span></span>

[!code-fsharp[ActivePatterns](../../samples/snippets/fsharp/tour.fs#L764-L786)]

## <a name="optional-types"></a><span data-ttu-id="26a98-194">Optionale Typen</span><span class="sxs-lookup"><span data-stu-id="26a98-194">Optional Types</span></span>

<span data-ttu-id="26a98-195">Ein Sonderfall des Unterscheidungs-Union-Typen ist der Typ, der eignet sich daher, dass es sich um einen Teil der F#-Kernbibliothek ist.</span><span class="sxs-lookup"><span data-stu-id="26a98-195">One special case of Discriminated Union types is the Option Type, which is so useful that it's a part of the F# core library.</span></span>

<span data-ttu-id="26a98-196">[Der Optionstyp](language-reference/options.md) ist ein Typ, der eine der beiden Fälle darstellt: ein Wert oder nichts überhaupt.</span><span class="sxs-lookup"><span data-stu-id="26a98-196">[The Option Type](language-reference/options.md) is a type which represents one of two cases: a value, or nothing at all.</span></span>  <span data-ttu-id="26a98-197">Sie wird in jedem Szenario verwendet, in dem ein Wert möglicherweise vorhanden oder kann nicht von einem bestimmten Vorgang führen.</span><span class="sxs-lookup"><span data-stu-id="26a98-197">It is used in any scenario where a value may or may not result from a particular operation.</span></span>  <span data-ttu-id="26a98-198">Dies zwingt dann für beide Fälle, die ein Problem während der Kompilierung, anstatt ein Laufzeit-Problem somit berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="26a98-198">This then forces you to account for both cases, making it a compile-time concern rather than a runtime concern.</span></span>  <span data-ttu-id="26a98-199">Diese werden häufig in APIs verwendet, in denen `null` wird verwendet, um "nichts" stattdessen darstellen und Sie somit kümmern müssen `NullReferenceException` in vielen Fällen.</span><span class="sxs-lookup"><span data-stu-id="26a98-199">These are often used in APIs where `null` is used to represent "nothing" instead, thus eliminating the need to worry about `NullReferenceException` in many circumstances.</span></span>

[!code-fsharp[Options](../../samples/snippets/fsharp/tour.fs#L789-L814)]

## <a name="units-of-measure"></a><span data-ttu-id="26a98-200">Maßeinheiten</span><span class="sxs-lookup"><span data-stu-id="26a98-200">Units of Measure</span></span>

<span data-ttu-id="26a98-201">Eine einzigartige Funktion des F# Typsystem ist die Möglichkeit, den Kontext für numerische Literale durch Einheiten bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="26a98-201">One unique feature of F#'s type system is the ability to provide context for numeric literals through Units of Measure.</span></span>

<span data-ttu-id="26a98-202">[Maßeinheiten](language-reference/units-of-measure.md) ermöglichen Ihnen das Zuordnen eines numerischen Typs mit einer Einheit, z. B. Meter und haben Funktionen ausführen können Einheiten anstelle numerischer Literale.</span><span class="sxs-lookup"><span data-stu-id="26a98-202">[Units of Measure](language-reference/units-of-measure.md) allow you to associate a numeric type to a unit, such as Meters, and have functions perform work on units rather than numeric literals.</span></span>  <span data-ttu-id="26a98-203">Dies ermöglicht es den Compiler an, stellen Sie sicher, dass die Typen von numerischen Literalen übergebenen sinnvoll unter einem bestimmten Kontext, wodurch persistenzspeicherpunkte Laufzeitfehler zugeordnet, dass diese Art von Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="26a98-203">This enables the compiler to verify that the types of numeric literals passed in make sense under a certain context, thus eliminating runtime errors associated with that kind of work.</span></span>

[!code-fsharp[UnitsOfMeasure](../../samples/snippets/fsharp/tour.fs#L817-L842)]

<span data-ttu-id="26a98-204">Die F# viele SI-Typen und einheitenkonvertierungen definiert.</span><span class="sxs-lookup"><span data-stu-id="26a98-204">The F# Core library defines many SI unit types and unit conversions.</span></span>  <span data-ttu-id="26a98-205">Weitere Informationen finden Sie die [Microsoft.FSharp.Data.UnitSystems.SI-Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="26a98-205">To learn more, check out the [Microsoft.FSharp.Data.UnitSystems.SI Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span></span>

## <a name="classes-and-interfaces"></a><span data-ttu-id="26a98-206">Klassen und Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="26a98-206">Classes and Interfaces</span></span>

<span data-ttu-id="26a98-207">F#Außerdem bietet vollständige Unterstützung für .NET-Klassen, [Schnittstellen](language-reference/interfaces.md), [abstrakte Klassen](language-reference/abstract-classes.md), [Vererbung](language-reference/inheritance.md)und so weiter.</span><span class="sxs-lookup"><span data-stu-id="26a98-207">F# also has full support for .NET classes, [Interfaces](language-reference/interfaces.md), [Abstract Classes](language-reference/abstract-classes.md), [Inheritance](language-reference/inheritance.md), and so on.</span></span>

<span data-ttu-id="26a98-208">[Klassen](language-reference/classes.md) sind Typen, die .NET Objekte darstellen. die Eigenschaften, Methoden und Ereignisse wie stehen die [Mitglieder](language-reference/members/index.md).</span><span class="sxs-lookup"><span data-stu-id="26a98-208">[Classes](language-reference/classes.md) are types that represent .NET objects, which can have properties, methods, and events as its [Members](language-reference/members/index.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L845-L880)]

<span data-ttu-id="26a98-209">Definieren von generischen Klassen ist auch sehr einfach.</span><span class="sxs-lookup"><span data-stu-id="26a98-209">Defining generic classes is also very straightforward.</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L883-L908)]

<span data-ttu-id="26a98-210">Um eine Schnittstelle zu implementieren, können Sie mithilfe einer `interface ... with` Syntax oder [Objektausdruck](language-reference/object-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="26a98-210">To implement an Interface, you can use either `interface ... with` syntax or an [Object Expression](language-reference/object-expressions.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L911-L934)]

## <a name="which-types-to-use"></a><span data-ttu-id="26a98-211">Welche Typen sollen verwenden</span><span class="sxs-lookup"><span data-stu-id="26a98-211">Which Types to Use</span></span>

<span data-ttu-id="26a98-212">Das Vorhandensein von Klassen, die Datensätze, die Unterscheidungs-Unions und Tupel führt, um eine wichtige Frage: Welche sollten Sie verwenden?</span><span class="sxs-lookup"><span data-stu-id="26a98-212">The presence of Classes, Records, Discriminated Unions, and Tuples leads to an important question: which should you use?</span></span>  <span data-ttu-id="26a98-213">Wie fast alles im Leben hängt Ihre Situation die Antwort.</span><span class="sxs-lookup"><span data-stu-id="26a98-213">Like most everything in life, the answer depends on your circumstances.</span></span>

<span data-ttu-id="26a98-214">Tupel sind hervorragend für zurückgeben mehrerer Werte aus einer Funktion und ein Aggregat Ad-hoc-Werte als ein Wert selbst.</span><span class="sxs-lookup"><span data-stu-id="26a98-214">Tuples are great for returning multiple values from a function, and using an ad-hoc aggregate of values as a value itself.</span></span>

<span data-ttu-id="26a98-215">Datensätze sind eine "Step-up" von Tupeln, dass mit dem Namen, Beschriftungen und Unterstützung für optionale Member.</span><span class="sxs-lookup"><span data-stu-id="26a98-215">Records are a "step up" from Tuples, having named labels and support for optional members.</span></span>  <span data-ttu-id="26a98-216">Sie eignen sich hervorragend für eine ungezwungene-Darstellung der Daten bei der Übertragung über das Programm.</span><span class="sxs-lookup"><span data-stu-id="26a98-216">They are great for a low-ceremony representation of data in-transit through your program.</span></span>  <span data-ttu-id="26a98-217">Da sie auf Strukturgleichheit überprüft haben, sind sie Vergleich einfach zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="26a98-217">Because they have structural equality, they are easy to use with comparison.</span></span>

<span data-ttu-id="26a98-218">Unterscheidungs-Unions sind vielseitig, aber die Kern-Benefit ist in der Lage, nutzen diese in Verbindung mit dem Mustervergleich berücksichtigen, die für alle möglichen "Formen", die eine Daten enthalten können.</span><span class="sxs-lookup"><span data-stu-id="26a98-218">Discriminated Unions have many uses, but the core benefit is to be able to utilize them in conjunction with Pattern Matching to account for all possible "shapes" that a data can have.</span></span>  

<span data-ttu-id="26a98-219">Klassen eignen sich hervorragend für eine Vielzahl von Gründen, z. B. Wenn Sie Informationen darstellen und mit denen Sie diese Informationen an Funktionalität auch verknüpfen müssen.</span><span class="sxs-lookup"><span data-stu-id="26a98-219">Classes are great for a huge number of reasons, such as when you need to represent information and also tie that information to functionality.</span></span>  <span data-ttu-id="26a98-220">Als Faustregel gilt Wenn Sie Funktionen verfügen, die im Prinzip um einige Daten gebunden ist ist mithilfe von Klassen und die Prinzipien der objektorientierten Programmierung ein großer Vorteil.</span><span class="sxs-lookup"><span data-stu-id="26a98-220">As a rule of thumb, when you have functionality which is conceptually tied to some data, using Classes and the principles of Object-Oriented Programming is a big benefit.</span></span>  <span data-ttu-id="26a98-221">Klassen sind auch der bevorzugte Datentyp bei der Interaktion mit c# und Visual Basic, als diese Sprachen Klassen für nahezu alle verwenden.</span><span class="sxs-lookup"><span data-stu-id="26a98-221">Classes are also the preferred data type when interoperating with C# and Visual Basic, as these languages use classes for nearly everything.</span></span>

## <a name="next-steps"></a><span data-ttu-id="26a98-222">Nächste Schritte</span><span class="sxs-lookup"><span data-stu-id="26a98-222">Next Steps</span></span>

<span data-ttu-id="26a98-223">Nun, Sie, dass einige der wichtigsten Funktionen der Sprache gesehen haben, sollten Sie Ihre erste schreiben werden F# Programme!</span><span class="sxs-lookup"><span data-stu-id="26a98-223">Now that you've seen some of the primary features of the language, you should be ready to write your first F# programs!</span></span>  <span data-ttu-id="26a98-224">Sehen Sie sich [Einstieg](tutorials/getting-started/index.md) zu erfahren, wie Sie Ihre Entwicklungsumgebung einrichten, und Schreiben von Code.</span><span class="sxs-lookup"><span data-stu-id="26a98-224">Check out [Getting Started](tutorials/getting-started/index.md) to learn how to set up your development environment and write some code.</span></span>

<span data-ttu-id="26a98-225">Die nächsten Schritte für weitere können beliebig sein, aber es wird empfohlen [Einführung in die funktionale Programmierung in F# ](introduction-to-functional-programming/index.md) abzurufenden mit Core Konzepte der funktionalen Programmierung vertraut.</span><span class="sxs-lookup"><span data-stu-id="26a98-225">The next steps for learning more can be whatever you like, but we recommend [Introduction to Functional Programming in F#](introduction-to-functional-programming/index.md) to get comfortable with core Functional Programming concepts.</span></span>  <span data-ttu-id="26a98-226">Dieser werden wichtige bei der Erstellung von robusten Programme in F#.</span><span class="sxs-lookup"><span data-stu-id="26a98-226">These will be essential in building robust programs in F#.</span></span>

<span data-ttu-id="26a98-227">Darüber hinaus sehen Sie sich die [F#-Sprachreferenz](language-reference/index.md) eine umfangreiche Sammlung von konzeptionellen Inhalten in F# angezeigt.</span><span class="sxs-lookup"><span data-stu-id="26a98-227">Also, check out the [F# Language Reference](language-reference/index.md) to see a comprehensive collection of conceptual content on F#.</span></span>
