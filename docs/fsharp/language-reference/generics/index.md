---
title: Generics
description: Erfahren Sie, wie Sie mithilfe generischer F#-Funktionen und Typen, die Sie Code schreiben, die mit einer Vielzahl von Typen funktioniert, ohne Code wiederholen zu ermöglichen.
ms.date: 05/16/2016
ms.openlocfilehash: 5d6e57762095e44836425f90d21a6c1dc71edaaa
ms.sourcegitcommit: cdf67135a98a5a51913dacddb58e004a3c867802
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/21/2019
ms.locfileid: "69666692"
---
# <a name="generics"></a><span data-ttu-id="8e2cd-103">Generics</span><span class="sxs-lookup"><span data-stu-id="8e2cd-103">Generics</span></span>

<span data-ttu-id="8e2cd-104">F#-Funktionswerte, -Methoden, -Eigenschaften und -Aggregattypen, wie z.B. Klassen und Unterscheidungs-Unions können *generisch* sein.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-104">F# function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be *generic*.</span></span> <span data-ttu-id="8e2cd-105">Generische Konstrukte enthalten mindestens einen Typparameter, die in der Regel vom Benutzer des generischen Konstrukts angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-105">Generic constructs contain at least one type parameter, which is usually supplied by the user of the generic construct.</span></span> <span data-ttu-id="8e2cd-106">Mit generischen Funktionen und Typen können Sie Code schreiben, der mit einer Vielzahl von Typen funktioniert, ohne den Code für jeden Typ zu wiederholen.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-106">Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</span></span> <span data-ttu-id="8e2cd-107">Ihren Code generisch zu erstellen kann einfach sein, da Ihr Code häufig implizit abgeleitet wird, um durch den Typrückschluss des Compilers und durch automatische Verallgemeinerungsmechanismen generisch zu sein.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-107">Making your code generic can be simple in F#, because often your code is implicitly inferred to be generic by the compiler's type inference and automatic generalization mechanisms.</span></span>

## <a name="syntax"></a><span data-ttu-id="8e2cd-108">Syntax</span><span class="sxs-lookup"><span data-stu-id="8e2cd-108">Syntax</span></span>

```fsharp
// Explicitly generic function.
let function-name<type-parameters> parameter-list =
function-body

// Explicitly generic method.
[ static ] member object-identifer.method-name<type-parameters> parameter-list [ return-type ] =
method-body

// Explicitly generic class, record, interface, structure,
// or discriminated union.
type type-name<type-parameters> type-definition
```

## <a name="remarks"></a><span data-ttu-id="8e2cd-109">Hinweise</span><span class="sxs-lookup"><span data-stu-id="8e2cd-109">Remarks</span></span>

<span data-ttu-id="8e2cd-110">Die Deklaration einer explizit generischen Funktion oder eines Typs entspricht weitgehend einer nicht generischen Funktion oder des Typs, mit Ausnahme der Spezifikation (und Verwendung) der Typparameter in spitzen Klammern nach dem Namen der Funktion oder des Typs.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-110">The declaration of an explicitly generic function or type is much like that of a non-generic function or type, except for the specification (and use) of the type parameters, in angle brackets after the function or type name.</span></span>

<span data-ttu-id="8e2cd-111">Deklarationen sind oft implizit generisch.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-111">Declarations are often implicitly generic.</span></span> <span data-ttu-id="8e2cd-112">Wenn Sie den Typ jedes Parameters nicht vollständig angeben, der zum Erstellen einer Funktion oder eines Typs verwendet wird, versucht der Compiler den Typ jedes einzelnen Parameters, Werts und jeder Variablen aus dem Code, den Sie schreiben, abzuleiten.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-112">If you do not fully specify the type of every parameter that is used to compose a function or type, the compiler attempts to infer the type of each parameter, value, and variable from the code you write.</span></span> <span data-ttu-id="8e2cd-113">Weitere Informationen finden Sie unter [Type Inference (F#)](../type-inference.md).</span><span class="sxs-lookup"><span data-stu-id="8e2cd-113">For more information, see [Type Inference](../type-inference.md).</span></span> <span data-ttu-id="8e2cd-114">Wenn der Code für Ihren Typ oder die Funktion die Typen der Parameter nicht anderweitig einschränkt, ist die Funktion oder der Typ implizit generisch.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-114">If the code for your type or function does not otherwise constrain the types of parameters, the function or type is implicitly generic.</span></span> <span data-ttu-id="8e2cd-115">Dieser Prozess heißt *automatische Verallgemeinerung*.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-115">This process is named *automatic generalization*.</span></span> <span data-ttu-id="8e2cd-116">Es gibt einige Einschränkungen für die automatische Verallgemeinerung.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-116">There are some limits on automatic generalization.</span></span> <span data-ttu-id="8e2cd-117">Wenn beispielsweise der F#-Compiler die Typen für ein generisches Konstrukt nicht ableiten kann, meldet der Compiler einen Fehler, der sich auf eine Einschränkung namens *Wertebeschränkung* bezieht.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-117">For example, if the F# compiler is unable to infer the types for a generic construct, the compiler reports an error that refers to a restriction called the *value restriction*.</span></span> <span data-ttu-id="8e2cd-118">In diesem Fall müssen Sie möglicherweise einige Typanmerkungen hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-118">In that case, you may have to add some type annotations.</span></span> <span data-ttu-id="8e2cd-119">Weitere Informationen über die automatische Verallgemeinerung und die Wertebeschränkung, und wie Sie den Code ändern, um das Problem zu lösen, finden Sie unter [Automatische Verallgemeinerung](automatic-generalization.md).</span><span class="sxs-lookup"><span data-stu-id="8e2cd-119">For more information about automatic generalization and the value restriction, and how to change your code to address the problem, see [Automatic Generalization](automatic-generalization.md).</span></span>

<span data-ttu-id="8e2cd-120">In der vorherigen Syntax ist *type-parameters* eine durch Trennzeichen getrennte Liste von Parametern, die unbekannte Typen darstellen, jeweils beginnend mit einem einfachen Anführungszeichen und optional mit einer Einschränkungsklausel, die weiter begrenzt, welche Typen für den Typparameter verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-120">In the previous syntax, *type-parameters* is a comma-separated list of parameters that represent unknown types, each of which starts with a single quotation mark, optionally with a constraint clause that further limits what types may be used for that type parameter.</span></span> <span data-ttu-id="8e2cd-121">Die Syntax für Einschränkungsklauseln verschiedener Arten und andere Informationen zu Einschränkungen finden Sie unter [Einschränkungen](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="8e2cd-121">For the syntax for constraint clauses of various kinds and other information about constraints, see [Constraints](constraints.md).</span></span>

<span data-ttu-id="8e2cd-122">Die *type-definition* in der Syntax entspricht der Typdefinition für einen nicht generischen Typ.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-122">The *type-definition* in the syntax is the same as the type definition for a non-generic type.</span></span> <span data-ttu-id="8e2cd-123">Sie enthält die Konstruktorparameter für einen Klassentyp, eine optionale `as`-Klausel, das gleiche Symbol, die Datensatzfelder, die `inherit`-Klausel, die Optionen für eine Unterscheidungs-Union, `let`- und `do`-Bindungen, die Memberdefinitionen und alles andere, was in einer nicht generischen Typdefinition zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-123">It includes the constructor parameters for a class type, an optional `as` clause, the equal symbol, the record fields, the `inherit` clause, the choices for a discriminated union, `let` and `do` bindings, member definitions, and anything else permitted in a non-generic type definition.</span></span>

<span data-ttu-id="8e2cd-124">Die anderen Syntaxelemente sind identisch mit denen für nicht generische Funktionen und Typen.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-124">The other syntax elements are the same as those for non-generic functions and types.</span></span> <span data-ttu-id="8e2cd-125">Beispielsweise ist *object-identifier* ein Bezeichner, der das enthaltende Objekt selbst darstellt.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-125">For example, *object-identifier* is an identifier that represents the containing object itself.</span></span>

<span data-ttu-id="8e2cd-126">Eigenschaften, Felder und Konstruktoren können nicht generischer als der einschließende Typ sein.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-126">Properties, fields, and constructors cannot be more generic than the enclosing type.</span></span> <span data-ttu-id="8e2cd-127">Außerdem können Werte in einem Modul nicht generisch sein.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-127">Also, values in a module cannot be generic.</span></span>

## <a name="implicitly-generic-constructs"></a><span data-ttu-id="8e2cd-128">Implizit generische Konstrukte</span><span class="sxs-lookup"><span data-stu-id="8e2cd-128">Implicitly Generic Constructs</span></span>

<span data-ttu-id="8e2cd-129">Wenn der F#-Compiler die Typen im Code ableitet, behandelt es automatisch alle Funktionen, die als Generische generisch sein können.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-129">When the F# compiler infers the types in your code, it automatically treats any function that can be generic as generic.</span></span> <span data-ttu-id="8e2cd-130">Wenn Sie einen Typ explizit angeben, wie z.B. einen Parametertyp, verhindern Sie die automatische Verallgemeinerung.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-130">If you specify a type explicitly, such as a parameter type, you prevent automatic generalization.</span></span>

<span data-ttu-id="8e2cd-131">Im folgenden Codebeispiel ist `makeList` generisch, obwohl weder es noch seine Parameter explizit als generisch deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-131">In the following code example, `makeList` is generic, even though neither it nor its parameters are explicitly declared as generic.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1700.fs)]

<span data-ttu-id="8e2cd-132">Die Signatur der Funktion wird als `'a -> 'a -> 'a list` abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-132">The signature of the function is inferred to be `'a -> 'a -> 'a list`.</span></span> <span data-ttu-id="8e2cd-133">Beachten Sie, dass `a` und `b` in diesem Beispiel abgeleitet werden, um über den gleichen Typ zu verfügen.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-133">Note that `a` and `b` in this example are inferred to have the same type.</span></span> <span data-ttu-id="8e2cd-134">Dies ist, da sie zusammen in einer Liste enthalten sind, und alle Elemente einer Liste müssen vom gleichen Typ sein.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-134">This is because they are included in a list together, and all elements of a list must be of the same type.</span></span>

<span data-ttu-id="8e2cd-135">Sie können auch eine Funktion generisch erstellen, indem Sie die Syntax für einfache Anführungszeichen in einer Typanmerkung verwenden, um anzugeben, dass ein Parametertyp ein generischer Typparameter ist.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-135">You can also make a function generic by using the single quotation mark syntax in a type annotation to indicate that a parameter type is a generic type parameter.</span></span> <span data-ttu-id="8e2cd-136">Im folgenden Code ist `function1` generisch, da seine Parameter auf diese Weise als Typparameter deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-136">In the following code, `function1` is generic because its parameters are declared in this manner, as type parameters.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1701.fs)]

## <a name="explicitly-generic-constructs"></a><span data-ttu-id="8e2cd-137">Explizit generische Konstrukte</span><span class="sxs-lookup"><span data-stu-id="8e2cd-137">Explicitly Generic Constructs</span></span>

<span data-ttu-id="8e2cd-138">Sie können eine Funktion auch generisch erstellen, indem Sie seine Typparameter explizit in spitzen Klammern (`<type-parameter>`) deklarieren.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-138">You can also make a function generic by explicitly declaring its type parameters in angle brackets (`<type-parameter>`).</span></span> <span data-ttu-id="8e2cd-139">Dies wird im folgenden Code veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-139">The following code illustrates this.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1703.fs)]

## <a name="using-generic-constructs"></a><span data-ttu-id="8e2cd-140">Verwenden von generischen Konstrukten</span><span class="sxs-lookup"><span data-stu-id="8e2cd-140">Using Generic Constructs</span></span>

<span data-ttu-id="8e2cd-141">Wenn Sie generische Funktionen oder Methoden verwenden, müssen Sie möglicherweise nicht die Typargumente angeben.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-141">When you use generic functions or methods, you might not have to specify the type arguments.</span></span> <span data-ttu-id="8e2cd-142">Der Compiler verwendet den Typrückschluss, um die entsprechenden Typargumente abzuleiten.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-142">The compiler uses type inference to infer the appropriate type arguments.</span></span> <span data-ttu-id="8e2cd-143">Wenn immer noch eine Mehrdeutigkeit vorliegt, können Sie Typargumente in spitzen Klammern angeben und mehrere Typargumente durch Kommas trennen.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-143">If there is still an ambiguity, you can supply type arguments in angle brackets, separating multiple type arguments with commas.</span></span>

<span data-ttu-id="8e2cd-144">Der folgende Code zeigt die Verwendung der Funktionen, die in den vorherigen Abschnitten definiert sind.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-144">The following code shows the use of the functions that are defined in the previous sections.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1702.fs)]

> [!NOTE]
> <span data-ttu-id="8e2cd-145">Es gibt zwei Möglichkeiten zum Verweisen auf einen generischen Typ anhand des Namens.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-145">There are two ways to refer to a generic type by name.</span></span> <span data-ttu-id="8e2cd-146">Beispielsweise sind `list<int>` und `int list` zwei Methoden zum Verweisen auf einen generischen Typ `list`, der über ein einzelnes Typargument `int` verfügt.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-146">For example, `list<int>` and `int list` are two ways to refer to a generic type `list` that has a single type argument `int`.</span></span> <span data-ttu-id="8e2cd-147">Die letztgenannte Form wird konventionell nur mit integrierten F#-Typen verwendet, wie z.B. `list` und `option`.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-147">The latter form is conventionally used only with built-in F# types such as `list` and `option`.</span></span> <span data-ttu-id="8e2cd-148">Wenn mehrere Typargumente vorhanden sind, verwenden Sie normalerweise die Syntax `Dictionary<int, string>`, aber Sie können auch die Syntax `(int, string) Dictionary` verwenden.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-148">If there are multiple type arguments, you normally use the syntax `Dictionary<int, string>` but you can also use the syntax `(int, string) Dictionary`.</span></span>

## <a name="wildcards-as-type-arguments"></a><span data-ttu-id="8e2cd-149">Platzhalter als Typargumente</span><span class="sxs-lookup"><span data-stu-id="8e2cd-149">Wildcards as Type Arguments</span></span>

<span data-ttu-id="8e2cd-150">Um anzugeben, dass ein Typargument vom Compiler abgeleitet werden soll, können Sie den Unterstrich bzw. das Platzhaltersymbol (`_`) anstatt eines benannten Typarguments verwenden.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-150">To specify that a type argument should be inferred by the compiler, you can use the underscore, or wildcard symbol (`_`), instead of a named type argument.</span></span> <span data-ttu-id="8e2cd-151">Dies wird im folgenden Code veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-151">This is shown in the following code.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1704.fs)]

## <a name="constraints-in-generic-types-and-functions"></a><span data-ttu-id="8e2cd-152">Einschränkungen bei generischen Typen und Funktionen</span><span class="sxs-lookup"><span data-stu-id="8e2cd-152">Constraints in Generic Types and Functions</span></span>

<span data-ttu-id="8e2cd-153">In einer generischen Typ- oder Funktionsdefinition können Sie nur diese Konstrukte verwenden, die bekanntermaßen für den generischen Typparameter verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-153">In a generic type or function definition, you can use only those constructs that are known to be available on the generic type parameter.</span></span> <span data-ttu-id="8e2cd-154">Dies ist erforderlich, um die Überprüfung von Funktions- und Methodenaufrufen zur Kompilierzeit zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-154">This is required to enable the verification of function and method calls at compile time.</span></span> <span data-ttu-id="8e2cd-155">Wenn Sie Ihre Typparameter explizit deklarieren, können Sie eine explizite Einschränkung für einen generischen Typparameter anwenden, um den Compiler zu informieren, dass bestimmte Methoden und Funktionen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-155">If you declare your type parameters explicitly, you can apply an explicit constraint to a generic type parameter to notify the compiler that certain methods and functions are available.</span></span> <span data-ttu-id="8e2cd-156">Wenn Sie F#-Compiler die generischen Parametertypen ableiten lassen, wird es jedoch die entsprechenden Einschränkungen für Sie bestimmen.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-156">However, if you allow the F# compiler to infer your generic parameter types, it will determine the appropriate constraints for you.</span></span> <span data-ttu-id="8e2cd-157">Weitere Informationen finden Sie unter [Einschränkungen](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="8e2cd-157">For more information, see [Constraints](constraints.md).</span></span>

## <a name="statically-resolved-type-parameters"></a><span data-ttu-id="8e2cd-158">Statisch aufgelöste Typparameter</span><span class="sxs-lookup"><span data-stu-id="8e2cd-158">Statically Resolved Type Parameters</span></span>

<span data-ttu-id="8e2cd-159">Es gibt zwei Arten von Typparametern, die in F#-Programmen verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-159">There are two kinds of type parameters that can be used in F# programs.</span></span> <span data-ttu-id="8e2cd-160">Die Ersten sind generische Typparameter der Art, die in den vorherigen Abschnitten beschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-160">The first are generic type parameters of the kind described in the previous sections.</span></span> <span data-ttu-id="8e2cd-161">Diese erste Art von Typparameter entspricht den generischen Typparametern, die in Sprachen wie Visual Basic und C# verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-161">This first kind of type parameter is equivalent to the generic type parameters that are used in languages such as Visual Basic and C#.</span></span> <span data-ttu-id="8e2cd-162">Eine andere Art von Typparameter ist für F# spezifisch und wird als ein *statisch aufgelöster Typparameter* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="8e2cd-162">Another kind of type parameter is specific to F# and is referred to as a *statically resolved type parameter*.</span></span> <span data-ttu-id="8e2cd-163">Informationen zu diesen Konstrukten finden Sie unter [Statisch aufgelöste Typparameter](statically-resolved-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="8e2cd-163">For information about these constructs, see [Statically Resolved Type Parameters](statically-resolved-type-parameters.md).</span></span>

## <a name="examples"></a><span data-ttu-id="8e2cd-164">Beispiele</span><span class="sxs-lookup"><span data-stu-id="8e2cd-164">Examples</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1705.fs)]

## <a name="see-also"></a><span data-ttu-id="8e2cd-165">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="8e2cd-165">See also</span></span>

- [<span data-ttu-id="8e2cd-166">Sprachreferenz</span><span class="sxs-lookup"><span data-stu-id="8e2cd-166">Language Reference</span></span>](../index.md)
- [<span data-ttu-id="8e2cd-167">Typen</span><span class="sxs-lookup"><span data-stu-id="8e2cd-167">Types</span></span>](../fsharp-types.md)
- [<span data-ttu-id="8e2cd-168">Statisch aufgelöste Typparameter</span><span class="sxs-lookup"><span data-stu-id="8e2cd-168">Statically Resolved Type Parameters</span></span>](statically-resolved-type-parameters.md)
- [<span data-ttu-id="8e2cd-169">Generika</span><span class="sxs-lookup"><span data-stu-id="8e2cd-169">Generics</span></span>](../../../standard/generics/index.md)
- [<span data-ttu-id="8e2cd-170">Automatische Verallgemeinerung</span><span class="sxs-lookup"><span data-stu-id="8e2cd-170">Automatic Generalization</span></span>](automatic-generalization.md)
- [<span data-ttu-id="8e2cd-171">Einschränkungen</span><span class="sxs-lookup"><span data-stu-id="8e2cd-171">Constraints</span></span>](constraints.md)
