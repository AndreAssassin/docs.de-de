---
title: Werte
description: Erfahren Sie, wie Werte in F# Mengen sind, die einen bestimmten Typ aufweisen.
ms.date: 05/16/2016
ms.openlocfilehash: 5c1d4f1e59cbf092911d99a725654042bf3383b1
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/23/2019
ms.locfileid: "61902186"
---
# <a name="values"></a><span data-ttu-id="fbdd9-103">Werte</span><span class="sxs-lookup"><span data-stu-id="fbdd9-103">Values</span></span>

<span data-ttu-id="fbdd9-104">Werte in F# sind Mengen, die einen bestimmten Typ aufweisen. Werte können Ganzzahlen oder Gleitkommazahlen, Zeichen oder Text, Listen, Sequenzen, Arrays, Tupeln, Unterscheidungs-Unions, Datensätze, Klassentypen oder Funktionswerte sein.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-104">Values in F# are quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</span></span>

## <a name="binding-a-value"></a><span data-ttu-id="fbdd9-105">Binden eines Werts</span><span class="sxs-lookup"><span data-stu-id="fbdd9-105">Binding a Value</span></span>

<span data-ttu-id="fbdd9-106">Der Begriff *Bindung* bezeichnet das Zuordnen eines Namens zu einer Definition.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-106">The term *binding* means associating a name with a definition.</span></span> <span data-ttu-id="fbdd9-107">Das `let`-Schlüsselwort bindet einen Wert, wie in den folgenden Beispielen:</span><span class="sxs-lookup"><span data-stu-id="fbdd9-107">The `let` keyword binds a value, as in the following examples:</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet601.fs)]

<span data-ttu-id="fbdd9-108">Der Typ eines Werts wird aus der Definition abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-108">The type of a value is inferred from the definition.</span></span> <span data-ttu-id="fbdd9-109">Für einen primitiven Datentyp, z.B. eine Ganzzahl oder Gleitkommazahl, wird der Typ vom Typ des Literals bestimmt.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-109">For a primitive type, such as an integral or floating point number, the type is determined from the type of the literal.</span></span> <span data-ttu-id="fbdd9-110">Aus diesem Grund leitet der Compiler im vorherigen Beispiel den Typ `b` ab, um `unsigned int` zu sein, hingegen leitet der Compiler den Typ `a` ab, damit er `int` wird.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-110">Therefore, in the previous example, the compiler infers the type of `b` to be `unsigned int`, whereas the compiler infers the type of `a` to be `int`.</span></span> <span data-ttu-id="fbdd9-111">Der Typ eines Funktionswerts wird anhand des Rückgabewerts im Funktionsrumpf bestimmt.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-111">The type of a function value is determined from the return value in the function body.</span></span> <span data-ttu-id="fbdd9-112">Weitere Informationen über Funktionswerttypen finden Sie unter [Funktionen](../functions/index.md).</span><span class="sxs-lookup"><span data-stu-id="fbdd9-112">For more information about function value types, see [Functions](../functions/index.md).</span></span> <span data-ttu-id="fbdd9-113">Weitere Informationen über Literaltypen finden Sie unter [Literale](../literals.md).</span><span class="sxs-lookup"><span data-stu-id="fbdd9-113">For more information about literal types, see [Literals](../literals.md).</span></span>

<span data-ttu-id="fbdd9-114">Der Compiler gibt keine Diagnose zu nicht verwendeten Bindungen standardmäßig aus.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-114">The compiler does not issue diagnostics about unused bindings by default.</span></span> <span data-ttu-id="fbdd9-115">Um diese Nachrichten erhalten, aktivieren Warnung 1182 in der Projektdatei oder beim Aufrufen des Compilers (finden Sie unter `--warnon` unter [Compileroptionen](../compiler-options.md)).</span><span class="sxs-lookup"><span data-stu-id="fbdd9-115">To receive these messages, enable warning 1182 in your project file or when invoking the compiler (see `--warnon` under [Compiler Options](../compiler-options.md)).</span></span>

## <a name="why-immutable"></a><span data-ttu-id="fbdd9-116">Warum unveränderlich?</span><span class="sxs-lookup"><span data-stu-id="fbdd9-116">Why Immutable?</span></span>

<span data-ttu-id="fbdd9-117">Unveränderliche Werte sind Werte, die im Verlauf der Ausführung des Programms nicht geändert werden können.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-117">Immutable values are values that cannot be changed throughout the course of a program's execution.</span></span> <span data-ttu-id="fbdd9-118">Wenn Sie an Sprachen wie C++, Visual Basic oder C# gewöhnt sind, finden Sie es möglicherweise überraschend, dass F# unveränderlichen Werte Vorrang gewährt, anstelle von Variablen, denen während der Ausführung eines Programms neue Werte zugeordnet werden können.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-118">If you are used to languages such as C++, Visual Basic, or C#, you might find it surprising that F# puts primacy over immutable values rather than variables that can be assigned new values during the execution of a program.</span></span> <span data-ttu-id="fbdd9-119">Unveränderliche Daten sind ein wichtiges Element der funktionalen Programmierung.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-119">Immutable data is an important element of functional programming.</span></span> <span data-ttu-id="fbdd9-120">In einer Multithreadumgebung sind freigegebene änderbare Variablen, die von vielen unterschiedlichen Threads geändert werden können, schwierig zu verwalten.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-120">In a multithreaded environment, shared mutable variables that can be changed by many different threads are difficult to manage.</span></span> <span data-ttu-id="fbdd9-121">Darüber hinaus kann man mit änderbaren Variablen manchmal nur schwer feststellen, ob eine Variable geändert werden kann, wenn sie an eine andere Funktion übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-121">Also, with mutable variables, it can sometimes be hard to tell if a variable might be changed when it is passed to another function.</span></span>

<span data-ttu-id="fbdd9-122">In reinen funktionalen Sprachen gibt es keine Variablen, und Funktionen verhalten sich genau wie mathematische Funktionen.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-122">In pure functional languages, there are no variables, and functions behave strictly as mathematical functions.</span></span> <span data-ttu-id="fbdd9-123">Wo Code in einer prozeduralen Sprache eine Zuweisung einer Variable verwendet, um einen Wert zu ändern, verfügt der entsprechende Code in einer funktionalen Sprache über einen unveränderlichen Wert, der die Eingabe ist, eine unveränderliche Funktion und über verschiedene unveränderliche Werte als Ausgabe.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-123">Where code in a procedural language uses a variable assignment to alter a value, the equivalent code in a functional language has an immutable value that is the input, an immutable function, and different immutable values as the output.</span></span> <span data-ttu-id="fbdd9-124">Diese mathematische Strenge ermöglicht genauere Schlussfolgerungen über das Verhalten des Programms.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-124">This mathematical strictness allows for tighter reasoning about the behavior of the program.</span></span> <span data-ttu-id="fbdd9-125">Diese Strenge ist der Grund dafür, dass Compiler Code präziser überprüfen und effizienter optimieren können, und es erleichtert Entwicklern das Verstehen und korrekte Schreiben von Code.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-125">This tighter reasoning is what enables compilers to check code more stringently and to optimize more effectively, and helps make it easier for developers to understand and write correct code.</span></span> <span data-ttu-id="fbdd9-126">Funktionaler Code ist daher häufig einfacher zu debuggen als gewöhnlicher prozeduraler Code.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-126">Functional code is therefore likely to be easier to debug than ordinary procedural code.</span></span>

<span data-ttu-id="fbdd9-127">F# ist keine rein funktionale Programmiersprache, aber unterstützt funktionale Programmierung umfassend.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-127">F# is not a pure functional language, yet it fully supports functional programming.</span></span> <span data-ttu-id="fbdd9-128">Die Verwendung von unveränderlichen Werten wird empfohlen, da Ihr Code dadurch von einem wichtigen Aspekt der funktionalen Programmierung profitieren kann.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-128">Using immutable values is a good practice because doing this allows your code to benefit from an important aspect of functional programming.</span></span>

## <a name="mutable-variables"></a><span data-ttu-id="fbdd9-129">Änderbare Variablen</span><span class="sxs-lookup"><span data-stu-id="fbdd9-129">Mutable Variables</span></span>

<span data-ttu-id="fbdd9-130">Sie können mithilfe des Schlüsselworts `mutable` eine Variable angeben, die geändert werden kann.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-130">You can use the keyword `mutable` to specify a variable that can be changed.</span></span> <span data-ttu-id="fbdd9-131">Änderbare Variablen in F# sollten grundsätzlich einen begrenzten Bereich haben, entweder als Feld eines Typs oder als lokaler Wert.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-131">Mutable variables in F# should generally have a limited scope, either as a field of a type or as a local value.</span></span> <span data-ttu-id="fbdd9-132">Änderbare Variablen mit einem begrenzten Gültigkeitsbereich sind einfacher zu steuern und werden seltener auf falsche Weise geändert.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-132">Mutable variables with a limited scope are easier to control and are less likely to be modified in incorrect ways.</span></span>

<span data-ttu-id="fbdd9-133">Sie können einen Anfangswert für eine änderbare Variable zuweisen, indem Sie das `let`-Schlüsselwort auf die gleiche Weise verwenden, wie Sie einen Wert definieren würden.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-133">You can assign an initial value to a mutable variable by using the `let` keyword in the same way as you would define a value.</span></span> <span data-ttu-id="fbdd9-134">Der Unterschied ist jedoch, dass Sie anschließend den änderbaren Variablen neue Werte zuweisen können, indem Sie den `<-`-Operator verwenden, wie im folgenden Beispiel.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-134">However, the difference is that you can subsequently assign new values to mutable variables by using the `<-` operator, as in the following example.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet602.fs)]

<span data-ttu-id="fbdd9-135">Werte, die markiert `mutable` automatisch auf heraufgestuft werden `'a ref` Wenn durch eine Closure erfasst, einschließlich Formularen, die z. B. Erstellen von Abschlüssen, `seq` Generatoren.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-135">Values marked `mutable` may be automatically promoted to `'a ref` if captured by a closure, including forms that create closures, such as `seq` builders.</span></span> <span data-ttu-id="fbdd9-136">Wenn Sie in diesem Fall benachrichtigt werden möchten, aktivieren Sie die Warnung 3180 in der Projektdatei oder beim Aufrufen des Compilers.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-136">If you wish to be notified when this occurs, enable warning 3180 in your project file or when invoking the compiler.</span></span>

## <a name="related-topics"></a><span data-ttu-id="fbdd9-137">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="fbdd9-137">Related Topics</span></span>

|<span data-ttu-id="fbdd9-138">Titel</span><span class="sxs-lookup"><span data-stu-id="fbdd9-138">Title</span></span>|<span data-ttu-id="fbdd9-139">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="fbdd9-139">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="fbdd9-140">let-Bindungen</span><span class="sxs-lookup"><span data-stu-id="fbdd9-140">let Bindings</span></span>](../functions/let-bindings.md)|<span data-ttu-id="fbdd9-141">Enthält Informationen zur Verwendung der `let` Schlüsselwort, um die Bindung von Namen an Werte und Funktionen.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-141">Provides information about using the `let` keyword to bind names to values and functions.</span></span>|
|[<span data-ttu-id="fbdd9-142">Funktionen</span><span class="sxs-lookup"><span data-stu-id="fbdd9-142">Functions</span></span>](../functions/index.md)|<span data-ttu-id="fbdd9-143">Bietet eine Übersicht über Funktionen in F#.</span><span class="sxs-lookup"><span data-stu-id="fbdd9-143">Provides an overview of functions in F#.</span></span>|

## <a name="see-also"></a><span data-ttu-id="fbdd9-144">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="fbdd9-144">See also</span></span>

- [<span data-ttu-id="fbdd9-145">NULL-Werte</span><span class="sxs-lookup"><span data-stu-id="fbdd9-145">Null Values</span></span>](null-Values.md)
- [<span data-ttu-id="fbdd9-146">F#-Sprachreferenz</span><span class="sxs-lookup"><span data-stu-id="fbdd9-146">F# Language Reference</span></span>](../index.md)